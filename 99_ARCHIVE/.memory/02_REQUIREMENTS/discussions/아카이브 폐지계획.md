📘 MCP 실행/아카이브 구조 전환 방향성 계획서
1. 배경 및 문제 인식
1.1 현재 문제

apply_req 기반 흐름에서 intake → plan_from_brief → execute로 전환 중

execute 단계에서 코드 생성/수정은 완료되나

RUN 아카이브 이동이 누락되는 사례 발생

RUN 아카이브(04_TASK_LOGS/archive)는

자동화 실패 지점이 많고

실제로 사람이 거의 조회하지 않음

1.2 관찰 결과

변경 이력과 증거는 이미 Git이 사실상 담당

RUN 아카이브는 “완료 표시용 문서 이동”에 그치며

단일 진실 소스(Single Source of Truth) 역할을 하지 못함

2. 핵심 결정 (Decision)
✅ 옵션 A 채택: 아카이브 폐지 + Git 중심 운영

RUN 문서는 모두 active에 유지

완료/실패 여부는 문서 이동이 아닌 Status 메타데이터로만 표현

변경 증거(Evidence)는 Git 커밋 기준으로 관리

RUN 아카이브 이동은 필수 동작에서 제거

3. 역할 재정의
3.1 Git의 역할 (Strong)

실제 변경 이력의 저장소

무엇이, 언제, 어떤 파일이 변경됐는지에 대한 증거

복구 및 추적의 기준점

3.2 RUN 문서의 역할 (Light)

변경의 의도(Intent) 요약

실행 범위와 검증 기준 명시

Git 커밋을 사람이 이해하기 위한 맥락 메타데이터

RUN = “왜 이 커밋이 존재하는가”를 설명하는 라벨

4. 실행 흐름(Workflow) 정리
4.1 표준 파이프라인
intake
 → plan_from_brief
 → execute

4.2 execute 단계 정의 (중요)

execute는 다음을 보장해야 함:

코드 생성/수정 수행

Git 커밋 생성 (또는 명시적 no-commit 기록)

RUN 문서 업데이트

Status: Completed / Failed

Completed 날짜

Evidence: Git 커밋 해시

※ RUN 이동(move)은 수행하지 않음

5. “사람이 보기 어려운 문제”에 대한 대응
5.1 원칙

파일은 이동하지 않는다

대신 사람이 보는 뷰(view)를 만든다

5.2 필수 도입 요소
(1) Active 대시보드 파일

위치: 04_TASK_LOGS/active/README.md

자동 생성/갱신

포함 내용:

최근 RUN N개 요약

상태별 요약 (Active / Completed / Failed)

각 RUN 1줄 요약:

Status | Started | Input(BRIEF) | Summary | Git

(2) RUN 메타데이터 최소 표준

모든 RUN에 아래 필드 강제:

> **Summary**: 사람용 1줄 요약

> **Git**: commit hash 또는 no-commit

> **Status**: Active / Completed / Failed

(3) CLI 기반 검색/필터

예시:

runs --status completed

runs --failed

runs --recent 10

사람은 README / CLI를 통해서만 탐색

6. 제거/완화되는 리스크
기존 리스크	변경 후
RUN 이동 실패	이동 자체 제거
실행 중 멈춤 시 기록 유실	Git 커밋으로 증거 보존
아카이브 누락	개념 자체 제거
완료 판단 불명확	Status + Git 기준
7. 단계별 이행 계획
Phase 1 (즉시)

finalize_run() 의존 제거

RUN 이동을 “필수 완료 조건”에서 제외

RUN에 Git Evidence 기록

Phase 2

active/README.md 대시보드 자동 생성

RUN Summary 필드 강제

Phase 3

CLI 인덱싱/필터 명령 추가

(선택) 월간 요약 리포트 생성

8. 결론

아카이브 문제의 본질은 “이동 실패”가 아니라 역할 과잉

증거는 Git, 맥락은 RUN, 가독성은 View로 분리

문서 이동 없는 구조가 자동화·신뢰성·운영 모두에서 최적