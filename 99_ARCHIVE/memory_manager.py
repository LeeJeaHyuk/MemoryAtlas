#!/usr/bin/env python3

import contextlib as __stickytape_contextlib

@__stickytape_contextlib.contextmanager
def __stickytape_temporary_dir():
    import tempfile
    import shutil
    dir_path = tempfile.mkdtemp()
    try:
        yield dir_path
    finally:
        shutil.rmtree(dir_path)

with __stickytape_temporary_dir() as __stickytape_working_dir:
    def __stickytape_write_module(path, contents):
        import os, os.path

        def make_package(path):
            parts = path.split("/")
            partial_path = __stickytape_working_dir
            for part in parts:
                partial_path = os.path.join(partial_path, part)
                if not os.path.exists(partial_path):
                    os.mkdir(partial_path)
                    with open(os.path.join(partial_path, "__init__.py"), "wb") as f:
                        f.write(b"\n")

        make_package(os.path.dirname(path))

        full_path = os.path.join(__stickytape_working_dir, path)
        with open(full_path, "wb") as module_file:
            module_file.write(contents)

    import sys as __stickytape_sys
    __stickytape_sys.path.insert(0, __stickytape_working_dir)

    __stickytape_write_module('core/__init__.py', b'')
    __stickytape_write_module('core/bootstrap.py', b'\nfrom pathlib import Path\n\nfrom core.config import (\n    BOOTSTRAP_CONVENTIONS_TEMPLATE,\n    BOOTSTRAP_GOALS_TEMPLATE,\n    BOOTSTRAP_PROMPT_TEMPLATE,\n    ROOT_DIR,\n)\n\ndef bootstrap_init(dry_run: bool = False) -> None:\n    """Create Bootstrap files for AI-driven project initialization.\n    \n    Context Bootstrapping (v2.4): AI\xea\xb0\x80 \xec\x82\xac\xec\x9a\xa9\xec\x9e\x90\xec\x99\x80 \xec\x9d\xb8\xed\x84\xb0\xeb\xb7\xb0\xeb\xa5\xbc \xed\x86\xb5\xed\x95\xb4\n    \xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8 \xed\x97\x8c\xeb\xb2\x95(CONVENTIONS, GOALS)\xec\x9d\x84 \xec\x9e\x91\xec\x84\xb1\xed\x95\x98\xeb\x8f\x84\xeb\xa1\x9d \xec\x9c\xa0\xeb\x8f\x84\xed\x95\x98\xeb\x8a\x94 \xea\xb8\xb0\xeb\x8a\xa5.\n    \n    Creates:\n        - BOOTSTRAP_PROMPT.md: AI \xed\x82\xa5\xec\x98\xa4\xed\x94\x84 \xeb\xaf\xb8\xed\x8c\x85 \xec\x95\x84\xec\xa0\xa0\xeb\x8b\xa4\n        - 01_CONTEXT/CONVENTIONS.md: [TODO] \xed\x85\x9c\xed\x94\x8c\xeb\xa6\xbf (AI\xea\xb0\x80 \xec\xb1\x84\xec\x9b\x80)\n        - 01_CONTEXT/GOALS.md: [TODO] \xed\x85\x9c\xed\x94\x8c\xeb\xa6\xbf (AI\xea\xb0\x80 \xec\xb1\x84\xec\x9b\x80)\n    """\n    bootstrap_dir = Path(ROOT_DIR)\n    context_dir = bootstrap_dir / "01_CONTEXT"\n    \n    # Ensure base structure exists\n    bootstrap_dir.mkdir(exist_ok=True)\n    context_dir.mkdir(exist_ok=True)\n    \n    files_to_create = {\n        bootstrap_dir / "BOOTSTRAP_PROMPT.md": BOOTSTRAP_PROMPT_TEMPLATE,\n        context_dir / "CONVENTIONS.md": BOOTSTRAP_CONVENTIONS_TEMPLATE,\n        context_dir / "GOALS.md": BOOTSTRAP_GOALS_TEMPLATE,\n    }\n    \n    print("\\n" + "=" * 60)\n    print("\xf0\x9f\x9a\x80 Context Bootstrapping (v2.4)")\n    print("=" * 60)\n    \n    for filepath, content in files_to_create.items():\n        if filepath.exists():\n            print(f"  [SKIP] {filepath} (already exists)")\n            continue\n        \n        if dry_run:\n            print(f"  [DRY-RUN] Would create: {filepath}")\n        else:\n            filepath.write_text(content, encoding="utf-8")\n            print(f"  [CREATE] {filepath}")\n    \n    print("\\n" + "-" * 60)\n    print("\xf0\x9f\x93\x8b \xeb\x8b\xa4\xec\x9d\x8c \xeb\x8b\xa8\xea\xb3\x84:")\n    print("   1. BOOTSTRAP_PROMPT.md\xeb\xa5\xbc AI \xec\x97\x90\xec\x9d\xb4\xec\xa0\x84\xed\x8a\xb8\xec\x97\x90\xea\xb2\x8c \xec\xa0\x84\xeb\x8b\xac\xed\x95\x98\xec\x84\xb8\xec\x9a\x94")\n    print("   2. AI\xea\xb0\x80 \xec\xa7\x88\xeb\xac\xb8\xed\x95\x98\xeb\xa9\xb4 \xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8\xec\x97\x90 \xeb\xa7\x9e\xea\xb2\x8c \xeb\x8b\xb5\xeb\xb3\x80\xed\x95\x98\xec\x84\xb8\xec\x9a\x94")\n    print("   3. AI\xea\xb0\x80 CONVENTIONS.md\xec\x99\x80 GOALS.md\xeb\xa5\xbc \xec\x99\x84\xec\x84\xb1\xed\x95\xa9\xeb\x8b\x88\xeb\x8b\xa4")\n    print("   4. \xec\x99\x84\xeb\xa3\x8c \xed\x9b\x84 `python memory_manager.py --update`\xeb\xa1\x9c \xeb\x82\x98\xeb\xa8\xb8\xec\xa7\x80 \xea\xb5\xac\xec\xa1\xb0 \xec\x83\x9d\xec\x84\xb1")\n    print("-" * 60 + "\\n")\n')
    __stickytape_write_module('core/config.py', b'\nimport re\n\nCURRENT_VERSION = "3.4.1"\nROOT_DIR = ".memory"\nTEMPLATE_VERSION = "3.4"  # Template schema version (Quick Start + Direct Execute)\n\n# ============================================================================\n# STRUCTURE (v3.1) - Capabilities, Invariants & Competencies Edition\n# ============================================================================\n# .memory/\n# \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 00_INBOX/                   # [\xec\x88\x98\xec\x8b\xa0\xed\x95\xa8] \xec\x82\xac\xec\x9a\xa9\xec\x9e\x90 \xec\x9a\x94\xec\xb2\xad/\xec\x95\x84\xec\x9d\xb4\xeb\x94\x94\xec\x96\xb4 (intake \xeb\x8c\x80\xec\x83\x81)\n# \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 00_SYSTEM/                  # \xec\x8b\x9c\xec\x8a\xa4\xed\x85\x9c \xea\xb4\x80\xeb\xa6\xac (\xec\x8b\x9c\xec\x8a\xa4\xed\x85\x9c\xeb\xa7\x8c \xec\x88\x98\xec\xa0\x95)\n# \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 01_PROJECT_CONTEXT/         # [\xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8 \xed\x97\x8c\xeb\xb2\x95]\n# \xe2\x94\x82   \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 00_GOALS.md\n# \xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 01_CONVENTIONS.md\n# \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 02_REQUIREMENTS/            # [WHAT: Authority Layer]\n# \xe2\x94\x82   \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 capabilities/           # REQ-* (\xea\xb8\xb0\xeb\x8a\xa5/\xed\x96\x89\xeb\x8f\x99 - "\xec\x8b\x9c\xec\x8a\xa4\xed\x85\x9c\xec\x9d\x80 ~\xed\x95\xb4\xec\x95\xbc \xed\x95\x9c\xeb\x8b\xa4")\n# \xe2\x94\x82   \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 invariants/             # RULE-* (\xeb\xb6\x88\xeb\xb3\x80 \xea\xb7\x9c\xec\xb9\x99 - "\xed\x95\xad\xec\x83\x81 ~\xec\x9d\xb4\xeb\x8b\xa4")\n# \xe2\x94\x82   \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 competencies/           # CQ-* (\xec\x97\xad\xeb\x9f\x89 \xec\xa7\x88\xeb\xac\xb8 - "\xec\x8b\x9c\xec\x8a\xa4\xed\x85\x9c\xec\x9d\x80 ~\xec\x97\x90 \xeb\x8b\xb5\xed\x95\xa0 \xec\x88\x98 \xec\x9e\x88\xeb\x8a\x94\xea\xb0\x80?")\n# \xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 discussions/            # DISC-* (\xec\xa1\xb0\xec\x9c\xa8 \xea\xb8\xb0\xeb\xa1\x9d, LLM \xea\xb8\xb0\xeb\xb3\xb8 \xeb\xac\xb4\xec\x8b\x9c)\n# \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 03_TECH_SPECS/              # [HOW: \xea\xb0\x9c\xeb\xb0\x9c\xec\x9e\x90\xec\x9d\x98 \xec\x98\x81\xec\x97\xad]\n# \xe2\x94\x82   \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 architecture/\n# \xe2\x94\x82   \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 api_specs/\n# \xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 decisions/              # ADR-* (RATIONALE)\n# \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 04_TASK_LOGS/               # [HISTORY: Execution Layer]\n# \xe2\x94\x82   \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 active/                 # RUN-* (\xec\x8b\xa4\xed\x96\x89 \xeb\x8b\xa8\xec\x9c\x84)\n# \xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 archive/\n# \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 98_KNOWLEDGE/               # [ASSET: \xeb\xb0\xb0\xec\x9a\xb4 \xec\xa0\x90]\n#     \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 troubleshooting/\n# ============================================================================\n\nDIRS = [\n    "00_INBOX",\n    "00_SYSTEM/scripts",\n    "00_SYSTEM/mcp",\n    "00_SYSTEM/mcp/templates",\n    "00_SYSTEM/state",\n    "01_PROJECT_CONTEXT",\n    "02_REQUIREMENTS/capabilities",\n    "02_REQUIREMENTS/invariants",\n    "02_REQUIREMENTS/competencies",\n    "02_REQUIREMENTS/discussions",\n    "02_REQUIREMENTS/discussions/briefs",\n    "03_TECH_SPECS/architecture",\n    "03_TECH_SPECS/api_specs",\n    "03_TECH_SPECS/decisions",\n    "04_TASK_LOGS/active",\n    "04_TASK_LOGS/archive",\n    "98_KNOWLEDGE/troubleshooting",\n    "99_ARCHIVE",\n    "99_ARCHIVE/discussions",\n]\n\n# ============================================================================\n# LINT / CHECK CONFIGURATION\n# ============================================================================\nLINT_DIRS = [\n    "01_PROJECT_CONTEXT",\n    "02_REQUIREMENTS/capabilities",\n    "02_REQUIREMENTS/invariants",\n    "02_REQUIREMENTS/competencies",\n    "02_REQUIREMENTS/discussions",\n    "04_TASK_LOGS/active",\n]\n\nLINK_SCAN_DIRS = [\n    "01_PROJECT_CONTEXT",\n    "02_REQUIREMENTS",\n    "03_TECH_SPECS",\n    "04_TASK_LOGS",\n]\n\nREQ_SCAN_DIRS = [\n    "02_REQUIREMENTS/capabilities",\n    "02_REQUIREMENTS/invariants",\n    "02_REQUIREMENTS/competencies",\n]\n\nRUN_SCAN_DIRS = [\n    "04_TASK_LOGS/active",\n]\n\n\nBRIEF_SCAN_DIRS = [\n    "02_REQUIREMENTS/discussions/briefs",\n]\n\nLINT_SKIP_FILES = {"README.md", "00_INDEX.md", "_index.md"}\n\n# Document type-specific header requirements\nHEADER_FIELDS_BY_TYPE = {\n    "default": ["**ID**", "**Last Updated**"],\n    "capabilities": ["**ID**", "**Domain**", "**Status**", "**Last Updated**", "**Must-Read**"],\n    "invariants": ["**ID**", "**Domain**", "**Priority**", "**Last Updated**", "**Must-Read**"],\n    "competencies": ["**ID**", "**Domain**", "**Status**", "**Last Updated**"],\n    "decisions": ["**Status**", "**Date**"],\n    "discussions": ["**ID**", "**Related-REQ**", "**Date**"],\n    "runs": ["**ID**", "**Input**", "**Verification**"],\n    "briefs": ["**ID**", "**Date**"],\n}\n\n# ID patterns\nREQ_ID_PATTERN = re.compile(r"^REQ-([A-Z]+)-(\\d{3})$")\nRULE_ID_PATTERN = re.compile(r"^RULE-([A-Z]+)-(\\d{3})$")\nCQ_ID_PATTERN = re.compile(r"^CQ-([A-Z]+)-(\\d{3})$")\nADR_ID_PATTERN = re.compile(r"^ADR-(\\d{3})$")\nDISC_ID_PATTERN = re.compile(r"^DISC-([A-Z]+)-(\\d{3})$")\nRUN_ID_PATTERN = re.compile(r"^RUN-(REQ|RULE|BRIEF)-([A-Z]+)-(\\d{3})-step-(\\d{2})$")\nBRIEF_ID_PATTERN = re.compile(r"^BRIEF-([A-Z]+)-(\\d{3})$")\n\n# Regex patterns\nLINK_RE = re.compile(r"\\[[^\\]]*\\]\\(([^)]+)\\)")\n\n# Authority source: **ID**: line in document metadata\n# Fix A: Include ADR in META_ID_RE\nMETA_ID_RE = re.compile(r"^\\s*>\\s*\\*\\*ID\\*\\*:\\s*((?:REQ|RULE|CQ|DISC|RUN|ADR|BRIEF)-[A-Z0-9-]+(?:-step-\\d{2})?)\\s*$", re.M)\n\n# Must-Read field (v2.2)\nMUST_READ_RE = re.compile(r"^\\s*>\\s*\\*\\*Must-Read\\*\\*:\\s*(.+)$", re.M)\nMUST_READ_ANY_ID_RE = re.compile(r"(?:REQ|RULE|CQ|DISC|CTX)-[A-Z]+-\\d{3}|ADR-\\d{3}")\nMUST_READ_ALLOWED_ID_RE = re.compile(r"(?:RULE)-[A-Z]+-\\d{3}|ADR-\\d{3}")\nMUST_READ_LINK_RE = re.compile(r"\\[([^\\]]+)\\]\\(([^)]+)\\)")\n\n# Header patterns (v2.2.1: Support H1-H3, i.e. #, ##, ###)\n# P0 fix: Templates use # [REQ-...] (H1), so regex must match #{1,3}\nREQ_HEADER_RE = re.compile(r"^#{1,3}\\s+\\[(REQ-[A-Z]+-\\d{3})\\]", re.M)\nRULE_HEADER_RE = re.compile(r"^#{1,3}\\s+\\[(RULE-[A-Z]+-\\d{3})\\]", re.M)\nCQ_HEADER_RE = re.compile(r"^#{1,3}\\s+\\[(CQ-[A-Z]+-\\d{3})\\]", re.M)\nRUN_HEADER_RE = re.compile(r"^#{1,3}\\s+\\[(RUN-(?:REQ|RULE|BRIEF)-[A-Z]+-\\d{3}-step-\\d{2})\\]", re.M)\nDISC_HEADER_RE = re.compile(r"^#{1,3}\\s+\\[(DISC-[A-Z]+-\\d{3})\\]", re.M)\nBRIEF_HEADER_RE = re.compile(r"^#{1,3}\\s+\\[(BRIEF-[A-Z]+-\\d{3})\\]", re.M)\n\n# RUN document sections (v2.2)\nRUN_INPUT_RE = re.compile(r"^\\s*>\\s*\\*\\*Input\\*\\*:\\s*(.+)$", re.M)\nRUN_VERIFICATION_RE = re.compile(r"^\\s*>\\s*\\*\\*Verification\\*\\*:\\s*(.+)$", re.M)\n# Fix D: Support H3 Output (### Output)\nRUN_OUTPUT_RE = re.compile(r"^#{2,3}\\s*Output", re.M)\n\nCHECKBOX_RE = re.compile(r"^\\s*-\\s*\\[[ xX]\\]", re.M)\n\n# ============================================================================\n# DOC TEMPLATES (v2.3) - Smart Spec Edition\n# ============================================================================\nDOC_TEMPLATES = {\n    # =========================================================================\n    # ROOT INDEX\n    # =========================================================================\n    "00_INDEX.md": f"""# Project Memory Index\n\n> Entry point for Memory-Driven Development in this repo.\n> **Version**: {CURRENT_VERSION} (Smart Spec Edition)\n> **Template Version**: {TEMPLATE_VERSION}\n\n## Capabilities, Invariants & Competencies Model (v3.1)\n\n```\n02_REQUIREMENTS/ \xea\xb5\xac\xec\xa1\xb0:\n  capabilities/   - REQ-* (\xea\xb8\xb0\xeb\x8a\xa5/\xed\x96\x89\xeb\x8f\x99) "\xec\x8b\x9c\xec\x8a\xa4\xed\x85\x9c\xec\x9d\x80 ~\xed\x95\xb4\xec\x95\xbc \xed\x95\x9c\xeb\x8b\xa4"\n  invariants/     - RULE-* (\xeb\xb6\x88\xeb\xb3\x80 \xea\xb7\x9c\xec\xb9\x99) "\xed\x95\xad\xec\x83\x81 ~\xec\x9d\xb4\xeb\x8b\xa4 / ~\xeb\x8a\x94 \xea\xb8\x88\xec\xa7\x80"\n  competencies/  - CQ-* (\xec\x97\xad\xeb\x9f\x89 \xec\xa7\x88\xeb\xac\xb8) "\xec\x8b\x9c\xec\x8a\xa4\xed\x85\x9c\xec\x9d\x80 ~\xec\x97\x90 \xeb\x8b\xb5\xed\x95\xa0 \xec\x88\x98 \xec\x9e\x88\xeb\x8a\x94\xea\xb0\x80?"\n  discussions/    - DISC-* (\xec\xa1\xb0\xec\x9c\xa8 \xea\xb8\xb0\xeb\xa1\x9d) LLM \xea\xb8\xb0\xeb\xb3\xb8 \xeb\xac\xb4\xec\x8b\x9c\n\nREQ vs RULE vs CQ \xed\x8c\x90\xec\xa0\x95:\n  REQ  = Input/Output/Acceptance Criteria \xed\x95\x84\xec\x88\x98 (\xeb\x8f\x99\xec\x9e\x91 \xec\xa4\x91\xec\x8b\xac)\n  RULE = Scope/Violation/Examples \xed\x95\x84\xec\x88\x98 (\xeb\xb6\x88\xeb\xb3\x80 \xec\xa4\x91\xec\x8b\xac)\n  CQ   = Question/Expected Answer/Traceability \xed\x95\x84\xec\x88\x98 (\xea\xb2\x80\xec\xa6\x9d \xec\xa4\x91\xec\x8b\xac)\n```\n\n## Quick Navigation\n\n| Folder | Purpose | Authority Level |\n|--------|---------|-----------------|\n| `01_PROJECT_CONTEXT/` | \xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8 \xed\x97\x8c\xeb\xb2\x95 + **Boundaries** | Constitution |\n| `02_REQUIREMENTS/capabilities/` | \xea\xb8\xb0\xeb\x8a\xa5 **\xea\xb2\xb0\xec\xa0\x95** (REQ-*) | Authority |\n| `02_REQUIREMENTS/invariants/` | \xeb\xb6\x88\xeb\xb3\x80 \xea\xb7\x9c\xec\xb9\x99 **\xea\xb2\xb0\xec\xa0\x95** (RULE-*) | Authority |\n| `02_REQUIREMENTS/competencies/` | \xec\x97\xad\xeb\x9f\x89 \xec\xa7\x88\xeb\xac\xb8 **\xea\xb2\x80\xec\xa6\x9d** (CQ-*) | Authority |\n| `02_REQUIREMENTS/discussions/` | \xec\xa1\xb0\xec\x9c\xa8 \xea\xb8\xb0\xeb\xa1\x9d (DISC-*) | Reference |\n| `03_TECH_SPECS/` | \xea\xb8\xb0\xec\x88\xa0 \xec\x84\xa4\xea\xb3\x84 & ADR | Implementation |\n| `04_TASK_LOGS/` | \xec\x8b\xa4\xed\x96\x89 \xea\xb8\xb0\xeb\xa1\x9d (RUN-*) | Execution |\n| `98_KNOWLEDGE/` | \xeb\xb0\xb0\xec\x9a\xb4 \xec\xa0\x90 | Asset |\n\n## Start Here (For AI Agents)\n\n### Reading Priority (P0 = Must Read)\n1. **P0**: `01_PROJECT_CONTEXT/01_CONVENTIONS.md` - **\xed\x8a\xb9\xed\x9e\x88 Boundaries \xec\x84\xb9\xec\x85\x98** \xe2\xad\x90\n2. **P0**: Target REQ\'s `**Must-Read**` field\n3. **P1**: `02_REQUIREMENTS/invariants/` (all active)\n4. **P1.5**: `02_REQUIREMENTS/competencies/` (referenced CQs only)\n5. **P2**: `98_KNOWLEDGE/` (if complex feature)\n\n## 3-Step Workflow (Intake \xe2\x86\x92 Plan \xe2\x86\x92 Finish)\n\n1. **Intake**: \xec\x83\x9d\xea\xb0\x81/\xeb\xa9\x94\xeb\xaa\xa8 \xe2\x86\x92 BRIEF \xec\x83\x9d\xec\x84\xb1 (`02_REQUIREMENTS/discussions/briefs/`)\n2. **Plan**: BRIEF \xe2\x86\x92 RUN \xec\x83\x9d\xec\x84\xb1 (`04_TASK_LOGS/active/`)\n3. **Finish**: \xea\xb5\xac\xed\x98\x84 \xec\x99\x84\xeb\xa3\x8c \xe2\x86\x92 Status \xec\x97\x85\xeb\x8d\xb0\xec\x9d\xb4\xed\x8a\xb8 + Git \xec\xa6\x9d\xea\xb1\xb0\n\n> MCP \xeb\x8f\x84\xea\xb5\xac: `intake()` \xe2\x86\x92 `plan()` \xe2\x86\x92 `finish()`\n\n### Execution Checklist\n1. [ ] **Intake**: BRIEF \xec\x83\x9d\xec\x84\xb1 \xeb\xb0\x8f \xea\xb2\x80\xed\x86\xa0\n2. [ ] **Plan**: RUN \xeb\xac\xb8\xec\x84\x9c \xec\x83\x9d\xec\x84\xb1 \xeb\xb0\x8f \xea\xb2\x80\xed\x86\xa0\n3. [ ] \xea\xb5\xac\xed\x98\x84 \xe2\x86\x92 \xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xe2\x86\x92 Git \xec\xbb\xa4\xeb\xb0\x8b\n4. [ ] **Finish**: Self-Check \xed\x86\xb5\xea\xb3\xbc \xed\x9b\x84 finish() \xed\x98\xb8\xec\xb6\x9c (Status \xe2\x86\x92 Completed)\n\n## Quick Start (MCP \xeb\x8f\x84\xea\xb5\xac \xec\x82\xac\xec\x9a\xa9\xeb\xb2\x95)\n\n### 1. "Intake \xed\x95\xb4\xec\xa4\x98"\n```python\nintake("\xec\x82\xac\xec\x9a\xa9\xec\x9e\x90 \xec\x9a\x94\xec\xb2\xad \xeb\x82\xb4\xec\x9a\xa9", domain="GEN")\n```\n\xe2\x86\x92 \xeb\xb0\x98\xed\x99\x98: BRIEF \xed\x8c\x8c\xec\x9d\xbc \xea\xb2\xbd\xeb\xa1\x9c (\xec\x98\x88: `BRIEF-GEN-001`)\n\n### 2. "Plan \xeb\xa7\x8c\xeb\x93\xa4\xec\x96\xb4\xec\xa4\x98"\n```python\nplan("BRIEF-GEN-001")\n```\n\xe2\x86\x92 \xeb\xb0\x98\xed\x99\x98: RUN ID (\xec\x98\x88: `RUN-BRIEF-GEN-001-step-01`)\n\n### 3. "\xec\x9e\x91\xec\x97\x85 \xec\x99\x84\xeb\xa3\x8c"\n1. RUN \xeb\xac\xb8\xec\x84\x9c\xec\x9d\x98 Steps \xec\x8b\xa4\xed\x96\x89\n2. Self-Check \xed\x99\x95\xec\x9d\xb8\n3. Git \xec\xbb\xa4\xeb\xb0\x8b \xec\x83\x9d\xec\x84\xb1\n4. \xec\x99\x84\xeb\xa3\x8c \xed\x9b\x84:\n```python\nfinish("RUN-BRIEF-GEN-001-step-01", git_hash="abc123")\n```\n\xe2\x86\x92 Status\xea\xb0\x80 Completed\xeb\xa1\x9c \xeb\xb3\x80\xea\xb2\xbd + Git \xec\xa6\x9d\xea\xb1\xb0 \xea\xb8\xb0\xeb\xa1\x9d\n\n### \xec\x98\x88\xec\x8b\x9c \xeb\x8c\x80\xed\x99\x94\n```\nUser: "\xeb\xa1\x9c\xea\xb7\xb8\xec\x9d\xb8 \xea\xb8\xb0\xeb\x8a\xa5 \xec\xb6\x94\xea\xb0\x80\xed\x95\xb4\xec\xa4\x98. intake \xed\x95\xb4"\nLLM:  intake("\xeb\xa1\x9c\xea\xb7\xb8\xec\x9d\xb8 \xea\xb8\xb0\xeb\x8a\xa5 \xec\xb6\x94\xea\xb0\x80", domain="AUTH") \xed\x98\xb8\xec\xb6\x9c\nLLM:  BRIEF \xec\x83\x9d\xec\x84\xb1 \xe2\x86\x92 \xec\x82\xac\xec\x9a\xa9\xec\x9e\x90 \xea\xb2\x80\xed\x86\xa0 \xec\x9a\x94\xec\xb2\xad\nUser: "plan \xeb\xa7\x8c\xeb\x93\xa4\xec\x96\xb4"\nLLM:  plan("BRIEF-AUTH-001") \xed\x98\xb8\xec\xb6\x9c\nLLM:  RUN \xec\x83\x9d\xec\x84\xb1 \xe2\x86\x92 \xec\x82\xac\xec\x9a\xa9\xec\x9e\x90 \xea\xb2\x80\xed\x86\xa0 \xec\x9a\x94\xec\xb2\xad\nUser: "run \xed\x95\xb4"\nLLM:  RUN Steps \xec\x8b\xa4\xed\x96\x89 \xe2\x86\x92 Self-Check \xe2\x86\x92 finish()\n```\n\n## Manual Fallback (MCP \xec\x97\x86\xec\x9d\xb4)\n\nMCP \xeb\x8f\x84\xea\xb5\xac \xec\x82\xac\xec\x9a\xa9\xec\x9d\xb4 \xeb\xb6\x88\xea\xb0\x80\xeb\x8a\xa5\xed\x95\x98\xea\xb1\xb0\xeb\x82\x98 \xec\x9b\x90\xed\x95\x98\xec\xa7\x80 \xec\x95\x8a\xeb\x8a\x94 \xea\xb2\xbd\xec\x9a\xb0, \xeb\x8f\x99\xec\x9d\xbc\xed\x95\x9c \xec\x9b\x8c\xed\x81\xac\xed\x94\x8c\xeb\xa1\x9c\xec\x9a\xb0\xeb\xa5\xbc \xec\x88\x98\xeb\x8f\x99\xec\x9c\xbc\xeb\xa1\x9c \xec\x88\x98\xed\x96\x89\xed\x95\xa0 \xec\x88\x98 \xec\x9e\x88\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4.\n\n### 1. BRIEF \xec\xa7\x81\xec\xa0\x91 \xec\x9e\x91\xec\x84\xb1\n- **\xed\x85\x9c\xed\x94\x8c\xeb\xa6\xbf**: `02_REQUIREMENTS/discussions/briefs/README.md` \xec\xb0\xb8\xec\xa1\xb0\n- **\xec\x9c\x84\xec\xb9\x98**: `02_REQUIREMENTS/discussions/briefs/BRIEF-DOMAIN-001.md`\n- **\xed\x95\x84\xec\x88\x98 \xec\x84\xb9\xec\x85\x98**: User Request, Intent Summary, Affected Artifacts, Proposed Changes, Verification Criteria\n\n### 2. REQ/RUN \xec\xa7\x81\xec\xa0\x91 \xec\x9e\x91\xec\x84\xb1\n- **REQ \xed\x85\x9c\xed\x94\x8c\xeb\xa6\xbf**: `02_REQUIREMENTS/capabilities/README.md` \xec\xb0\xb8\xec\xa1\xb0\n- **REQ \xec\x9c\x84\xec\xb9\x98**: `02_REQUIREMENTS/capabilities/REQ-DOMAIN-001.md`\n- **RUN \xed\x85\x9c\xed\x94\x8c\xeb\xa6\xbf**: `04_TASK_LOGS/active/README.md` \xec\xb0\xb8\xec\xa1\xb0\n- **RUN \xec\x9c\x84\xec\xb9\x98**: `04_TASK_LOGS/active/RUN-BRIEF-DOMAIN-001-step-01.md`\n\n### 3. \xec\x99\x84\xeb\xa3\x8c \xec\xb2\x98\xeb\xa6\xac (\xec\x88\x98\xeb\x8f\x99)\n- RUN \xeb\xac\xb8\xec\x84\x9c\xec\x9d\x98 Status\xeb\xa5\xbc `Completed` \xeb\x98\x90\xeb\x8a\x94 `Failed`\xeb\xa1\x9c \xeb\xb3\x80\xea\xb2\xbd\n- Git \xec\xbb\xa4\xeb\xb0\x8b \xed\x95\xb4\xec\x8b\x9c\xeb\xa5\xbc Evidence\xec\x97\x90 \xea\xb8\xb0\xeb\xa1\x9d\n- RUN\xec\x9d\x80 `active/`\xec\x97\x90 \xec\x9c\xa0\xec\xa7\x80 (\xec\x9d\xb4\xeb\x8f\x99 \xec\x97\x86\xec\x9d\x8c)\n\n> \xe2\x9a\xa0\xef\xb8\x8f MCP \xeb\x8f\x84\xea\xb5\xac \xec\x82\xac\xec\x9a\xa9\xec\x9d\xb4 \xea\xb6\x8c\xec\x9e\xa5\xeb\x90\xa9\xeb\x8b\x88\xeb\x8b\xa4. \xec\x88\x98\xeb\x8f\x99 \xed\x94\x84\xeb\xa1\x9c\xec\x84\xb8\xec\x8a\xa4\xeb\x8a\x94 \xeb\x8f\x99\xec\x9d\xbc\xed\x95\x9c \xea\xb2\xb0\xea\xb3\xbc\xeb\xa5\xbc \xeb\xa7\x8c\xeb\x93\xa4\xec\xa7\x80\xeb\xa7\x8c \xeb\x8d\x94 \xeb\xa7\x8e\xec\x9d\x80 \xec\x9e\x91\xec\x97\x85\xec\x9d\xb4 \xed\x95\x84\xec\x9a\x94\xed\x95\xa9\xeb\x8b\x88\xeb\x8b\xa4.\n\n## Direct Execute (\xea\xb0\x84\xeb\x8b\xa8\xed\x95\x9c \xec\x9e\x91\xec\x97\x85)\n\n\xeb\x8b\xa4\xec\x9d\x8c \xec\xa1\xb0\xea\xb1\xb4\xec\x9d\x84 **\xeb\xaa\xa8\xeb\x91\x90** \xeb\xa7\x8c\xec\xa1\xb1\xed\x95\x98\xeb\xa9\xb4 BRIEF/RUN \xec\x97\x86\xec\x9d\xb4 \xeb\xb0\x94\xeb\xa1\x9c \xec\x8b\xa4\xed\x96\x89 \xea\xb0\x80\xeb\x8a\xa5:\n\n### Skip \xea\xb0\x80\xeb\x8a\xa5 \xec\xa1\xb0\xea\xb1\xb4\n- \xeb\x8b\xa8\xec\x9d\xbc \xed\x8c\x8c\xec\x9d\xbc \xec\x88\x98\xec\xa0\x95\n- \xec\x95\x84\xed\x82\xa4\xed\x85\x8d\xec\xb2\x98 \xec\x98\x81\xed\x96\xa5 \xec\x97\x86\xec\x9d\x8c\n- \xeb\xaa\x85\xeb\xb0\xb1\xed\x95\x9c \xeb\xb3\x80\xea\xb2\xbd (typo \xec\x88\x98\xec\xa0\x95, \xeb\x8b\xa8\xec\x88\x9c \xeb\xb2\x84\xea\xb7\xb8 \xed\x94\xbd\xec\x8a\xa4)\n- \xec\x83\x88 \xec\x9d\x98\xec\xa1\xb4\xec\x84\xb1 \xec\x97\x86\xec\x9d\x8c\n- \xea\xb2\x80\xec\xa6\x9d\xec\x9d\xb4 \xec\x9e\x90\xeb\xaa\x85\xed\x95\xa8 (\xec\x97\x90\xeb\x9f\xac \xed\x95\xb4\xea\xb2\xb0 = \xec\x84\xb1\xea\xb3\xb5)\n\n### \xec\x98\x88\xec\x8b\x9c\n| \xec\x9e\x91\xec\x97\x85 | \xea\xb2\xbd\xeb\xa1\x9c |\n|------|------|\n| README \xec\x98\xa4\xed\x83\x80 \xec\x88\x98\xec\xa0\x95 | \xe2\x9c\x85 Direct Execute |\n| \xeb\xa1\x9c\xea\xb7\xb8 \xeb\xa9\x94\xec\x8b\x9c\xec\xa7\x80 \xec\xb6\x94\xea\xb0\x80 | \xe2\x9c\x85 Direct Execute |\n| \xeb\x8b\xa8\xec\x88\x9c import \xec\x88\x98\xec\xa0\x95 | \xe2\x9c\x85 Direct Execute |\n| \xec\x83\x88 API \xec\x97\x94\xeb\x93\x9c\xed\x8f\xac\xec\x9d\xb8\xed\x8a\xb8 | \xe2\x9d\x8c 3-Phase \xed\x95\x84\xec\x9a\x94 |\n| \xec\x9d\xb8\xec\xa6\x9d \xeb\xa1\x9c\xec\xa7\x81 \xeb\xb3\x80\xea\xb2\xbd | \xe2\x9d\x8c 3-Phase \xed\x95\x84\xec\x9a\x94 |\n| \xeb\x8b\xa4\xec\xa4\x91 \xed\x8c\x8c\xec\x9d\xbc \xeb\xa6\xac\xed\x8c\xa9\xed\x86\xa0\xeb\xa7\x81 | \xe2\x9d\x8c 3-Phase \xed\x95\x84\xec\x9a\x94 |\n\n### \xec\xa3\xbc\xec\x9d\x98\xec\x82\xac\xed\x95\xad\n- Skip \xec\x8b\x9c\xec\x97\x90\xeb\x8f\x84 **\xec\xbb\xa4\xeb\xb0\x8b \xeb\xa9\x94\xec\x8b\x9c\xec\xa7\x80\xec\x97\x90 \xeb\xb3\x80\xea\xb2\xbd \xec\x9d\xb4\xec\x9c\xa0 \xeb\xaa\x85\xec\x8b\x9c**\n- \xeb\xb6\x88\xed\x99\x95\xec\x8b\xa4\xed\x95\x98\xeb\xa9\xb4 \xe2\x86\x92 Intake \xec\xa7\x84\xed\x96\x89 \xea\xb6\x8c\xec\x9e\xa5\n\n### What NOT to Read by Default\n- `02_REQUIREMENTS/discussions/` - Only when explicitly referenced\n- `04_TASK_LOGS/archive/` - Only for historical context\n- `99_ARCHIVE/` - Deprecated content\n\n## Document Map\n\n### 01_PROJECT_CONTEXT (\xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8 \xed\x97\x8c\xeb\xb2\x95)\n- [00_GOALS.md](01_PROJECT_CONTEXT/00_GOALS.md) - \xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8 \xeb\xaa\xa9\xed\x91\x9c\n- [01_CONVENTIONS.md](01_PROJECT_CONTEXT/01_CONVENTIONS.md) - \xec\xbd\x94\xeb\x94\xa9 \xea\xb7\x9c\xec\xb9\x99 + **Boundaries** \xe2\xad\x90\n\n### 02_REQUIREMENTS (\xec\x9a\x94\xea\xb5\xac\xec\x82\xac\xed\x95\xad)\n- [capabilities/](02_REQUIREMENTS/capabilities/) - \xea\xb8\xb0\xeb\x8a\xa5 **\xea\xb2\xb0\xec\xa0\x95** (REQ-*)\n- [invariants/](02_REQUIREMENTS/invariants/) - \xeb\xb6\x88\xeb\xb3\x80 \xea\xb7\x9c\xec\xb9\x99 **\xea\xb2\xb0\xec\xa0\x95** (RULE-*)\n- [competencies/](02_REQUIREMENTS/competencies/) - \xec\x97\xad\xeb\x9f\x89 \xec\xa7\x88\xeb\xac\xb8 **\xea\xb2\x80\xec\xa6\x9d** (CQ-*)\n- [discussions/](02_REQUIREMENTS/discussions/) - \xec\xa1\xb0\xec\x9c\xa8 \xea\xb8\xb0\xeb\xa1\x9d (DISC-*)\n\n### 03_TECH_SPECS (\xea\xb8\xb0\xec\x88\xa0 \xec\x84\xa4\xea\xb3\x84)\n- [architecture/](03_TECH_SPECS/architecture/) - \xea\xb5\xac\xec\xa1\xb0\xeb\x8f\x84, DB \xec\x8a\xa4\xed\x82\xa4\xeb\xa7\x88\n- [api_specs/](03_TECH_SPECS/api_specs/) - API \xeb\xaa\x85\xec\x84\xb8\n- [decisions/](03_TECH_SPECS/decisions/) - ADR (RATIONALE)\n\n### 04_TASK_LOGS (\xec\x9e\x91\xec\x97\x85 \xea\xb8\xb0\xeb\xa1\x9d)\n- [active/](04_TASK_LOGS/active/) - \xec\x8b\xa4\xed\x96\x89 \xec\xa4\x91 (RUN-*) + **Self-Check**\n- [archive/](04_TASK_LOGS/archive/) - \xec\x99\x84\xeb\xa3\x8c\xeb\x90\x9c \xec\x9e\x91\xec\x97\x85\n\n### 98_KNOWLEDGE (\xec\xa7\x80\xec\x8b\x9d \xec\xa0\x80\xec\x9e\xa5\xec\x86\x8c)\n- [troubleshooting/](98_KNOWLEDGE/troubleshooting/) - \xed\x95\xb4\xea\xb2\xb0\xeb\x90\x9c \xeb\x82\x9c\xec\xa0\x9c\xeb\x93\xa4\n""",\n\n    # =========================================================================\n    # 01_PROJECT_CONTEXT\n    # =========================================================================\n    "01_PROJECT_CONTEXT/00_GOALS.md": f"""# Project Goals\n\n> **ID**: CTX-GOALS-001\n> **Last Updated**: (TBD)\n> **Template-Version**: {TEMPLATE_VERSION}\n\n---\n\n## 1. Project Identity\n\n### Name\n(\xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8 \xec\x9d\xb4\xeb\xa6\x84)\n\n### One-Line Summary\n(\xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8\xeb\xa5\xbc \xed\x95\x9c \xeb\xac\xb8\xec\x9e\xa5\xec\x9c\xbc\xeb\xa1\x9c \xec\x84\xa4\xeb\xaa\x85)\n\n### Core Value\n(\xec\x9d\xb4 \xec\x8b\x9c\xec\x8a\xa4\xed\x85\x9c\xec\x9d\xb4 \xec\xa1\xb4\xec\x9e\xac\xed\x95\x98\xeb\x8a\x94 \xec\x9d\xb4\xec\x9c\xa0, \xec\x96\xb4\xeb\x96\xa4 \xea\xb0\x80\xec\xb9\x98\xeb\xa5\xbc \xec\xa0\x9c\xea\xb3\xb5\xed\x95\x98\xeb\x8a\x94\xea\xb0\x80?)\n\n---\n\n## 2. Target Users\n\n- **Primary**: (\xec\xa3\xbc\xec\x9a\x94 \xec\x82\xac\xec\x9a\xa9\xec\x9e\x90)\n- **Secondary**: (\xeb\xb6\x80\xea\xb0\x80 \xec\x82\xac\xec\x9a\xa9\xec\x9e\x90)\n\n---\n\n## 3. Success Criteria\n\n- [ ] Criterion 1\n- [ ] Criterion 2\n- [ ] Criterion 3\n\n---\n\n## 4. Scope\n\n### In-Scope\n- (\xed\x8f\xac\xed\x95\xa8\xeb\x90\x98\xeb\x8a\x94 \xea\xb8\xb0\xeb\x8a\xa5/\xeb\xb2\x94\xec\x9c\x84)\n\n### Out-of-Scope\n- (\xeb\xaa\x85\xec\x8b\x9c\xec\xa0\x81\xec\x9c\xbc\xeb\xa1\x9c \xec\xa0\x9c\xec\x99\xb8\xeb\x90\x98\xeb\x8a\x94 \xea\xb2\x83\xeb\x93\xa4)\n\n---\n\n## 5. Milestones\n\n| Phase | Description | Target Date | Status |\n|-------|-------------|-------------|--------|\n| Phase 1 | MVP | TBD | Not Started |\n| Phase 2 | Core Features | TBD | Not Started |\n| Phase 3 | Hardening | TBD | Not Started |\n""",\n\n    "01_PROJECT_CONTEXT/01_CONVENTIONS.md": f"""# Coding Conventions & Rules (Smart Spec)\n\n> **ID**: CTX-CONV-001\n> **Last Updated**: (TBD)\n> **Template-Version**: {TEMPLATE_VERSION}\n\n---\n\n## 1. Commands (\xec\x8b\xa4\xed\x96\x89 \xeb\xaa\x85\xeb\xa0\xb9\xec\x96\xb4)\n\n> AI\xea\xb0\x80 \xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8, \xeb\xa6\xb0\xed\x8a\xb8, \xec\x8b\xa4\xed\x96\x89 \xec\x8b\x9c \xec\x82\xac\xec\x9a\xa9\xed\x95\xa0 \xeb\xaa\x85\xeb\xa0\xb9\xec\x96\xb4\xeb\xa5\xbc \xeb\xaa\x85\xec\x8b\x9c\xed\x95\xa9\xeb\x8b\x88\xeb\x8b\xa4.\n\n| Action | Command | Description |\n|--------|---------|-------------|\n| **Test** | `pytest` | Run all unit tests |\n| **Test (specific)** | `pytest tests/test_<name>.py` | Run specific test file |\n| **Lint** | `ruff check .` | Check code style |\n| **Format** | `ruff format .` | Auto-format code |\n| **Run** | `python main.py` | Run the application |\n| **Build** | `(TBD)` | Build for production |\n\n---\n\n## 2. Project Structure (\xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8 \xea\xb5\xac\xec\xa1\xb0)\n\n```\nproject_root/\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 src/                    # \xec\x86\x8c\xec\x8a\xa4 \xec\xbd\x94\xeb\x93\x9c (\xeb\xb9\x84\xec\xa6\x88\xeb\x8b\x88\xec\x8a\xa4 \xeb\xa1\x9c\xec\xa7\x81)\n\xe2\x94\x82   \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 __init__.py\n\xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 (modules)/\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 tests/                  # \xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xec\xbd\x94\xeb\x93\x9c (src\xec\x99\x80 1:1 \xeb\x8c\x80\xec\x9d\x91)\n\xe2\x94\x82   \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 __init__.py\n\xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 test_*.py\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 .memory/                # \xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8 \xeb\xac\xb8\xec\x84\x9c (MemoryAtlas)\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 requirements.txt        # Python \xec\x9d\x98\xec\xa1\xb4\xec\x84\xb1\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 README.md               # \xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8 \xec\x86\x8c\xea\xb0\x9c\n```\n\n---\n\n## 3. Code Style (\xec\xbd\x94\xeb\x93\x9c \xec\x8a\xa4\xed\x83\x80\xec\x9d\xbc)\n\n### Python\n- **Formatter**: `ruff format` (or `black`)\n- **Linter**: `ruff check` (or `flake8`)\n- **Type Hints**: Required for all public functions\n- **Docstrings**: Google style (\xeb\xb3\xb5\xec\x9e\xa1\xed\x95\x9c \xed\x95\xa8\xec\x88\x98\xeb\xa7\x8c)\n\n### Naming Conventions\n| Type | Style | Example |\n|------|-------|---------|\n| Variables/Functions | `snake_case` | `user_name`, `get_data()` |\n| Classes | `PascalCase` | `UserManager` |\n| Constants | `UPPER_SNAKE_CASE` | `MAX_RETRY` |\n| Files | `lowercase_underscores` | `user_service.py` |\n\n### Comments\n- \xeb\xb3\xb5\xec\x9e\xa1\xed\x95\x9c \xeb\xa1\x9c\xec\xa7\x81\xec\x97\x90\xeb\xa7\x8c **"Why"**\xeb\xa5\xbc \xec\xa0\x81\xeb\x8a\x94\xeb\x8b\xa4\n- \xeb\xaa\x85\xeb\xb0\xb1\xed\x95\x9c \xec\xbd\x94\xeb\x93\x9c\xec\x97\x90 \xec\xa3\xbc\xec\x84\x9d \xea\xb8\x88\xec\xa7\x80\n- TODO: `# TODO(author): description`\n\n---\n\n## 4. Testing Strategy (\xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xec\xa0\x84\xeb\x9e\xb5)\n\n### Requirements\n- \xeb\xaa\xa8\xeb\x93\xa0 \xea\xb8\xb0\xeb\x8a\xa5(`REQ`)\xec\x9d\x80 \xec\xb5\x9c\xec\x86\x8c 1\xea\xb0\x9c\xec\x9d\x98 \xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xed\x8c\x8c\xec\x9d\xbc\xec\x9d\x84 \xea\xb0\x80\xec\xa0\xb8\xec\x95\xbc \xed\x95\xa8\n- \xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xed\x8c\x8c\xec\x9d\xbc\xeb\xaa\x85: `test_<module_name>.py`\n- \xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xed\x95\xa8\xec\x88\x98\xeb\xaa\x85: `test_<behavior>_<expected_result>()`\n\n### TDD Workflow (\xea\xb6\x8c\xec\x9e\xa5)\n1. `RUN` \xeb\xac\xb8\xec\x84\x9c \xec\x9e\x91\xec\x84\xb1 \xec\x8b\x9c \xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xec\xbc\x80\xec\x9d\xb4\xec\x8a\xa4 \xeb\xa8\xbc\xec\xa0\x80 \xec\xa0\x95\xec\x9d\x98\n2. \xec\x8b\xa4\xed\x8c\xa8\xed\x95\x98\xeb\x8a\x94 \xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xec\x9e\x91\xec\x84\xb1\n3. \xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xed\x86\xb5\xea\xb3\xbc\xed\x95\x98\xeb\x8a\x94 \xec\xb5\x9c\xec\x86\x8c \xec\xbd\x94\xeb\x93\x9c \xec\x9e\x91\xec\x84\xb1\n4. \xeb\xa6\xac\xed\x8c\xa9\xed\x86\xa0\xeb\xa7\x81\n\n### Coverage\n- \xeb\xaa\xa9\xed\x91\x9c: (\xec\x98\x88: 80% \xec\x9d\xb4\xec\x83\x81)\n- \xed\x95\xb5\xec\x8b\xac \xeb\xb9\x84\xec\xa6\x88\xeb\x8b\x88\xec\x8a\xa4 \xeb\xa1\x9c\xec\xa7\x81: 100%\n\n---\n\n## 5. Git Workflow (Git \xea\xb7\x9c\xec\xb9\x99)\n\n### Branch Naming\n- Feature: `feat/REQ-ID-short-desc` (\xec\x98\x88: `feat/REQ-AUTH-001-login`)\n- Bugfix: `fix/issue-id-desc`\n- Hotfix: `hotfix/critical-fix`\n\n### Commit Messages\n```\n<type>(<scope>): <subject>\n\n<body>\n```\n- **Types**: `feat`, `fix`, `docs`, `refactor`, `test`, `chore`\n- **Example**: `feat(auth): add JWT token validation`\n\n### PR Rules\n- 1 PR = 1 REQ (\xea\xb0\x80\xeb\x8a\xa5\xed\x95\x9c \xea\xb2\xbd\xec\x9a\xb0)\n- Self-review \xed\x9b\x84 \xec\x9a\x94\xec\xb2\xad\n- CI \xed\x86\xb5\xea\xb3\xbc \xed\x95\x84\xec\x88\x98\n\n---\n\n## 6. Smart Spec Boundaries (STRICT)\n\n### \xe2\x9c\x85 Always (\xed\x95\xad\xec\x83\x81 \xec\x88\x98\xed\x96\x89)\n- `RUN` \xeb\xac\xb8\xec\x84\x9c \xec\x9e\x91\xec\x84\xb1 \xec\x8b\x9c `Verification` \xec\x84\xb9\xec\x85\x98\xec\x97\x90 \xea\xb5\xac\xec\xb2\xb4\xec\xa0\x81\xec\x9d\xb8 **\xea\xb2\x80\xec\xa6\x9d \xeb\xaa\x85\xeb\xa0\xb9\xec\x96\xb4**\xeb\xa5\xbc \xed\x8f\xac\xed\x95\xa8\xed\x95\xa0 \xea\xb2\x83. (\xec\x98\x88: `pytest tests/auth/`)\n- \xeb\xaa\xa8\xeb\x93\xa0 \xed\x8d\xbc\xeb\xb8\x94\xeb\xa6\xad API/\xed\x95\xa8\xec\x88\x98\xec\x97\x90\xeb\x8a\x94 **Docstring**\xea\xb3\xbc **Type Hint**\xeb\xa5\xbc \xed\x8f\xac\xed\x95\xa8\xed\x95\xa0 \xea\xb2\x83.\n\n### \xf0\x9f\x99\x8b Ask First (\xeb\xac\xbc\xec\x96\xb4\xeb\xb3\xbc \xea\xb2\x83)\n- `requirements.txt`, `package.json` \xeb\x93\xb1 **\xec\x9d\x98\xec\xa1\xb4\xec\x84\xb1 \xec\xb6\x94\xea\xb0\x80/\xeb\xb3\x80\xea\xb2\xbd**.\n- **DB \xec\x8a\xa4\xed\x82\xa4\xeb\xa7\x88 \xeb\xb3\x80\xea\xb2\xbd** (`migration` \xed\x8c\x8c\xec\x9d\xbc \xec\x83\x9d\xec\x84\xb1).\n- \xea\xb8\xb0\xec\xa1\xb4 `01_CONVENTIONS`\xeb\x82\x98 \xec\x8b\x9c\xec\x8a\xa4\xed\x85\x9c \xed\x85\x9c\xed\x94\x8c\xeb\xa6\xbf \xec\x88\x98\xec\xa0\x95.\n\n### \xf0\x9f\x9a\xab Never (\xec\xa0\x88\xeb\x8c\x80 \xea\xb8\x88\xec\xa7\x80)\n- **Secret Key**, Password, API Key\xeb\xa5\xbc \xec\xbd\x94\xeb\x93\x9c\xeb\x82\x98 \xeb\xac\xb8\xec\x84\x9c\xec\x97\x90 \xed\x95\x98\xeb\x93\x9c\xec\xbd\x94\xeb\x94\xa9.\n- **Mock Data**\xeb\xa5\xbc \xed\x94\x84\xeb\xa1\x9c\xeb\x8d\x95\xec\x85\x98 \xec\xbd\x94\xeb\x93\x9c\xec\x97\x90 \xeb\x82\xa8\xea\xb8\xb0\xeb\x8a\x94 \xed\x96\x89\xec\x9c\x84.\n- `REQ` \xeb\xac\xb8\xec\x84\x9c\xec\x9d\x98 **Decision** \xec\x84\xb9\xec\x85\x98\xec\x9d\x84 \xec\x88\x98\xec\xa0\x95\xed\x95\x98\xec\xa7\x80 \xec\x95\x8a\xea\xb3\xa0 \xed\x95\x98\xeb\x8b\xa8\xec\x97\x90 "\xec\xb6\x94\xea\xb0\x80 \xec\x82\xac\xed\x95\xad"\xec\x9c\xbc\xeb\xa1\x9c \xeb\x8d\xa7\xeb\xb6\x99\xec\x9d\xb4\xeb\x8a\x94 \xed\x96\x89\xec\x9c\x84.\n\n---\n\n## 7. Documentation Maintenance Policy\n1. **SSOT (Single Source of Truth)**: `REQ` \xeb\xac\xb8\xec\x84\x9c\xeb\x8a\x94 \xed\x95\xad\xec\x83\x81 **\xed\x98\x84\xec\x9e\xac \xec\x8b\x9c\xec\xa0\x90\xec\x9d\x98 \xec\xb5\x9c\xec\xa2\x85 \xeb\xaa\x85\xec\x84\xb8**\xec\x97\xac\xec\x95\xbc \xed\x95\x9c\xeb\x8b\xa4.\n2. **Rewrite, Don\'t Append**: \xec\x9a\x94\xea\xb5\xac\xec\x82\xac\xed\x95\xad\xec\x9d\xb4 \xeb\xb3\x80\xea\xb2\xbd\xeb\x90\x98\xeb\xa9\xb4 \xea\xb8\xb0\xec\xa1\xb4 \xed\x85\x8d\xec\x8a\xa4\xed\x8a\xb8\xeb\xa5\xbc \xec\x88\x98\xec\xa0\x95(Refactor)\xed\x95\x98\xeb\x9d\xbc. \xeb\xb0\x91\xec\x97\x90 "Update 1..." \xec\x8b\x9d\xec\x9c\xbc\xeb\xa1\x9c \xeb\x8d\xa7\xeb\xb6\x99\xec\x9d\xb4\xec\xa7\x80 \xeb\xa7\x88\xeb\x9d\xbc.\n3. **Change Log**: \xeb\xb3\x80\xea\xb2\xbd \xec\x9d\xb4\xeb\xa0\xa5\xec\x9d\x80 \xeb\xac\xb8\xec\x84\x9c \xec\xb5\x9c\xec\x83\x81\xeb\x8b\xa8\xec\x9d\x98 `Change Log` \xed\x85\x8c\xec\x9d\xb4\xeb\xb8\x94\xec\x97\x90\xeb\xa7\x8c \xea\xb8\xb0\xeb\xa1\x9d\xed\x95\x98\xeb\x9d\xbc.\n\n---\n\n## 8. AI Agent Quick Reference\n\n### Reading Priority (P0 = Must Read)\n1. **P0**: \xec\x9d\xb4 \xed\x8c\x8c\xec\x9d\xbc (`01_CONVENTIONS.md`)\n2. **P0**: Target REQ\xec\x9d\x98 `**Must-Read**` \xed\x95\x84\xeb\x93\x9c\n3. **P1**: `02_REQUIREMENTS/invariants/` (\xec\xa0\x84\xec\xb2\xb4)\n4. **P1.5**: `02_REQUIREMENTS/competencies/` (\xec\xb0\xb8\xec\xa1\xb0\xeb\x90\x9c CQ\xeb\xa7\x8c)\n5. **P2**: `98_KNOWLEDGE/` (\xeb\xb3\xb5\xec\x9e\xa1\xed\x95\x9c \xea\xb8\xb0\xeb\x8a\xa5 \xec\x8b\x9c)\n\n### Execution Checklist (3-Step Workflow)\n1. [ ] **Intake**: BRIEF \xec\x83\x9d\xec\x84\xb1 \xeb\xb0\x8f \xea\xb2\x80\xed\x86\xa0\n2. [ ] **Plan**: RUN \xeb\xac\xb8\xec\x84\x9c \xec\x83\x9d\xec\x84\xb1 \xeb\xb0\x8f \xea\xb2\x80\xed\x86\xa0\n3. [ ] \xea\xb5\xac\xed\x98\x84 \xe2\x86\x92 \xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xe2\x86\x92 \xea\xb2\x80\xec\xa6\x9d\n4. [ ] **Finish**: Self-Check \xed\x86\xb5\xea\xb3\xbc \xed\x9b\x84 finish() \xed\x98\xb8\xec\xb6\x9c\n""",\n\n    "01_PROJECT_CONTEXT/04_AGENT_GUIDE.md": """# Agent Guide\n\n## Source of Truth\n- Always start with 00_INDEX.md.\n- Prefer .memory documents over ad-hoc assumptions.\n\n## Update Rules\n- Update 02_REQUIREMENTS when requirements or specs change.\n- Update 01_PROJECT_CONTEXT when architecture or scope changes.\n- Update 03_TECH_SPECS after implementing or deferring work.\n\n## 3-Phase Workflow\n1. **Intake**: Idea -> BRIEF\n2. **Plan**: BRIEF -> RUN\n3. **Execute**: RUN -> Code/Test -> Archive\n\n## Documentation Standard: Structured Natural Language\nUse the following rules so humans and LLMs can both parse and act on documents reliably.\n\n### Rule 1: Metadata Header (Context Injection)\nPlace a header at the very top to declare what the document is, who it is for, and its freshness.\n\n```markdown\n# Document Title (e.g., News Classification Service Requirements)\n\n> **ID**: DOC-ING-001\n> **Service**: Ingestion Service\n> **Scope**: News article category classification and tagging logic\n> **Last Updated**: 2026-01-15\n\n---\n```\n\n### Rule 2: Atomic Requirements (ID-Scoped Blocks)\nWrite each requirement as its own block with an ID and explicit fields.\n\n```markdown\n### [REQ-CLS-001] Rule-Based Disclosure Classification\n\n- **Description**: If the title contains certain keywords, classify immediately without an LLM.\n- **Input**: `Article` (title, content)\n- **Output**: `ClassificationResult` (category=\'CORP_EVENT\', confidence=1.0)\n- **Rules**:\n  - If the title contains "[\xea\xb3\xb5\xec\x8b\x9c]" or "[IR]", classify as `CORP_EVENT`.\n  - If the title contains "\xec\x86\x8d\xeb\xb3\xb4", increase weight.\n```\n\n### Rule 3: Checkbox State Tracking\nTrack implementation inside the requirement using checkboxes.\n\n```markdown\n- **Acceptance Criteria**:\n  - [x] "[\xea\xb3\xb5\xec\x8b\x9c]" keyword handling implemented\n  - [ ] "[IR]" keyword handling implemented\n  - [ ] Unit tests written\n```\n\n### Rule 4: Explicit Schemas via Code Blocks\nDefine schemas and examples inside code blocks (json, python, etc.).\n\n```markdown\n**Output Format Example**:\n```json\n{\n  "category": "MACRO",\n  "confidence": 0.95,\n  "reasoning": "Multiple mentions of rate hikes"\n}\n```\n```\n\n### Rule 5: Explicit Linking\nUse relative links to related documents.\n\n```markdown\n## Related Documents\n- **Data Model**: [../../01_PROJECT_CONTEXT/03_DATA_MODEL.md](../../01_PROJECT_CONTEXT/03_DATA_MODEL.md)\n- **Architecture**: [../../01_PROJECT_CONTEXT/02_ARCHITECTURE.md](../../01_PROJECT_CONTEXT/02_ARCHITECTURE.md)\n```\n\n### Rule 6: Human-Centric Readability (\xec\x82\xac\xeb\x9e\x8c \xec\xa4\x91\xec\x8b\xac \xea\xb0\x80\xeb\x8f\x85\xec\x84\xb1)\n\xec\x82\xac\xeb\x9e\x8c\xec\x9d\xb4 3\xec\xb4\x88 \xec\x95\x88\xec\x97\x90 \xed\x95\xb5\xec\x8b\xac\xec\x9d\x84 \xed\x8c\x8c\xec\x95\x85\xed\x95\xa0 \xec\x88\x98 \xec\x9e\x88\xeb\x8f\x84\xeb\xa1\x9d \xec\x9e\x91\xec\x84\xb1\xed\x95\x98\xeb\x9d\xbc.\n\n1. **BLUF (Bottom Line Up Front)**: \xeb\xaa\xa8\xeb\x93\xa0 \xec\x84\xb9\xec\x85\x98\xec\x9d\x80 **\xea\xb2\xb0\xeb\xa1\xa0(Conclusion)**\xec\x9d\xb4\xeb\x82\x98 **\xed\x95\x9c \xec\xa4\x84 \xec\x9a\x94\xec\x95\xbd(Summary)**\xec\x9c\xbc\xeb\xa1\x9c \xec\x8b\x9c\xec\x9e\x91\xed\x95\x98\xeb\x9d\xbc.\n2. **Visual Anchors (Emojis)**: \xed\x85\x8d\xec\x8a\xa4\xed\x8a\xb8\xec\x9d\x98 \xec\x84\xb1\xea\xb2\xa9\xec\x9d\x84 \xec\x95\x84\xec\x9d\xb4\xec\xbd\x98\xec\x9c\xbc\xeb\xa1\x9c \xed\x91\x9c\xec\x8b\x9c\xed\x95\x98\xeb\x9d\xbc.\n   - \xf0\x9f\x93\x95 **Critical**: \xec\xa3\xbc\xec\x9d\x98\xec\x82\xac\xed\x95\xad, \xeb\xb3\xb4\xec\x95\x88 \xec\x9d\xb4\xec\x8a\x88\n   - \xe2\x9c\xa8 **Feature**: \xec\x83\x88\xeb\xa1\x9c\xec\x9a\xb4 \xea\xb8\xb0\xeb\x8a\xa5\n   - \xf0\x9f\x92\xa1 **Note**: \xec\xb0\xb8\xea\xb3\xa0, \xed\x8c\x81\n   - \xe2\x9d\x93 **Open**: \xeb\xaf\xb8\xea\xb2\xb0\xec\xa0\x95 \xec\x82\xac\xed\x95\xad\n\n### Rule 7: Diagram Over Text (\xed\x85\x8d\xec\x8a\xa4\xed\x8a\xb8\xeb\xb3\xb4\xeb\x8b\xa4 \xeb\x8b\xa4\xec\x9d\xb4\xec\x96\xb4\xea\xb7\xb8\xeb\x9e\xa8)\n\xec\xa1\xb0\xea\xb1\xb4 \xeb\xb6\x84\xea\xb8\xb0\xeb\x82\x98 \xed\x9d\x90\xeb\xa6\x84\xec\x9d\xb4 3\xeb\x8b\xa8\xea\xb3\x84 \xec\x9d\xb4\xec\x83\x81 \xeb\x84\x98\xec\x96\xb4\xea\xb0\x80\xeb\xa9\xb4 \xec\xa4\x84\xea\xb8\x80 \xec\x82\xac\xec\x9a\xa9\xec\x9d\x84 \xea\xb8\x88\xec\xa7\x80\xed\x95\x9c\xeb\x8b\xa4.\n\n1. **Decision Matrix**: \xeb\xb3\xb5\xec\x9e\xa1\xed\x95\x9c \xec\xa1\xb0\xea\xb1\xb4(\xea\xb6\x8c\xed\x95\x9c, \xec\x83\x81\xed\x83\x9c \xeb\x93\xb1)\xec\x9d\x80 \xeb\xb0\x98\xeb\x93\x9c\xec\x8b\x9c **\xeb\xa7\x88\xed\x81\xac\xeb\x8b\xa4\xec\x9a\xb4 \xed\x91\x9c(Table)**\xeb\xa1\x9c \xec\x9e\x91\xec\x84\xb1\xed\x95\x98\xeb\x9d\xbc.\n2. **Mermaid.js**: \xeb\x8d\xb0\xec\x9d\xb4\xed\x84\xb0 \xed\x9d\x90\xeb\xa6\x84\xec\x9d\xb4\xeb\x82\x98 \xec\x83\x81\xed\x83\x9c \xeb\xb3\x80\xed\x99\x94\xeb\x8a\x94 `mermaid` \xec\xbd\x94\xeb\x93\x9c \xeb\xb8\x94\xeb\xa1\x9d\xec\x9c\xbc\xeb\xa1\x9c \xec\x8b\x9c\xea\xb0\x81\xed\x99\x94\xed\x95\x98\xeb\x9d\xbc.\n\n## Expected Effects (Current vs Proposed)\n\n| \xea\xb5\xac\xeb\xb6\x84 | \xed\x98\x84\xec\x9e\xac \xec\x83\x81\xed\x83\x9c (Current) | \xec\xb6\x94\xea\xb0\x80 \xec\xa0\x81\xec\x9a\xa9 \xed\x9b\x84 (Proposed) |\n|------|---------------------|-------------------------|\n| \xeb\xb3\xb5\xec\x9e\xa1\xed\x95\x9c \xeb\xa1\x9c\xec\xa7\x81 \xec\x84\xa4\xeb\xaa\x85 | "\xea\xb4\x80\xeb\xa6\xac\xec\x9e\x90\xeb\x8a\x94 \xec\x9d\xbd\xea\xb8\xb0 \xec\x93\xb0\xea\xb8\xb0\xea\xb0\x80 \xeb\x90\x98\xeb\x8a\x94\xeb\x8d\xb0 \xec\x9c\xa0\xec\xa0\x80\xeb\x8a\x94 \xec\x9d\xbd\xea\xb8\xb0\xeb\xa7\x8c \xeb\x90\x98\xea\xb3\xa0..." (\xec\xa4\x84\xea\xb8\x80) | \xea\xb6\x8c\xed\x95\x9c \xed\x85\x8c\xec\x9d\xb4\xeb\xb8\x94(Table) + \xed\x9d\x90\xeb\xa6\x84\xeb\x8f\x84(Mermaid) |\n| \xec\x9a\x94\xea\xb5\xac\xec\x82\xac\xed\x95\xad \xeb\xb3\x80\xea\xb2\xbd \xec\x8b\x9c | \xeb\xac\xb8\xec\x84\x9c \xeb\xa7\xa8 \xec\x95\x84\xeb\x9e\x98\xec\x97\x90 `## \xec\xb6\x94\xea\xb0\x80 \xec\x9a\x94\xec\xb2\xad\xec\x82\xac\xed\x95\xad` \xec\x84\xb9\xec\x85\x98\xec\x9d\xb4 \xea\xb3\x84\xec\x86\x8d \xec\x83\x9d\xea\xb9\x80 (\xec\x8a\xa4\xed\x8c\x8c\xea\xb2\x8c\xed\x8b\xb0) | Decision \xeb\xb3\xb8\xeb\xac\xb8\xec\x9d\xb4 \xea\xb9\x94\xeb\x81\x94\xed\x95\x98\xea\xb2\x8c \xec\x88\x98\xec\xa0\x95\xeb\x90\x98\xea\xb3\xa0, \xec\x83\x81\xeb\x8b\xa8 Change Log\xeb\xa7\x8c \xed\x95\x9c \xec\xa4\x84 \xec\xb6\x94\xea\xb0\x80\xeb\x90\xa8 |\n| \xec\x9c\x84\xed\x97\x98\xed\x95\x9c \xec\x9e\x91\xec\x97\x85 \xec\x8b\x9c | AI\xea\xb0\x80 \xec\x9e\x84\xec\x9d\x98\xeb\xa1\x9c \xed\x8c\x90\xeb\x8b\xa8\xed\x95\xb4\xec\x84\x9c \xec\xa7\x84\xed\x96\x89\xed\x95\xa0 \xec\x88\x98 \xec\x9e\x88\xec\x9d\x8c | Ask First \xea\xb7\x9c\xec\xb9\x99\xec\x97\x90 \xea\xb1\xb8\xeb\xa0\xa4 "\xec\x9d\x98\xec\xa1\xb4\xec\x84\xb1\xec\x9d\x84 \xec\xb6\x94\xea\xb0\x80\xed\x95\xb4\xeb\x8f\x84 \xeb\x90\xa0\xea\xb9\x8c\xec\x9a\x94?"\xeb\x9d\xbc\xea\xb3\xa0 \xeb\xac\xbc\xec\x96\xb4\xeb\xb4\x84 |\n| \xea\xb0\x80\xeb\x8f\x85\xec\x84\xb1 | \xed\x9d\x91\xeb\xb0\xb1 \xed\x85\x8d\xec\x8a\xa4\xed\x8a\xb8 \xec\x9c\x84\xec\xa3\xbc\xeb\x9d\xbc \xeb\x88\x88\xec\x97\x90 \xec\x9e\x98 \xec\x95\x88 \xeb\x93\xa4\xec\x96\xb4\xec\x98\xb4 | \xec\x9d\xb4\xeb\xaa\xa8\xec\xa7\x80(\xf0\x9f\x93\x95, \xe2\x9c\xa8, \xf0\x9f\x92\xa1, \xe2\x9d\x93)\xec\x99\x80 \xec\x9a\x94\xec\x95\xbd \xeb\x8d\x95\xeb\xb6\x84\xec\x97\x90 \xed\x9b\x91\xec\x96\xb4\xeb\xb3\xb4\xea\xb8\xb0 \xed\x8e\xb8\xed\x95\xa8 |\n\n## Standard Template (Copy/Paste)\n```markdown\n# [Service Name] Requirements\n\n> **Service**: [Service name, e.g., Ingestion]\n> **Component**: [Component name, e.g., Classification Pipeline]\n> **Status**: [Draft / Active / Deprecated]\n\n---\n\n## 1. Overview\nBriefly describe what this document defines.\n\n## 2. Requirements\n\n### [REQ-AAA-001] [Feature Name]\n- **Description**: Clear statement of what must be done.\n- **Input**:\n  - `text` (str): input description\n- **Output**:\n  - `result` (dict): output description\n- **Logic/Rules**:\n  1. First rule\n  2. Second rule\n- **Acceptance Criteria**:\n  - [ ] Feature implemented\n  - [ ] Edge cases handled\n  - [ ] Tests passing\n\n### [REQ-AAA-002] [Feature Name]\n...\n\n## 3. Data Structures\n```python\n# Pydantic-style or JSON example\nclass OutputDTO:\n    id: str\n    value: int\n```\n\n## 4. References\nList related documents here.\n```\n""",\n\n    # =========================================================================\n    # 02_REQUIREMENTS (v2.3 - Smart Spec Edition)\n    # =========================================================================\n    "02_REQUIREMENTS/README.md": f"""# Requirements (Authority Layer)\n\n> **Template-Version**: {TEMPLATE_VERSION}\n>\n> \xec\x9d\xb4 \xed\x8f\xb4\xeb\x8d\x94\xeb\x8a\x94 **"\xeb\xac\xb4\xec\x97\x87\xec\x9d\x84 \xeb\xa7\x8c\xeb\x93\xa4 \xea\xb2\x83\xec\x9d\xb8\xea\xb0\x80?"**\xec\x9d\x98 **\xec\xb5\x9c\xec\xa2\x85 \xea\xb2\xb0\xec\xa0\x95**\xec\x9d\x84 \xec\xa0\x80\xec\x9e\xa5\xed\x95\xa9\xeb\x8b\x88\xeb\x8b\xa4.\n> \xeb\x85\xbc\xec\x9d\x98/\xec\xa1\xb0\xec\x9c\xa8 \xea\xb8\xb0\xeb\xa1\x9d\xec\x9d\x80 `discussions/`\xec\x97\x90 \xeb\xb6\x84\xeb\xa6\xac\xed\x95\xa9\xeb\x8b\x88\xeb\x8b\xa4.\n\n## Capabilities, Invariants & Competencies Model (v3.1)\n\n```\n\xeb\xac\xb8\xec\x84\x9c \xeb\x93\xb1\xea\xb8\x89:\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 capabilities/     \xe2\x86\x92 REQ-* (\xea\xb8\xb0\xeb\x8a\xa5/\xed\x96\x89\xeb\x8f\x99) "\xec\x8b\x9c\xec\x8a\xa4\xed\x85\x9c\xec\x9d\x80 ~\xed\x95\xb4\xec\x95\xbc \xed\x95\x9c\xeb\x8b\xa4"\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 invariants/       \xe2\x86\x92 RULE-* (\xeb\xb6\x88\xeb\xb3\x80 \xea\xb7\x9c\xec\xb9\x99) "\xed\x95\xad\xec\x83\x81 ~\xec\x9d\xb4\xeb\x8b\xa4 / ~\xeb\x8a\x94 \xea\xb8\x88\xec\xa7\x80"\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 competencies/     \xe2\x86\x92 CQ-* (\xec\x97\xad\xeb\x9f\x89 \xec\xa7\x88\xeb\xac\xb8) "\xec\x8b\x9c\xec\x8a\xa4\xed\x85\x9c\xec\x9d\x80 ~\xec\x97\x90 \xeb\x8b\xb5\xed\x95\xa0 \xec\x88\x98 \xec\x9e\x88\xeb\x8a\x94\xea\xb0\x80?"\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 discussions/      \xe2\x86\x92 DISC-* (\xec\xa1\xb0\xec\x9c\xa8 \xea\xb8\xb0\xeb\xa1\x9d, LLM \xea\xb8\xb0\xeb\xb3\xb8 \xeb\xac\xb4\xec\x8b\x9c)\n```\n\n## REQ vs RULE vs CQ \xed\x8c\x90\xec\xa0\x95 \xea\xb8\xb0\xec\xa4\x80\n\n### REQ (capabilities/\xec\x97\x90\xeb\xa7\x8c \xec\xa1\xb4\xec\x9e\xac)\n- **\xeb\xac\xb8\xec\x9e\xa5 \xed\x98\x95\xed\x83\x9c**: "\xec\x8b\x9c\xec\x8a\xa4\xed\x85\x9c\xec\x9d\x80 ~~\xed\x95\xb4\xec\x95\xbc \xed\x95\x9c\xeb\x8b\xa4" (\xeb\x8f\x99\xec\x9e\x91 \xec\xa4\x91\xec\x8b\xac)\n- **\xed\x95\x84\xec\x88\x98 \xec\x84\xb9\xec\x85\x98**: Input, Output, Acceptance Criteria\n- **\xea\xb7\x9c\xec\xb9\x99 \xec\x9e\x91\xec\x84\xb1 \xea\xb8\x88\xec\xa7\x80**: \xed\x98\x95\xec\x8b\x9d/\xec\xa0\x9c\xec\x95\xbd/\xea\xb8\x88\xec\xa7\x80\xeb\x8a\x94 Must-Read\xeb\xa1\x9c RULE \xec\xb0\xb8\xec\xa1\xb0\n\n### RULE (invariants/\xec\x97\x90\xeb\xa7\x8c \xec\xa1\xb4\xec\x9e\xac)\n- **\xeb\xac\xb8\xec\x9e\xa5 \xed\x98\x95\xed\x83\x9c**: "\xed\x95\xad\xec\x83\x81 ~~\xec\x9d\xb4\xeb\x8b\xa4 / ~~\xeb\x8a\x94 \xea\xb8\x88\xec\xa7\x80" (\xeb\xb6\x88\xeb\xb3\x80 \xec\xa4\x91\xec\x8b\xac)\n- **\xed\x95\x84\xec\x88\x98 \xec\x84\xb9\xec\x85\x98**: Scope, Violation \xed\x8c\x90\xec\xa0\x95 \xea\xb8\xb0\xec\xa4\x80, Examples\n- **\xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xea\xb0\x80\xeb\x8a\xa5**: \xeb\x8b\xa8\xeb\x8f\x85\xec\x9c\xbc\xeb\xa1\x9c \xec\xb0\xb8/\xea\xb1\xb0\xec\xa7\x93 \xed\x8c\x90\xec\xa0\x95 \xea\xb0\x80\xeb\x8a\xa5\xed\x95\xb4\xec\x95\xbc \xed\x95\xa8\n\n### CQ (competencies/\xec\x97\x90\xeb\xa7\x8c \xec\xa1\xb4\xec\x9e\xac)\n- **\xeb\xac\xb8\xec\x9e\xa5 \xed\x98\x95\xed\x83\x9c**: "\xec\x8b\x9c\xec\x8a\xa4\xed\x85\x9c\xec\x9d\x80 ~~\xec\x97\x90 \xeb\x8b\xb5\xed\x95\xa0 \xec\x88\x98 \xec\x9e\x88\xeb\x8a\x94\xea\xb0\x80?" (\xea\xb2\x80\xec\xa6\x9d \xec\xa4\x91\xec\x8b\xac)\n- **\xed\x95\x84\xec\x88\x98 \xec\x84\xb9\xec\x85\x98**: Question, Expected Answer, Traceability\n- **REQ/RULE \xec\x97\xb0\xea\xb2\xb0**: Solves by / Constrained by \xeb\xa7\x81\xed\x81\xac\xeb\xa1\x9c \xec\xb6\x94\xec\xa0\x81\xec\x84\xb1 \xed\x99\x95\xeb\xb3\xb4\n\n## Structure\n\n```\n02_REQUIREMENTS/\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 capabilities/       # REQ-* (\xea\xb8\xb0\xeb\x8a\xa5/\xed\x96\x89\xeb\x8f\x99)\n\xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 REQ-AUTH-001.md\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 invariants/         # RULE-* (\xeb\xb6\x88\xeb\xb3\x80 \xea\xb7\x9c\xec\xb9\x99)\n\xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 RULE-ID-001.md\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 competencies/       # CQ-* (\xec\x97\xad\xeb\x9f\x89 \xec\xa7\x88\xeb\xac\xb8)\n\xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 CQ-AUTH-001.md\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 discussions/        # DISC-* (\xec\xa1\xb0\xec\x9c\xa8 \xea\xb8\xb0\xeb\xa1\x9d)\n    \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 DISC-AUTH-001.md\n```\n\n## Naming Convention (STRICT)\n\n| Type | Pattern | Example | Location |\n|------|---------|---------|----------|\n| Capability | `REQ-[DOMAIN]-[NNN].md` | `REQ-AUTH-001.md` | capabilities/ |\n| Invariant | `RULE-[DOMAIN]-[NNN].md` | `RULE-ID-001.md` | invariants/ |\n| Competency | `CQ-[DOMAIN]-[NNN].md` | `CQ-AUTH-001.md` | competencies/ |\n| Discussion | `DISC-[DOMAIN]-[NNN].md` | `DISC-AUTH-001.md` | discussions/ |\n\n## Must-Read Field (Required)\n\n\xeb\xaa\xa8\xeb\x93\xa0 REQ/RULE \xeb\xac\xb8\xec\x84\x9c\xec\x97\x90\xeb\x8a\x94 `**Must-Read**` \xed\x95\x84\xeb\x93\x9c\xea\xb0\x80 \xed\x95\x84\xec\x88\x98\xec\x9e\x85\xeb\x8b\x88\xeb\x8b\xa4:\n\n```markdown\n> **Must-Read**: RULE-ID-001, RULE-META-001, ADR-003\n```\n\n\xec\x9d\xb4 \xed\x95\x84\xeb\x93\x9c\xec\x97\x90 \xeb\x82\x98\xec\x97\xb4\xeb\x90\x9c \xeb\xac\xb8\xec\x84\x9c\xeb\x8a\x94 \xed\x95\xb4\xeb\x8b\xb9 REQ \xea\xb5\xac\xed\x98\x84 \xec\x8b\x9c **\xeb\xb0\x98\xeb\x93\x9c\xec\x8b\x9c** \xec\x9d\xbd\xec\x96\xb4\xec\x95\xbc \xed\x95\xa9\xeb\x8b\x88\xeb\x8b\xa4.\n\nCQ \xeb\xac\xb8\xec\x84\x9c\xeb\x8a\x94 Must-Read \xeb\x8c\x80\xec\x8b\xa0 **Traceability \xec\x84\xb9\xec\x85\x98**\xec\x9c\xbc\xeb\xa1\x9c REQ/RULE\xec\x9d\x84 \xec\x97\xb0\xea\xb2\xb0\xed\x95\xa9\xeb\x8b\x88\xeb\x8b\xa4.\n\n- Must-Read allows only RULE/ADR IDs (CTX is P0 and not allowed here).\n- If you use markdown links, the link text must be the ID (e.g. `[RULE-ID-001](invariants/RULE-ID-001.md)`).\n\n## Partial Updates Policy (Recommended)\n\n- Keep REQ as the full contract; `Status=Active` means the whole REQ is executable.\n- Do not mix "pending/later" items inside an Active REQ. Use DISC or a new Draft REQ.\n- When only part changes, narrow scope in RUN (In Scope / Out of Scope) and reference the target sections.\n- Record evidence in RUN for "already implemented" vs "needs work":\n  tests passed, commands run, and code locations.\n\n### When to Revisit a Pending Section Model\n\nAdopt a formal Pending section only if at least two are true:\n- A single REQ routinely contains 10+ sub-features and only a subset is delivered each time.\n- Agents frequently misjudge scope, causing repeated rework.\n- There are multiple collaborators and explicit sprint deferrals are required.\n- Roadmap-level proposals must live inside the REQ.\n\n## MCP Automation Notes\n\n- `Automator.apply_req(req_id[, dry_run, create_spec])` drives the pipeline: validate REQ, build a spec draft (optional), create a RUN, and generate DISC drafts on failure.\n- The CLI exposes `python memory_manager.py apply-req --id REQ-XXX-001 [--dry-run] [--no-spec]`; it prints artifacts or failure/discussion links.\n- FastMCP agents can call `src/mcp_server.py::apply_req` to run the same flow and receive a JSON-like report.\n- Read-only MCP helpers: `req_status(req_id)` for readiness checks, `run_report(run_id)` for structured RUN summaries.\n\n\n""",\n\n    "02_REQUIREMENTS/capabilities/README.md": f"""# Capabilities (REQ-*)\n\n> **Template-Version**: {TEMPLATE_VERSION}\n>\n> **"\xec\x8b\x9c\xec\x8a\xa4\xed\x85\x9c\xec\x9d\x80 ~\xed\x95\xb4\xec\x95\xbc \xed\x95\x9c\xeb\x8b\xa4"** \xed\x98\x95\xed\x83\x9c\xec\x9d\x98 \xea\xb8\xb0\xeb\x8a\xa5/\xed\x96\x89\xeb\x8f\x99\xec\x9d\x84 \xec\xa0\x95\xec\x9d\x98\xed\x95\xa9\xeb\x8b\x88\xeb\x8b\xa4.\n> \xeb\x85\xbc\xec\x9d\x98/\xeb\x8c\x80\xec\x95\x88 \xea\xb2\x80\xed\x86\xa0\xeb\x8a\x94 `../discussions/`\xec\x97\x90 \xec\x9e\x91\xec\x84\xb1\xed\x95\x98\xec\x84\xb8\xec\x9a\x94.\n\n## REQ \xed\x8c\x90\xec\xa0\x95 \xea\xb8\xb0\xec\xa4\x80\n\n- \xe2\x9c\x85 "\xec\x8b\x9c\xec\x8a\xa4\xed\x85\x9c\xec\x9d\x80 ~~\xed\x95\xb4\xec\x95\xbc \xed\x95\x9c\xeb\x8b\xa4"\xeb\xa1\x9c \xec\x8b\x9c\xec\x9e\x91 \xea\xb0\x80\xeb\x8a\xa5 (\xeb\x8f\x99\xec\x9e\x91 \xec\xa4\x91\xec\x8b\xac)\n- \xe2\x9c\x85 Input / Output / Acceptance Criteria \xed\x95\x84\xec\x88\x98\n- \xe2\x9d\x8c \xea\xb7\x9c\xec\xb9\x99/\xed\x98\x95\xec\x8b\x9d/\xec\xa0\x9c\xec\x95\xbd\xec\x9d\x80 \xeb\xb3\xb8\xeb\xac\xb8\xec\x97\x90 \xec\x93\xb0\xec\xa7\x80 \xeb\xa7\x90\xea\xb3\xa0 Must-Read\xeb\xa1\x9c RULE \xec\xb0\xb8\xec\xa1\xb0\n\n## Template\n\n```markdown\n# [REQ-XXX-001] Capability Name\n\n> **ID**: REQ-XXX-001\n> **Domain**: (\xeb\x8f\x84\xeb\xa9\x94\xec\x9d\xb8)\n> **Status**: [Draft | Active | Deprecated]\n> **Last Updated**: YYYY-MM-DD\n> **Must-Read**: RULE-XXX-001, ADR-XXX\n> **Template-Version**: {TEMPLATE_VERSION}\n\n---\n\n## Decision (\xec\xb5\x9c\xec\xa2\x85 \xea\xb2\xb0\xec\xa0\x95)\n\n(\xea\xb8\xb0\xeb\x8a\xa5\xec\x97\x90 \xeb\x8c\x80\xed\x95\x9c \xeb\xaa\x85\xed\x99\x95\xed\x95\x9c \xea\xb2\xb0\xec\xa0\x95. \xec\xa7\xa7\xea\xb3\xa0 \xeb\x8b\xa8\xeb\x8b\xa8\xed\x95\x98\xea\xb2\x8c.)\n\n## Input\n\n- `param1` (type): description\n\n## Output\n\n- `result` (type): description\n\n## Acceptance Criteria\n\n- [ ] Criterion 1\n- [ ] Criterion 2\n\n## In/Out of Scope (Optional)\n\n### In Scope\n- (\xec\x9d\xb4 \xea\xb8\xb0\xeb\x8a\xa5\xec\x97\x90 \xed\x8f\xac\xed\x95\xa8\xeb\x90\x98\xeb\x8a\x94 \xea\xb2\x83)\n\n### Out of Scope\n- (\xec\x9d\xb4 \xea\xb8\xb0\xeb\x8a\xa5\xec\x97\x90 \xed\x8f\xac\xed\x95\xa8\xeb\x90\x98\xec\xa7\x80 \xec\x95\x8a\xeb\x8a\x94 \xea\xb2\x83)\n\n## Related\n\n- Discussion: [DISC-XXX-001](../discussions/DISC-XXX-001.md)\n- Tech Spec: [API Spec](../../03_TECH_SPECS/api_specs/)\n```\n\n## Rules\n\n1. **\xeb\x8f\x99\xec\x9e\x91\xeb\xa7\x8c \xec\xa0\x81\xeb\x8a\x94\xeb\x8b\xa4**: \xea\xb7\x9c\xec\xb9\x99/\xec\xa0\x9c\xec\x95\xbd\xec\x9d\x80 invariants/\xec\x97\x90\n2. **\xec\xa7\xa7\xea\xb2\x8c \xec\x9c\xa0\xec\xa7\x80**: \xed\x95\x9c REQ = \xed\x95\x98\xeb\x82\x98\xec\x9d\x98 \xeb\xaa\x85\xed\x99\x95\xed\x95\x9c \xea\xb8\xb0\xeb\x8a\xa5\n3. **Must-Read \xed\x95\x84\xec\x88\x98**: RULE/ADR ID\xeb\xa7\x8c, \xeb\xa7\x81\xed\x81\xac \xed\x85\x8d\xec\x8a\xa4\xed\x8a\xb8\xeb\x8a\x94 ID\n4. **ID \xec\x9d\xbc\xec\xb9\x98**: \xed\x8c\x8c\xec\x9d\xbc\xeb\xaa\x85 = **ID**: = \xed\x97\xa4\xeb\x8d\x94 [ID]\n5. **AC \xed\x95\x84\xec\x88\x98**: Acceptance Criteria \xec\x97\x86\xec\x9c\xbc\xeb\xa9\xb4 REQ\xea\xb0\x80 \xec\x95\x84\xeb\x8b\x98\n""",\n\n    "02_REQUIREMENTS/invariants/README.md": f"""# Invariants (RULE-*)\n\n> **Template-Version**: {TEMPLATE_VERSION}\n>\n> **"\xed\x95\xad\xec\x83\x81 ~\xec\x9d\xb4\xeb\x8b\xa4 / ~\xeb\x8a\x94 \xea\xb8\x88\xec\xa7\x80"** \xed\x98\x95\xed\x83\x9c\xec\x9d\x98 \xeb\xb6\x88\xeb\xb3\x80 \xea\xb7\x9c\xec\xb9\x99\xec\x9d\x84 \xec\xa0\x95\xec\x9d\x98\xed\x95\xa9\xeb\x8b\x88\xeb\x8b\xa4.\n\n## RULE \xed\x8c\x90\xec\xa0\x95 \xea\xb8\xb0\xec\xa4\x80\n\n- \xe2\x9c\x85 "\xed\x95\xad\xec\x83\x81 ~~\xec\x9d\xb4\xeb\x8b\xa4 / ~~\xeb\x8a\x94 \xea\xb8\x88\xec\xa7\x80 / ~~\xeb\xa5\xbc \xeb\xa7\x8c\xec\xa1\xb1\xed\x95\xb4\xec\x95\xbc \xed\x95\x9c\xeb\x8b\xa4"\xeb\xa1\x9c \xec\x8b\x9c\xec\x9e\x91 \xea\xb0\x80\xeb\x8a\xa5 (\xeb\xb6\x88\xeb\xb3\x80 \xec\xa4\x91\xec\x8b\xac)\n- \xe2\x9c\x85 Scope / Violation \xed\x8c\x90\xec\xa0\x95 \xea\xb8\xb0\xec\xa4\x80 / Examples \xed\x95\x84\xec\x88\x98\n- \xe2\x9c\x85 \xeb\x8b\xa8\xeb\x8f\x85\xec\x9c\xbc\xeb\xa1\x9c \xec\xb0\xb8/\xea\xb1\xb0\xec\xa7\x93 \xed\x8c\x90\xec\xa0\x95 \xea\xb0\x80\xeb\x8a\xa5 (\xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xea\xb0\x80\xeb\x8a\xa5\xed\x95\x9c \xeb\xac\xb8\xec\x9e\xa5)\n\n## Template\n\n```markdown\n# [RULE-XXX-001] Invariant Name\n\n> **ID**: RULE-XXX-001\n> **Domain**: (\xeb\x8f\x84\xeb\xa9\x94\xec\x9d\xb8)\n> **Priority**: [Critical | High | Medium | Low]\n> **Last Updated**: YYYY-MM-DD\n> **Must-Read**: RULE-XXX-001, ADR-XXX\n> **Template-Version**: {TEMPLATE_VERSION}\n\n---\n\n## Rule Statement (\xec\xb5\x9c\xec\xa2\x85 \xea\xb2\xb0\xec\xa0\x95)\n\n(\xea\xb7\x9c\xec\xb9\x99\xec\x9d\x84 \xeb\xaa\x85\xed\x99\x95\xed\x95\x98\xea\xb2\x8c \xed\x95\x9c \xeb\xac\xb8\xec\x9e\xa5\xec\x9c\xbc\xeb\xa1\x9c. "\xed\x95\xad\xec\x83\x81 ~\xec\x9d\xb4\xeb\x8b\xa4" \xeb\x98\x90\xeb\x8a\x94 "~\xeb\x8a\x94 \xea\xb8\x88\xec\xa7\x80")\n\n## Scope\n\n(\xec\x9d\xb4 \xea\xb7\x9c\xec\xb9\x99\xec\x9d\xb4 \xec\xa0\x81\xec\x9a\xa9\xeb\x90\x98\xeb\x8a\x94 \xeb\xb2\x94\xec\x9c\x84)\n\n## Violation (\xec\x9c\x84\xeb\xb0\x98 \xed\x8c\x90\xec\xa0\x95 \xea\xb8\xb0\xec\xa4\x80)\n\n(\xec\x96\xb4\xeb\x96\xa4 \xea\xb2\xbd\xec\x9a\xb0 \xec\x9d\xb4 \xea\xb7\x9c\xec\xb9\x99\xec\x9d\x84 \xec\x9c\x84\xeb\xb0\x98\xed\x95\x9c \xea\xb2\x83\xec\x9d\xb8\xea\xb0\x80?)\n\n## Examples\n\n### Correct\n(\xec\x98\xac\xeb\xb0\x94\xeb\xa5\xb8 \xec\x98\x88\xec\x8b\x9c)\n\n### Incorrect\n(\xec\x9e\x98\xeb\xaa\xbb\xeb\x90\x9c \xec\x98\x88\xec\x8b\x9c)\n\n## Exceptions\n\n(\xec\x98\x88\xec\x99\xb8 \xec\x83\x81\xed\x99\xa9\xec\x9d\xb4 \xec\x9e\x88\xeb\x8b\xa4\xeb\xa9\xb4)\n```\n\n## Common Domains\n\n- **ID**: ID \xeb\xaa\x85\xeb\xaa\x85 \xea\xb7\x9c\xec\xb9\x99\n- **META**: \xeb\xa9\x94\xed\x83\x80\xeb\x8d\xb0\xec\x9d\xb4\xed\x84\xb0 \xea\xb7\x9c\xec\xb9\x99\n- **DATA**: \xeb\x8d\xb0\xec\x9d\xb4\xed\x84\xb0 \xed\x98\x95\xec\x8b\x9d, \xec\xa0\x80\xec\x9e\xa5 \xea\xb7\x9c\xec\xb9\x99\n- **SEC**: \xeb\xb3\xb4\xec\x95\x88 \xea\xb7\x9c\xec\xb9\x99\n- **VER**: \xeb\xb2\x84\xec\xa0\x84 \xea\xb4\x80\xeb\xa6\xac \xea\xb7\x9c\xec\xb9\x99\n\n## Rules\n\n1. **\xeb\xb6\x88\xeb\xb3\x80\xeb\xa7\x8c \xec\xa0\x81\xeb\x8a\x94\xeb\x8b\xa4**: \xea\xb8\xb0\xeb\x8a\xa5/\xeb\x8f\x99\xec\x9e\x91\xec\x9d\x80 capabilities/\xec\x97\x90\n2. **\xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xea\xb0\x80\xeb\x8a\xa5**: \xeb\x8b\xa8\xeb\x8f\x85\xec\x9c\xbc\xeb\xa1\x9c \xec\xb0\xb8/\xea\xb1\xb0\xec\xa7\x93 \xed\x8c\x90\xec\xa0\x95 \xea\xb0\x80\xeb\x8a\xa5\xed\x95\xb4\xec\x95\xbc \xed\x95\xa8\n3. **Violation \xed\x95\x84\xec\x88\x98**: \xec\x9c\x84\xeb\xb0\x98 \xea\xb8\xb0\xec\xa4\x80 \xec\x97\x86\xec\x9c\xbc\xeb\xa9\xb4 RULE\xec\x9d\xb4 \xec\x95\x84\xeb\x8b\x98\n4. **ID \xec\x9d\xbc\xec\xb9\x98**: \xed\x8c\x8c\xec\x9d\xbc\xeb\xaa\x85 = **ID**: = \xed\x97\xa4\xeb\x8d\x94 [ID]\n""",\n\n    "02_REQUIREMENTS/competencies/README.md": f"""# Competencies (CQ-*)\n\n> **Template-Version**: {TEMPLATE_VERSION}\n>\n> \xec\x8b\x9c\xec\x8a\xa4\xed\x85\x9c\xec\x9d\xb4 \xeb\xb0\x98\xeb\x93\x9c\xec\x8b\x9c \xeb\x8b\xb5\xed\x95\xb4\xec\x95\xbc \xed\x95\x98\xeb\x8a\x94 \xec\xa7\x88\xeb\xac\xb8(\xea\xb2\x80\xec\xa6\x9d \xec\x8b\x9c\xeb\x82\x98\xeb\xa6\xac\xec\x98\xa4)\xec\x9d\x84 \xec\xa0\x95\xec\x9d\x98\xed\x95\xa9\xeb\x8b\x88\xeb\x8b\xa4.\n> CQ\xeb\x8a\x94 REQ/RULE\xec\x9d\x98 \xec\x99\x84\xea\xb2\xb0\xec\x84\xb1\xec\x9d\x84 \xed\x99\x95\xec\x9d\xb8\xed\x95\x98\xeb\x8a\x94 \xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xec\xbc\x80\xec\x9d\xb4\xec\x8a\xa4 \xec\x97\xad\xed\x95\xa0\xec\x9e\x85\xeb\x8b\x88\xeb\x8b\xa4.\n\n## CQ \xed\x8c\x90\xec\xa0\x95 \xea\xb8\xb0\xec\xa4\x80\n\n- \xe2\x9c\x85 "\xec\x8b\x9c\xec\x8a\xa4\xed\x85\x9c\xec\x9d\x80 ~~\xec\x97\x90 \xeb\x8b\xb5\xed\x95\xa0 \xec\x88\x98 \xec\x9e\x88\xeb\x8a\x94\xea\xb0\x80?" \xed\x98\x95\xed\x83\x9c (\xea\xb2\x80\xec\xa6\x9d \xec\xa4\x91\xec\x8b\xac)\n- \xe2\x9c\x85 Question / Expected Answer / Traceability \xed\x95\x84\xec\x88\x98\n- \xe2\x9c\x85 REQ/RULE\xea\xb3\xbc \xeb\xa7\x81\xed\x81\xac\xeb\xa1\x9c \xec\xb6\x94\xec\xa0\x81\xec\x84\xb1 \xed\x99\x95\xeb\xb3\xb4\n\n## Template\n\n```markdown\n# [CQ-XXX-001] Competency Question Title\n\n> **ID**: CQ-XXX-001\n> **Domain**: (\xeb\x8f\x84\xeb\xa9\x94\xec\x9d\xb8)\n> **Status**: [Draft | Active | Deprecated]\n> **Last Updated**: YYYY-MM-DD\n> **Template-Version**: {TEMPLATE_VERSION}\n\n---\n\n## Question\n(\xea\xb2\x80\xec\xa6\x9d \xec\xa7\x88\xeb\xac\xb8)\n\n## Expected Answer (Criteria)\n1. ...\n2. ...\n\n## Traceability\n- **Solves by**: [REQ-XXX-001](../capabilities/REQ-XXX-001.md)\n- **Constrained by**: [RULE-XXX-001](../invariants/RULE-XXX-001.md)\n```\n\n## Rules\n\n1. **\xec\xa7\x88\xeb\xac\xb8 \xec\xa4\x91\xec\x8b\xac**: \xea\xb5\xac\xed\x98\x84 \xeb\xb0\xa9\xeb\xb2\x95\xec\x9d\xb4 \xec\x95\x84\xeb\x8b\x88\xeb\x9d\xbc \xeb\x8b\xb5\xeb\xb3\x80 \xea\xb0\x80\xeb\x8a\xa5\xec\x84\xb1\xec\x97\x90 \xec\xa7\x91\xec\xa4\x91\n2. **\xec\xb6\x94\xec\xa0\x81\xec\x84\xb1 \xed\x95\x84\xec\x88\x98**: \xec\xb5\x9c\xec\x86\x8c 1\xea\xb0\x9c REQ/RULE \xeb\xa7\x81\xed\x81\xac\n3. **ID \xec\x9d\xbc\xec\xb9\x98**: \xed\x8c\x8c\xec\x9d\xbc\xeb\xaa\x85 = **ID**: = \xed\x97\xa4\xeb\x8d\x94 [ID]\n""",\n\n    "02_REQUIREMENTS/discussions/README.md": f"""# Discussions (Reference Layer)\n\n> **Template-Version**: {TEMPLATE_VERSION}\n>\n> \xec\x82\xac\xeb\x9e\x8c-AI \xec\xa1\xb0\xec\x9c\xa8 \xea\xb8\xb0\xeb\xa1\x9d\xec\x9d\x84 \xec\xa0\x80\xec\x9e\xa5\xed\x95\xa9\xeb\x8b\x88\xeb\x8b\xa4.\n> **LLM\xec\x9d\x80 \xea\xb8\xb0\xeb\xb3\xb8\xec\xa0\x81\xec\x9c\xbc\xeb\xa1\x9c \xec\x9d\xb4 \xed\x8f\xb4\xeb\x8d\x94\xeb\xa5\xbc \xec\x9d\xbd\xec\xa7\x80 \xec\x95\x8a\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4.**\n\n## When to Use\n\n- \xec\x9a\x94\xea\xb5\xac\xec\x82\xac\xed\x95\xad \xeb\x85\xbc\xec\x9d\x98 \xea\xb3\xbc\xec\xa0\x95 \xea\xb8\xb0\xeb\xa1\x9d\n- \xeb\x8c\x80\xec\x95\x88 \xea\xb2\x80\xed\x86\xa0 \xeb\xb0\x8f \xeb\xb9\x84\xea\xb5\x90\n- \xea\xb2\xb0\xec\xa0\x95 \xea\xb7\xbc\xea\xb1\xb0 \xec\x83\x81\xec\x84\xb8 \xec\x84\xa4\xeb\xaa\x85\n- \xec\x9d\xb4\xed\x95\xb4\xea\xb4\x80\xea\xb3\x84\xec\x9e\x90 \xec\x9d\x98\xea\xb2\xac \xec\xa1\xb0\xec\x9c\xa8\n\n## Template\n\n```markdown\n# [DISC-XXX-001] Discussion Title\n\n> **ID**: DISC-XXX-001\n> **Related-REQ**: REQ-XXX-001 (or RULE-XXX-001)\n> **Date**: YYYY-MM-DD\n> **Participants**: (\xec\xb0\xb8\xec\x97\xac\xec\x9e\x90)\n> **Template-Version**: {TEMPLATE_VERSION}\n\n---\n\n## Context\n\n(\xeb\x85\xbc\xec\x9d\x98 \xeb\xb0\xb0\xea\xb2\xbd)\n\n## Options Considered\n\n### Option A: (\xeb\x8c\x80\xec\x95\x88 1)\n- Pros: ...\n- Cons: ...\n\n### Option B: (\xeb\x8c\x80\xec\x95\x88 2)\n- Pros: ...\n- Cons: ...\n\n## Discussion Log\n\n### YYYY-MM-DD\n- [Person/AI]: \xec\x9d\x98\xea\xb2\xac 1\n- [Person/AI]: \xec\x9d\x98\xea\xb2\xac 2\n\n## Conclusion\n\n(\xea\xb2\xb0\xeb\xa1\xa0 \xe2\x86\x92 REQ/RULE\xec\x97\x90 \xeb\xb0\x98\xec\x98\x81\xeb\x90\xa8)\n```\n\n## Important Notes\n\n1. **LLM \xea\xb8\xb0\xeb\xb3\xb8 \xeb\xac\xb4\xec\x8b\x9c**: \xeb\xaa\x85\xec\x8b\x9c\xec\xa0\x81\xec\x9c\xbc\xeb\xa1\x9c \xec\xb0\xb8\xec\xa1\xb0\xed\x95\x98\xec\xa7\x80 \xec\x95\x8a\xec\x9c\xbc\xeb\xa9\xb4 \xec\x9d\xbd\xec\xa7\x80 \xec\x95\x8a\xec\x9d\x8c\n2. **REQ\xec\x99\x80 \xec\x97\xb0\xea\xb2\xb0**: `Related-REQ` \xed\x95\x84\xeb\x93\x9c\xeb\xa1\x9c \xea\xb4\x80\xeb\xa0\xa8 \xea\xb2\xb0\xec\xa0\x95 \xeb\xac\xb8\xec\x84\x9c \xec\x97\xb0\xea\xb2\xb0\n3. **Archive \xec\xa0\x95\xec\xb1\x85**: \xec\x98\xa4\xeb\x9e\x98\xeb\x90\x9c \xeb\x85\xbc\xec\x9d\x98\xeb\x8a\x94 `99_ARCHIVE/discussions/`\xeb\xa1\x9c \xec\x9d\xb4\xeb\x8f\x99\n""",\n\n    "02_REQUIREMENTS/discussions/briefs/README.md": f"""# Briefs (Intake Layer)\n\n> **Template-Version**: {TEMPLATE_VERSION}\n>\n> **Idea/User Request**\xeb\xa5\xbc \xeb\xb9\xa0\xeb\xa5\xb4\xea\xb3\xa0 \xea\xb0\x80\xeb\xb3\x8d\xea\xb2\x8c \xea\xb8\xb0\xeb\xa1\x9d\xed\x95\x98\xeb\x8a\x94 \xea\xb3\xb3\xec\x9e\x85\xeb\x8b\x88\xeb\x8b\xa4.\n> `intake()` \xeb\xaa\x85\xeb\xa0\xb9\xec\x96\xb4\xeb\xa5\xbc \xed\x86\xb5\xed\x95\xb4 \xec\x83\x9d\xec\x84\xb1\xeb\x90\xa9\xeb\x8b\x88\xeb\x8b\xa4.\n\n## Workflow\n\n1. `intake("\xec\x84\xa4\xeb\xaa\x85")` -> `BRIEF-XXX-001.md` \xec\x83\x9d\xec\x84\xb1\n2. BRIEF \xea\xb2\x80\xed\x86\xa0 \xeb\xb0\x8f \xea\xb5\xac\xec\xb2\xb4\xed\x99\x94 (LLM/Human)\n3. `plan("BRIEF-ID")` -> `RUN` \xeb\xb0\x8f `REQ` \xec\x83\x9d\xec\x84\xb1\n\n## Template\n\n```markdown\n# [BRIEF-DOMAIN-001] Title\n\n> **ID**: BRIEF-DOMAIN-001\n> **Date**: YYYY-MM-DD\n> **Status**: Active\n\n## 1. User Request (\xec\x9b\x90\xeb\xb3\xb8 \xec\x9a\x94\xec\xb2\xad)\n(\xec\x82\xac\xec\x9a\xa9\xec\x9e\x90\xec\x9d\x98 \xec\x9b\x90\xeb\x9e\x98 \xed\x85\x8d\xec\x8a\xa4\xed\x8a\xb8 \xeb\xb3\xb4\xec\xa1\xb4)\n\n## 2. Intent Summary (\xec\x9d\x98\xeb\x8f\x84 \xec\x9a\x94\xec\x95\xbd)\n- **Goal**: ...\n- **Problem**: ...\n\n## 3. Affected Artifacts\n- Create: ...\n- Modify: ...\n\n## 4. Proposed Changes\n1. ...\n2. ...\n\n## 5. Verification Criteria\n- [ ] ...\n```\n""",\n\n    # =========================================================================\n    # 02_REQUIREMENTS/_index.md (Human Entry Point)\n    # =========================================================================\n    "02_REQUIREMENTS/_index.md": f"""# 02_REQUIREMENTS \xec\x9d\xbd\xea\xb8\xb0 \xea\xb0\x80\xec\x9d\xb4\xeb\x93\x9c\n\n> **Template-Version**: {TEMPLATE_VERSION}\n>\n> \xec\x9d\xb4 \xeb\xac\xb8\xec\x84\x9c\xeb\x8a\x94 \xec\x82\xac\xeb\x9e\x8c\xea\xb3\xbc LLM\xec\x9d\xb4 \xec\x9a\x94\xea\xb5\xac\xec\x82\xac\xed\x95\xad \xeb\xac\xb8\xec\x84\x9c\xeb\xa5\xbc **\xec\x96\xb4\xeb\x94\x94\xec\x84\x9c\xeb\xb6\x80\xed\x84\xb0 \xec\x9d\xbd\xec\x96\xb4\xec\x95\xbc \xed\x95\x98\xeb\x8a\x94\xec\xa7\x80** \xec\x95\x88\xeb\x82\xb4\xed\x95\xa9\xeb\x8b\x88\xeb\x8b\xa4.\n\n## \xf0\x9f\x93\x96 \xec\x9d\xbd\xeb\x8a\x94 \xec\x88\x9c\xec\x84\x9c\n\n### 1\xeb\x8b\xa8\xea\xb3\x84: \xec\xa0\x84\xec\x97\xad \xea\xb7\x9c\xec\xb9\x99 (\xed\x95\x84\xec\x88\x98)\n\n\xec\x95\x84\xeb\x9e\x98 \xea\xb7\x9c\xec\xb9\x99\xeb\x93\xa4\xec\x9d\x80 \xeb\xaa\xa8\xeb\x93\xa0 REQ \xea\xb5\xac\xed\x98\x84 \xec\xa0\x84\xec\x97\x90 \xeb\xb0\x98\xeb\x93\x9c\xec\x8b\x9c \xec\x9d\xbd\xec\x96\xb4\xec\x95\xbc \xed\x95\xa9\xeb\x8b\x88\xeb\x8b\xa4:\n\n| \xec\x88\x9c\xec\x84\x9c | \xeb\xac\xb8\xec\x84\x9c | \xec\x84\xa4\xeb\xaa\x85 |\n|------|------|------|\n| 1 | [RULE-ID-001](invariants/RULE-ID-001.md) | ID \xeb\xaa\x85\xeb\xaa\x85 \xea\xb7\x9c\xec\xb9\x99 |\n| 2 | [RULE-META-001](invariants/RULE-META-001.md) | \xeb\xa9\x94\xed\x83\x80\xeb\x8d\xb0\xec\x9d\xb4\xed\x84\xb0 \xed\x95\x84\xeb\x93\x9c \xea\xb7\x9c\xec\xb9\x99 |\n| 3 | [RULE-MUST-001](invariants/RULE-MUST-001.md) | Must-Read \xec\xb0\xb8\xec\xa1\xb0 \xea\xb7\x9c\xec\xb9\x99 |\n\n### 2\xeb\x8b\xa8\xea\xb3\x84: \xeb\x8c\x80\xec\x83\x81 \xea\xb8\xb0\xeb\x8a\xa5 \xeb\xb0\x8f \xea\xb2\x80\xec\xa6\x9d (\xec\x84\xa0\xed\x83\x9d)\n\n1. \xea\xb5\xac\xed\x98\x84\xed\x95\xa0 \xea\xb8\xb0\xeb\x8a\xa5\xec\x9d\x98 REQ \xeb\xac\xb8\xec\x84\x9c\xeb\xa5\xbc \xec\x9d\xbd\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4.\n2. \xed\x95\xb4\xeb\x8b\xb9 \xea\xb8\xb0\xeb\x8a\xa5\xec\x97\x90 \xec\x97\xb0\xea\xb2\xb0\xeb\x90\x9c CQ \xeb\xac\xb8\xec\x84\x9c\xeb\xa5\xbc \xec\x9d\xbd\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4. (\xec\x9e\x88\xeb\x8b\xa4\xeb\xa9\xb4)\n3. REQ\xec\x99\x80 CQ\xea\xb0\x80 `**Must-Read**`\xeb\xa1\x9c \xec\xb0\xb8\xec\xa1\xb0\xed\x95\x98\xeb\x8a\x94 RULE/ADR\xec\x9d\x84 \xec\x9d\xbd\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4.\n\n## \xf0\x9f\x8f\xb7\xef\xb8\x8f \xed\x8f\xb4\xeb\x8d\x94 \xea\xb5\xac\xec\xa1\xb0\n\n| \xed\x8f\xb4\xeb\x8d\x94 | \xec\xa7\x88\xeb\xac\xb8 | \xeb\x82\xb4\xec\x9a\xa9 |\n|------|------|------|\n| `capabilities/` | "\xeb\xac\xb4\xec\x97\x87\xec\x9d\x84 \xeb\xa7\x8c\xeb\x93\x9c\xeb\x8a\x94\xea\xb0\x80?" | REQ-* (\xea\xb8\xb0\xeb\x8a\xa5/\xed\x96\x89\xeb\x8f\x99) |\n| `invariants/` | "\xeb\xac\xb4\xec\x97\x87\xec\x9d\xb4 \xed\x95\xad\xec\x83\x81 \xec\xb0\xb8\xec\x9d\xb8\xea\xb0\x80?" | RULE-* (\xeb\xb6\x88\xeb\xb3\x80 \xea\xb7\x9c\xec\xb9\x99) |\n| `competencies/` | "\xeb\xac\xb4\xec\x97\x87\xec\x9d\x84 \xed\x95\xb4\xea\xb2\xb0\xed\x95\x98\xeb\x8a\x94\xea\xb0\x80?" | CQ-* (\xec\x97\xad\xeb\x9f\x89 \xec\xa7\x88\xeb\xac\xb8/\xec\x8b\x9c\xeb\x82\x98\xeb\xa6\xac\xec\x98\xa4) |\n| `discussions/` | "\xec\x96\xb4\xeb\x96\xbb\xea\xb2\x8c \xea\xb2\xb0\xec\xa0\x95\xed\x96\x88\xeb\x8a\x94\xea\xb0\x80?" | DISC-* (\xec\xa1\xb0\xec\x9c\xa8 \xea\xb8\xb0\xeb\xa1\x9d) |\n\n## REQ vs RULE vs CQ \xeb\xb9\xa0\xeb\xa5\xb8 \xed\x8c\x90\xec\xa0\x95\n\n```\nREQ (capabilities/)\n  \xe2\x86\x92 "\xec\x8b\x9c\xec\x8a\xa4\xed\x85\x9c\xec\x9d\x80 ~\xed\x95\xb4\xec\x95\xbc \xed\x95\x9c\xeb\x8b\xa4" (\xeb\x8f\x99\xec\x9e\x91 \xec\xa4\x91\xec\x8b\xac)\n  \xe2\x86\x92 Input/Output/AC \xed\x95\x84\xec\x88\x98\n\nRULE (invariants/)\n  \xe2\x86\x92 "\xed\x95\xad\xec\x83\x81 ~\xec\x9d\xb4\xeb\x8b\xa4 / ~\xeb\x8a\x94 \xea\xb8\x88\xec\xa7\x80" (\xeb\xb6\x88\xeb\xb3\x80 \xec\xa4\x91\xec\x8b\xac)\n  \xe2\x86\x92 Scope/Violation/Examples \xed\x95\x84\xec\x88\x98\n\nCQ (competencies/)\n  \xe2\x86\x92 "\xec\x8b\x9c\xec\x8a\xa4\xed\x85\x9c\xec\x9d\x80 ~\xec\x97\x90 \xeb\x8b\xb5\xed\x95\xa0 \xec\x88\x98 \xec\x9e\x88\xeb\x8a\x94\xea\xb0\x80?" (\xea\xb2\x80\xec\xa6\x9d \xec\xa4\x91\xec\x8b\xac)\n  \xe2\x86\x92 Question/Expected Answer/Traceability \xed\x95\x84\xec\x88\x98\n```\n\n## \xf0\x9f\x94\x97 Quick Links\n\n- \xea\xb5\xac\xec\xa1\xb0 \xec\x84\xa4\xeb\xaa\x85: [README.md](README.md)\n- \xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8 \xea\xb7\x9c\xec\xb9\x99: [01_CONVENTIONS.md](../01_PROJECT_CONTEXT/01_CONVENTIONS.md)\n\n## \xe2\x9a\xa0\xef\xb8\x8f \xec\xa3\xbc\xec\x9d\x98\xec\x82\xac\xed\x95\xad\n\n- `competencies/`\xeb\x8a\x94 **\xec\xb0\xb8\xec\xa1\xb0\xeb\x90\x9c \xea\xb2\xbd\xec\x9a\xb0\xec\x97\x90\xeb\xa7\x8c \xec\x9d\xbd\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4** (REQ/CQ \xec\x97\xb0\xea\xb2\xb0 \xec\x8b\x9c)\n- `discussions/`\xeb\x8a\x94 **\xea\xb8\xb0\xeb\xb3\xb8\xec\xa0\x81\xec\x9c\xbc\xeb\xa1\x9c \xec\x9d\xbd\xec\xa7\x80 \xec\x95\x8a\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4** (\xeb\xaa\x85\xec\x8b\x9c\xec\xa0\x81 \xec\xb0\xb8\xec\xa1\xb0 \xec\x8b\x9c\xeb\xa7\x8c)\n- \xea\xb0\x81 REQ\xec\x9d\x98 `**Must-Read**` \xed\x95\x84\xeb\x93\x9c\xea\xb0\x80 **\xec\x9d\xbd\xea\xb8\xb0 \xec\x9a\xb0\xec\x84\xa0\xec\x88\x9c\xec\x9c\x84\xec\x9d\x98 \xea\xb6\x8c\xec\x9c\x84**\xec\x9e\x85\xeb\x8b\x88\xeb\x8b\xa4\n""",\n\n    # =========================================================================\n    # 03_TECH_SPECS\n    # =========================================================================\n    "03_TECH_SPECS/README.md": f"""# Technical Specifications (HOW)\n\n> **Template-Version**: {TEMPLATE_VERSION}\n>\n> **"\xec\x96\xb4\xeb\x96\xbb\xea\xb2\x8c \xeb\xa7\x8c\xeb\x93\xa4 \xea\xb2\x83\xec\x9d\xb8\xea\xb0\x80?"**\xeb\xa5\xbc \xec\xa0\x95\xec\x9d\x98\xed\x95\xa9\xeb\x8b\x88\xeb\x8b\xa4.\n\n## Structure\n\n```\n03_TECH_SPECS/\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 architecture/       # \xea\xb5\xac\xec\xa1\xb0\xeb\x8f\x84, DB \xec\x8a\xa4\xed\x82\xa4\xeb\xa7\x88\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 api_specs/          # \xec\x9e\x85\xec\xb6\x9c\xeb\xa0\xa5 \xeb\xaa\x85\xec\x84\xb8\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 decisions/          # ADR (RATIONALE)\n```\n\n## Relation to Authority\n\n```\nREQ (Authority) \xe2\x86\x92 TECH_SPEC (Implementation) \xe2\x86\x92 CODE\n```\n\nTECH_SPEC\xec\x9d\x80 REQ\xec\x9d\x98 \xea\xb2\xb0\xec\xa0\x95\xec\x9d\x84 **\xea\xb5\xac\xed\x98\x84**\xed\x95\x98\xeb\x8a\x94 \xeb\xb0\xa9\xeb\xb2\x95\xec\x9d\x84 \xec\xa0\x95\xec\x9d\x98\xed\x95\xa9\xeb\x8b\x88\xeb\x8b\xa4.\nREQ\xec\x99\x80 \xec\xb6\xa9\xeb\x8f\x8c \xec\x8b\x9c, REQ\xea\xb0\x80 \xec\x9a\xb0\xec\x84\xa0\xed\x95\xa9\xeb\x8b\x88\xeb\x8b\xa4.\n""",\n\n    "03_TECH_SPECS/architecture/README.md": f"""# Architecture Documents\n\n> **Template-Version**: {TEMPLATE_VERSION}\n\n## Template: System Architecture\n\n```markdown\n# System Architecture\n\n> **Last Updated**: YYYY-MM-DD\n> **Template-Version**: {TEMPLATE_VERSION}\n\n---\n\n## High-Level Diagram\n\n(ASCII \xeb\x8b\xa4\xec\x9d\xb4\xec\x96\xb4\xea\xb7\xb8\xeb\x9e\xa8 \xeb\x98\x90\xeb\x8a\x94 \xec\x9d\xb4\xeb\xaf\xb8\xec\xa7\x80 \xeb\xa7\x81\xed\x81\xac)\n\n## Components\n\n| Component | Responsibility | Technology |\n|-----------|---------------|------------|\n| Frontend | UI | React |\n| Backend | API | FastAPI |\n| Database | Storage | PostgreSQL |\n\n## Data Flow\n\n1. User -> Frontend\n2. Frontend -> Backend API\n3. Backend -> Database\n```\n""",\n\n    "03_TECH_SPECS/api_specs/README.md": f"""# API Specifications\n\n> **Template-Version**: {TEMPLATE_VERSION}\n\n## Template\n\n```markdown\n# [Module Name] API Specification\n\n> **Module**: (\xeb\xaa\xa8\xeb\x93\x88\xeb\xaa\x85)\n> **Last Updated**: YYYY-MM-DD\n> **Related-REQ**: REQ-XXX-001\n> **Template-Version**: {TEMPLATE_VERSION}\n\n---\n\n## Endpoints / Functions\n\n### `GET /api/users/{{id}}`\n\n- **Description**: \xec\x82\xac\xec\x9a\xa9\xec\x9e\x90 \xec\xa0\x95\xeb\xb3\xb4 \xec\xa1\xb0\xed\x9a\x8c\n- **Parameters**: `id` (UUID)\n- **Response**: User object\n- **Error Codes**: 404, 500\n```\n""",\n\n    "03_TECH_SPECS/decisions/README.md": f"""# Architecture Decision Records (RATIONALE)\n\n> **Template-Version**: {TEMPLATE_VERSION}\n>\n> \xea\xb8\xb0\xec\x88\xa0\xec\xa0\x81 \xec\x9d\x98\xec\x82\xac\xea\xb2\xb0\xec\xa0\x95\xea\xb3\xbc \xea\xb7\xb8 **\xea\xb7\xbc\xea\xb1\xb0**\xeb\xa5\xbc \xea\xb8\xb0\xeb\xa1\x9d\xed\x95\xa9\xeb\x8b\x88\xeb\x8b\xa4.\n\n## Why ADR?\n\n"\xec\x99\x9c MongoDB \xeb\x8c\x80\xec\x8b\xa0 PostgreSQL\xec\x9d\x84 \xec\x8d\xbc\xeb\x8a\x94\xea\xb0\x80?"\xec\x97\x90 \xeb\x8c\x80\xed\x95\x9c \xeb\x8b\xb5\xec\x9d\x84 \xeb\x82\xa8\xea\xb9\x81\xeb\x8b\x88\xeb\x8b\xa4.\n\xea\xb5\xac\xec\xa1\xb0\xeb\xa5\xbc \xeb\x92\xa4\xec\xa7\x91\xec\x9d\x84 \xeb\x95\x8c, \xec\x9d\xb4 \xea\xb8\xb0\xeb\xa1\x9d\xec\x9d\x84 \xeb\xb3\xb4\xec\xa7\x80 \xec\x95\x8a\xec\x9c\xbc\xeb\xa9\xb4 \xea\xb0\x99\xec\x9d\x80 \xec\x8b\xa4\xec\x88\x98\xeb\xa5\xbc \xeb\xb0\x98\xeb\xb3\xb5\xed\x95\xa9\xeb\x8b\x88\xeb\x8b\xa4.\n\n## Template\n\n```markdown\n# ADR-001: [Decision Title]\n\n> **Status**: [Proposed | Accepted | Deprecated | Superseded]\n> **Date**: YYYY-MM-DD\n> **Deciders**: (\xea\xb2\xb0\xec\xa0\x95\xec\x9e\x90)\n> **Related-REQ**: REQ-XXX-001\n> **Template-Version**: {TEMPLATE_VERSION}\n\n---\n\n## Context\n\n(\xeb\xac\xb8\xec\xa0\x9c \xec\x83\x81\xed\x99\xa9\xec\x9d\x84 \xec\x84\xa4\xeb\xaa\x85)\n\n## Decision\n\n(\xeb\xac\xb4\xec\x97\x87\xec\x9d\x84 \xea\xb2\xb0\xec\xa0\x95\xed\x96\x88\xeb\x8a\x94\xea\xb0\x80?)\n\n## Alternatives Considered\n\n### Option A\n- Pros: ...\n- Cons: ...\n\n### Option B\n- Pros: ...\n- Cons: ...\n\n## Consequences\n\n### Positive\n- ...\n\n### Negative\n- ...\n```\n""",\n\n    # =========================================================================\n    # 04_TASK_LOGS (v2.2 - Execution Unit)\n    # =========================================================================\n    "04_TASK_LOGS/README.md": f"""# Task Logs (Execution Layer)\n\n> **Template-Version**: {TEMPLATE_VERSION}\n>\n> \xec\x8b\xa4\xed\x96\x89 \xea\xb8\xb0\xeb\xa1\x9d\xec\x9d\x84 \xea\xb4\x80\xeb\xa6\xac\xed\x95\xa9\xeb\x8b\x88\xeb\x8b\xa4.\n\n## Execution Unit Model (v2.2)\n\n```\n\xec\x8b\xa4\xed\x96\x89 \xeb\xac\xb8\xec\x84\x9c 1\xea\xb0\x9c = 1\xeb\xaa\xa9\xec\xa0\x81 + 1\xea\xb2\x80\xec\xa6\x9d + 1\xea\xb2\xb0\xea\xb3\xbc\n\nRUN-REQ-AUTH-001-step-01.md  (\xeb\xa1\x9c\xea\xb7\xb8\xec\x9d\xb8 \xed\x8f\xbc \xea\xb5\xac\xed\x98\x84)\nRUN-REQ-AUTH-001-step-02.md  (API \xec\x97\xb0\xeb\x8f\x99)\nRUN-REQ-AUTH-001-step-03.md  (\xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xec\x9e\x91\xec\x84\xb1)\n```\n\n### Why Small Units?\n\n- \xed\x81\xb0 RUN \xea\xb8\x88\xec\xa7\x80: \xed\x95\x9c\xeb\xb2\x88 \xec\x8b\xa4\xed\x96\x89\xec\x97\x90 \xeb\x84\x88\xeb\xac\xb4 \xeb\xa7\x8e\xec\x9d\x80 \xeb\xb3\x80\xea\xb2\xbd\xec\x9d\xb4 \xeb\xac\xb6\xec\x9d\xb4\xeb\xa9\xb4 \xec\xb6\x94\xec\xa0\x81 \xeb\xb6\x88\xea\xb0\x80\n- 1:1 \xeb\x8c\x80\xec\x9d\x91: \xeb\xb3\x80\xea\xb2\xbd \xec\x9d\xb4\xec\x9c\xa0\xeb\xa5\xbc \xeb\xaa\x85\xed\x99\x95\xed\x9e\x88 \xec\xb6\x94\xec\xa0\x81 \xea\xb0\x80\xeb\x8a\xa5\n- \xea\xb2\x80\xec\x83\x89 \xea\xb0\x80\xeb\x8a\xa5: \xeb\xa1\x9c\xea\xb7\xb8\xea\xb0\x80 \xec\x8c\x93\xec\x97\xac\xeb\x8f\x84 \xec\x9d\x98\xeb\xaf\xb8\xec\x9e\x88\xeb\x8a\x94 \xea\xb2\x80\xec\x83\x89\n\n## Structure\n\n```\n04_TASK_LOGS/\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 active/             # \xec\x8b\xa4\xed\x96\x89 \xec\xa4\x91 (RUN-*)\n\xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 RUN-REQ-AUTH-001-step-01.md\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 archive/            # \xec\x99\x84\xeb\xa3\x8c\xeb\x90\x9c \xec\x9e\x91\xec\x97\x85\n    \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 YYYY-MM/\n        \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 RUN-*.md\n```\n\n## Naming Convention\n\n`RUN-[REQ|RULE]-[DOMAIN]-[NNN]-step-[NN].md`\n\nExamples:\n- `RUN-REQ-AUTH-001-step-01.md`\n- `RUN-REQ-AUTH-001-step-02.md`\n- `RUN-RULE-DATA-001-step-01.md`\n\n## Scope for Partial Updates\n\nWhen only part of a REQ changes, define In Scope / Out of Scope in the RUN.\nKeep the REQ as the full contract; use DISC or a new Draft REQ for pending work.\n\n""",\n\n    "04_TASK_LOGS/active/README.md": f"""# Active Tasks (Execution)\n\n> **Template-Version**: {TEMPLATE_VERSION}\n\n## Dashboard (\xec\x9e\x90\xeb\x8f\x99 \xea\xb0\xb1\xec\x8b\xa0)\n\n| Status | RUN ID | Started | Summary | Git |\n|--------|--------|---------|---------|-----|\n| (\xec\x9e\x90\xeb\x8f\x99 \xec\x83\x9d\xec\x84\xb1) | | | | |\n\n> \xec\x9d\xb4 \xed\x85\x8c\xec\x9d\xb4\xeb\xb8\x94\xec\x9d\x80 `--runs` \xeb\xaa\x85\xeb\xa0\xb9 \xeb\x98\x90\xeb\x8a\x94 \xec\x8b\x9c\xec\x8a\xa4\xed\x85\x9c \xec\x97\x85\xeb\x8d\xb0\xec\x9d\xb4\xed\x8a\xb8 \xec\x8b\x9c \xec\x9e\x90\xeb\x8f\x99 \xea\xb0\xb1\xec\x8b\xa0\xeb\x90\xa9\xeb\x8b\x88\xeb\x8b\xa4.\n\n## RUN Document Template\n\n```markdown\n# [RUN-REQ-XXX-001-step-01] Step Title\n\n> **ID**: RUN-REQ-XXX-001-step-01\n> **Summary**: (\xec\x82\xac\xeb\x9e\x8c\xec\x9a\xa9 1\xec\xa4\x84 \xec\x9a\x94\xec\x95\xbd)\n> **Status**: Active | Completed | Failed\n> **Started**: YYYY-MM-DD\n> **Completed**: (\xec\x99\x84\xeb\xa3\x8c \xec\x8b\x9c \xec\x9e\x90\xeb\x8f\x99 \xea\xb8\xb0\xeb\xa1\x9d)\n> **Git**: (\xec\xbb\xa4\xeb\xb0\x8b \xed\x95\xb4\xec\x8b\x9c \xeb\x98\x90\xeb\x8a\x94 no-commit)\n> **Input**: BRIEF-XXX-001, REQ-XXX-001\n> **Verification**: (\xec\x84\xb1\xea\xb3\xb5 \xec\xa1\xb0\xea\xb1\xb4 - \xed\x95\x9c \xec\xa4\x84 \xec\x9a\x94\xec\x95\xbd)\n> **Template-Version**: {TEMPLATE_VERSION}\n\n---\n\n## Objective\n\n(\xec\x9d\xb4 \xeb\x8b\xa8\xea\xb3\x84\xec\x9d\x98 \xeb\xaa\xa9\xed\x91\x9c - \xed\x95\x98\xeb\x82\x98\xeb\xa7\x8c)\n\n## Scope\n\n### In Scope\n\n- (List the parts of the REQ you will change)\n\n### Out of Scope\n\n- (Explicitly state what will not be touched this run)\n\n## Steps\n\n1. [ ] Step 1\n2. [ ] Step 2\n\n## Verification (Self-Check)\n\n> \xec\x9e\x91\xec\x97\x85 \xec\x99\x84\xeb\xa3\x8c \xec\xa0\x84 \xeb\xb0\x98\xeb\x93\x9c\xec\x8b\x9c \xed\x99\x95\xec\x9d\xb8\xed\x95\x98\xeb\x8a\x94 \xec\xb2\xb4\xed\x81\xac\xeb\xa6\xac\xec\x8a\xa4\xed\x8a\xb8\n\n- [ ] **Test**: `pytest tests/test_xxx.py` \xed\x86\xb5\xea\xb3\xbc?\n- [ ] **Boundary**: Secret \xec\xbb\xa4\xeb\xb0\x8b \xec\x97\x86\xec\x9d\x8c? (`01_CONVENTIONS.md` Boundaries \xec\xa4\x80\xec\x88\x98?)\n- [ ] **Spec**: \xea\xb5\xac\xed\x98\x84\xec\x9d\xb4 `REQ-XXX-001`\xea\xb3\xbc \xec\x9d\xbc\xec\xb9\x98?\n\n### Success Condition\n(\xec\x84\xb1\xea\xb3\xb5 \xec\xa1\xb0\xea\xb1\xb4 \xec\x83\x81\xec\x84\xb8)\n\n## Evidence (Implementation Proof)\n\n- Tests: (what passed)\n- Commands: (what was executed)\n- Code references: (files/functions showing current behavior)\n- **Git**: (\xec\xbb\xa4\xeb\xb0\x8b \xed\x95\xb4\xec\x8b\x9c \xea\xb8\xb0\xeb\xa1\x9d)\n\n## Output\n\n(\xec\x83\x9d\xec\x84\xb1/\xec\x88\x98\xec\xa0\x95\xeb\x90\x9c \xed\x8c\x8c\xec\x9d\xbc \xeb\xaa\xa9\xeb\xa1\x9d)\n\n- `src/auth/login.py` - Created\n- `tests/test_login.py` - Created\n```\n\n## Rules\n\n1. **1 RUN = 1 \xeb\xaa\xa9\xec\xa0\x81**: \xec\x97\xac\xeb\x9f\xac \xeb\xaa\xa9\xec\xa0\x81\xec\x9d\x84 \xec\x84\x9e\xec\xa7\x80 \xec\x95\x8a\xec\x9d\x8c\n2. **Input \xeb\xaa\x85\xec\x8b\x9c**: \xec\x9d\xbd\xec\x96\xb4\xec\x95\xbc \xed\x95\xa0 \xeb\xac\xb8\xec\x84\x9c ID \xeb\xaa\xa9\xeb\xa1\x9d (Must-Read \xed\x8f\xac\xed\x95\xa8)\n3. **Verification \xeb\xaa\x85\xec\x8b\x9c**: \xec\x84\xb1\xea\xb3\xb5 \xec\xa1\xb0\xea\xb1\xb4 + Self-Check \xec\xb2\xb4\xed\x81\xac\xeb\xa6\xac\xec\x8a\xa4\xed\x8a\xb8\n4. **Output \xea\xb8\xb0\xeb\xa1\x9d**: \xec\x83\x9d\xec\x84\xb1/\xec\x88\x98\xec\xa0\x95 \xed\x8c\x8c\xec\x9d\xbc \xeb\xaa\xa9\xeb\xa1\x9d\n5. **Self-Check \xed\x95\x84\xec\x88\x98**: \xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8, Boundary, Spec \xec\x9d\xbc\xec\xb9\x98 \xed\x99\x95\xec\x9d\xb8\n6. **Scope \xeb\xaa\x85\xed\x99\x95\xed\x99\x94**: In Scope / Out of Scope \xea\xb5\xac\xeb\xb6\x84 \xed\x95\x84\xec\x88\x98\n7. **Evidence \xed\x99\x95\xeb\xb3\xb4**: Git \xec\xbb\xa4\xeb\xb0\x8b \xed\x95\xb4\xec\x8b\x9c \xed\x95\x84\xec\x88\x98 \xea\xb8\xb0\xeb\xa1\x9d\n\n## Archive \xec\xa0\x95\xec\xb1\x85 (v3.4+)\n\n- **RUN\xec\x9d\x80 \xec\x9d\xb4\xeb\x8f\x99\xed\x95\x98\xec\xa7\x80 \xec\x95\x8a\xec\x9d\x8c**: \xeb\xaa\xa8\xeb\x93\xa0 RUN\xec\x9d\x80 `active/`\xec\x97\x90 \xec\x9c\xa0\xec\xa7\x80\n- **\xec\x99\x84\xeb\xa3\x8c \xed\x91\x9c\xec\x8b\x9c**: Status \xeb\xa9\x94\xed\x83\x80\xeb\x8d\xb0\xec\x9d\xb4\xed\x84\xb0\xeb\xa1\x9c\xeb\xa7\x8c \xea\xb4\x80\xeb\xa6\xac (Active \xe2\x86\x92 Completed/Failed)\n- **\xec\xa6\x9d\xea\xb1\xb0**: Git \xec\xbb\xa4\xeb\xb0\x8b \xed\x95\xb4\xec\x8b\x9c\xea\xb0\x80 \xec\x9c\xa0\xec\x9d\xbc\xed\x95\x9c \xec\xa6\x9d\xea\xb1\xb0\n- **\xea\xb0\x80\xeb\x8f\x85\xec\x84\xb1**: \xec\x9d\xb4 README\xec\x9d\x98 Dashboard \xed\x85\x8c\xec\x9d\xb4\xeb\xb8\x94\xeb\xa1\x9c \xec\xa1\xb0\xed\x9a\x8c""",\n\n    "04_TASK_LOGS/archive/README.md": f"""# Archived Tasks\n\n> **Template-Version**: {TEMPLATE_VERSION}\n\n## Structure\n\n```\narchive/\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 2024-01/\n\xe2\x94\x82   \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 RUN-REQ-AUTH-001-step-01.md\n\xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 RUN-REQ-AUTH-001-step-02.md\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 2024-02/\n\xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 ...\n```\n\n## Archive Criteria\n\n- Status\xea\xb0\x80 `Done`\xec\x9c\xbc\xeb\xa1\x9c \xeb\xb3\x80\xea\xb2\xbd\xeb\x90\x9c RUN \xeb\xac\xb8\xec\x84\x9c\n- \xec\x9b\x94\xeb\xb3\x84\xeb\xa1\x9c \xec\x9e\x90\xeb\x8f\x99 \xec\xa0\x95\xeb\xa6\xac\n""",\n\n    # =========================================================================\n    # 98_KNOWLEDGE\n    # =========================================================================\n    "98_KNOWLEDGE/README.md": """# Knowledge Base (ASSET)\n\n> \xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8\xeb\xa5\xbc \xec\xa7\x84\xed\x96\x89\xed\x95\x98\xeb\xa9\xb4\xec\x84\x9c \xeb\xb0\xb0\xec\x9a\xb4 **"\xec\x9d\xbc\xeb\xb0\x98\xec\xa0\x81\xec\x9d\xb8 \xec\xa7\x80\xec\x8b\x9d"**\xec\x9d\x84 \xec\xa0\x80\xec\x9e\xa5\xed\x95\xa9\xeb\x8b\x88\xeb\x8b\xa4.\n\n## Why This Folder?\n\n- Task Log\xec\x97\x90 "\xed\x8c\x8c\xec\x9d\xb4\xec\x8d\xac asyncio \xec\x97\x90\xeb\x9f\xac \xed\x95\xb4\xea\xb2\xb0\xeb\xb2\x95"\xec\x9d\x84 \xec\xa0\x81\xec\x96\xb4\xeb\x91\x90\xeb\xa9\xb4, \xeb\x82\x98\xec\xa4\x91\xec\x97\x90 \xeb\xa1\x9c\xea\xb7\xb8\xea\xb0\x80 \xec\x8c\x93\xec\x97\xac\xec\x84\x9c \xea\xb2\x80\xec\x83\x89\xec\x9d\xb4 \xec\x95\x88 \xeb\x90\xa9\xeb\x8b\x88\xeb\x8b\xa4.\n- \xeb\xb0\xb0\xec\x9a\xb4 \xec\xa0\x90\xec\x9d\x84 \xeb\xb3\x84\xeb\x8f\x84\xeb\xa1\x9c \xec\xa0\x80\xec\x9e\xa5\xed\x95\xb4\xec\x95\xbc \xea\xb3\xbc\xea\xb1\xb0\xec\x9d\x98 \xec\x8b\xa4\xec\x88\x98\xeb\xa5\xbc \xeb\xb0\x98\xeb\xb3\xb5\xed\x95\x98\xec\xa7\x80 \xec\x95\x8a\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4.\n\n## Structure\n\n```\n98_KNOWLEDGE/\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 troubleshooting/    # \xed\x95\xb4\xea\xb2\xb0\xeb\x90\x9c \xeb\x82\x9c\xec\xa0\x9c\xeb\x93\xa4\n\xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 [topic]/        # \xec\xa3\xbc\xec\xa0\x9c\xeb\xb3\x84 \xeb\xb6\x84\xeb\xa5\x98\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 [other_topics]/     # \xed\x95\x84\xec\x9a\x94\xec\x97\x90 \xeb\x94\xb0\xeb\x9d\xbc \xec\xb6\x94\xea\xb0\x80\n```\n""",\n\n    "98_KNOWLEDGE/troubleshooting/README.md": f"""# Troubleshooting Guide\n\n> **Template-Version**: {TEMPLATE_VERSION}\n\n## Template\n\n```markdown\n# [Issue Title]\n\n> **Category**: [Python | JavaScript | Database | DevOps | ...]\n> **Date Discovered**: YYYY-MM-DD\n> **Related Task**: RUN-REQ-XXX-001-step-NN\n> **Template-Version**: {TEMPLATE_VERSION}\n\n---\n\n## Problem\n\n(\xeb\xac\xb8\xec\xa0\x9c \xec\x83\x81\xed\x99\xa9 \xec\x84\xa4\xeb\xaa\x85)\n\n## Root Cause\n\n(\xec\x9b\x90\xec\x9d\xb8 \xeb\xb6\x84\xec\x84\x9d)\n\n## Solution\n\n(\xed\x95\xb4\xea\xb2\xb0 \xeb\xb0\xa9\xeb\xb2\x95)\n\n## Prevention\n\n(\xeb\x8b\xa4\xec\x8b\x9c \xeb\xb0\x9c\xec\x83\x9d\xed\x95\x98\xec\xa7\x80 \xec\x95\x8a\xec\x9c\xbc\xeb\xa0\xa4\xeb\xa9\xb4?)\n```\n""",\n\n    # =========================================================================\n    # 00_SYSTEM\n    # =========================================================================\n    "00_SYSTEM/README.md": f"""# System Management\n\n> [!CAUTION]\n> ## SYSTEM-MANAGED FOLDER\n>\n> \xec\x9d\xb4 \xed\x8f\xb4\xeb\x8d\x94\xeb\x8a\x94 `memory_manager.py`\xec\x97\x90 \xec\x9d\x98\xed\x95\xb4 **\xec\x9e\x90\xeb\x8f\x99 \xea\xb4\x80\xeb\xa6\xac**\xeb\x90\xa9\xeb\x8b\x88\xeb\x8b\xa4.\n>\n> ### Overwrite Policy\n> - **AGENT_RULES.md**: \xec\x8b\x9c\xec\x8a\xa4\xed\x85\x9c \xec\x97\x85\xeb\x8d\xb0\xec\x9d\xb4\xed\x8a\xb8 \xec\x8b\x9c \xeb\x8d\xae\xec\x96\xb4\xec\x93\xb0\xea\xb8\xb0\xeb\x90\xa8\n> - **ONBOARDING_PROMPT.md**: \xec\x8b\x9c\xec\x8a\xa4\xed\x85\x9c \xec\x97\x85\xeb\x8d\xb0\xec\x9d\xb4\xed\x8a\xb8 \xec\x8b\x9c \xeb\x8d\xae\xec\x96\xb4\xec\x93\xb0\xea\xb8\xb0\xeb\x90\xa8\n> - **scripts/**: \xec\x8b\x9c\xec\x8a\xa4\xed\x85\x9c \xec\x97\x85\xeb\x8d\xb0\xec\x9d\xb4\xed\x8a\xb8 \xec\x8b\x9c \xeb\x8d\xae\xec\x96\xb4\xec\x93\xb0\xea\xb8\xb0\xeb\x90\xa8\n> - **mcp/**: auto-generated MCP definitions (overwritten on update)\n> - \xec\x82\xac\xec\x9a\xa9\xec\x9e\x90/\xec\x97\x90\xec\x9d\xb4\xec\xa0\x84\xed\x8a\xb8 \xec\x88\x98\xec\xa0\x95 -> \xeb\x8b\xa4\xec\x9d\x8c \xec\x97\x85\xeb\x8d\xb0\xec\x9d\xb4\xed\x8a\xb8\xec\x97\x90\xec\x84\x9c \xec\x9b\x90\xeb\xb3\xb5\n>\n> ### For Customization\n> \xec\xbb\xa4\xec\x8a\xa4\xed\x85\x80 \xea\xb7\x9c\xec\xb9\x99\xec\x9d\xb4 \xed\x95\x84\xec\x9a\x94\xed\x95\x98\xeb\xa9\xb4 `01_PROJECT_CONTEXT/01_CONVENTIONS.md`\xec\x97\x90 \xec\x9e\x91\xec\x84\xb1\xed\x95\x98\xec\x84\xb8\xec\x9a\x94.\n\n## MCP Auto-Launch\n\n- STDIO clients can auto-spawn the MCP server using the configured command.\n- This means the server does not need to be running manually in the background.\n- HTTP mode still requires a long-running server process.\n- Use `python memory_manager.py --bootstrap-mcp --target <client> --os <windows|unix>` to generate MCP bootstrap prompts and templates.\n- Validate with `python memory_manager.py --mcp-check --target <client>`.\n\n## Version Info\n\n- **Manager Version**: {CURRENT_VERSION}\n- **Template Version**: {TEMPLATE_VERSION}""",\n\n    # =========================================================================\n    # GETTING_STARTED.md (User-facing Guide)\n    # =========================================================================\n    "GETTING_STARTED.md": f"""# \xf0\x9f\x9a\x80 MemoryAtlas \xec\x8b\x9c\xec\x9e\x91\xed\x95\x98\xea\xb8\xb0\n\n> **Version**: {CURRENT_VERSION} | **Template**: {TEMPLATE_VERSION}\n>\n> \xec\x9d\xb4 \xeb\xac\xb8\xec\x84\x9c\xeb\x8a\x94 MemoryAtlas\xeb\xa5\xbc \xec\xb2\x98\xec\x9d\x8c \xec\x82\xac\xec\x9a\xa9\xed\x95\x98\xeb\x8a\x94 \xec\x82\xac\xec\x9a\xa9\xec\x9e\x90\xeb\xa5\xbc \xec\x9c\x84\xed\x95\x9c \xec\x84\xa4\xec\xa0\x95 \xea\xb0\x80\xec\x9d\xb4\xeb\x93\x9c\xec\x9e\x85\xeb\x8b\x88\xeb\x8b\xa4.\n\n## Quick Start\n\n```bash\n# 1. \xec\x98\xa8\xeb\xb3\xb4\xeb\x94\xa9 \xec\x8b\x9c\xec\x9e\x91 (\xeb\x8c\x80\xed\x99\x94\xed\x98\x95 \xec\x84\xa4\xec\xa0\x95)\npython memory_manager.py --guide\n\n# 2. \xec\xb6\x9c\xeb\xa0\xa5\xeb\x90\x9c \xed\x94\x84\xeb\xa1\xac\xed\x94\x84\xed\x8a\xb8\xeb\xa5\xbc LLM\xec\x97\x90\xea\xb2\x8c \xec\xa0\x84\xeb\x8b\xac\n# 3. LLM\xec\x9d\x98 \xec\xa7\x88\xeb\xac\xb8\xec\x97\x90 \xeb\x8b\xb5\xed\x95\x98\xeb\xa9\xb0 \xec\x84\xa4\xec\xa0\x95 \xec\x99\x84\xeb\xa3\x8c\n```\n\n## \xec\x84\xa4\xec\xa0\x95 \xec\xb2\xb4\xed\x81\xac\xeb\xa6\xac\xec\x8a\xa4\xed\x8a\xb8\n\n### Phase 1: \xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8 \xea\xb8\xb0\xeb\xb3\xb8 \xec\xa0\x95\xeb\xb3\xb4\n- [ ] \xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8 \xec\x9d\xb4\xeb\xa6\x84 \xec\x84\xa4\xec\xa0\x95 <!-- id:phase1.project_name -->\n- [ ] \xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8 \xeb\xaa\xa9\xed\x91\x9c \xec\xa0\x95\xec\x9d\x98 (`01_PROJECT_CONTEXT/00_GOALS.md`) <!-- id:phase1.project_goal -->\n- [ ] \xea\xb8\xb0\xec\x88\xa0 \xec\x8a\xa4\xed\x83\x9d \xea\xb2\xb0\xec\xa0\x95 <!-- id:phase1.tech_stack -->\n\n### Phase 2: \xea\xb0\x9c\xeb\xb0\x9c \xea\xb7\x9c\xec\xb9\x99 \xec\x84\xa4\xec\xa0\x95\n- [ ] \xec\xbd\x94\xeb\x94\xa9 \xec\xbb\xa8\xeb\xb2\xa4\xec\x85\x98 \xec\xa0\x95\xec\x9d\x98 (`01_PROJECT_CONTEXT/01_CONVENTIONS.md`) <!-- id:phase2.coding_style -->\n- [ ] Boundaries \xec\x84\xa4\xec\xa0\x95 (\xea\xb8\x88\xec\xa7\x80 \xec\x82\xac\xed\x95\xad) <!-- id:phase2.boundaries -->\n- [ ] \xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xec\xa0\x95\xec\xb1\x85 \xea\xb2\xb0\xec\xa0\x95 <!-- id:phase2.testing_policy -->\n\n### Phase 3: MCP \xec\x97\xb0\xeb\x8f\x99 (\xec\x84\xa0\xed\x83\x9d)\n- [ ] MCP \xec\x84\x9c\xeb\xb2\x84 \xec\x84\xa4\xec\xa0\x95 \xed\x99\x95\xec\x9d\xb8 <!-- id:phase3.mcp_server -->\n- [ ] \xed\x81\xb4\xeb\x9d\xbc\xec\x9d\xb4\xec\x96\xb8\xed\x8a\xb8 \xec\x97\xb0\xeb\x8f\x99 \xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 <!-- id:phase3.mcp_client -->\n- [ ] `intake()`, `plan()`, `finish()` \xeb\x8f\x99\xec\x9e\x91 \xed\x99\x95\xec\x9d\xb8 <!-- id:phase3.mcp_tools -->\n\n## \xec\x84\xa4\xec\xa0\x95 \xec\x99\x84\xeb\xa3\x8c \xed\x9b\x84\n\n\xec\x84\xa4\xec\xa0\x95\xec\x9d\xb4 \xec\x99\x84\xeb\xa3\x8c\xeb\x90\x98\xeb\xa9\xb4 \xeb\x8b\xa4\xec\x9d\x8c \xeb\xaa\x85\xeb\xa0\xb9\xec\x96\xb4\xeb\xa5\xbc \xec\x82\xac\xec\x9a\xa9\xed\x95\xa0 \xec\x88\x98 \xec\x9e\x88\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4:\n\n| \xeb\xaa\x85\xeb\xa0\xb9\xec\x96\xb4 | \xec\x84\xa4\xeb\xaa\x85 |\n|--------|------|\n| `intake("\xec\x9a\x94\xec\xb2\xad")` | \xec\x95\x84\xec\x9d\xb4\xeb\x94\x94\xec\x96\xb4 \xe2\x86\x92 BRIEF \xec\x83\x9d\xec\x84\xb1 |\n| `plan("BRIEF-ID")` | BRIEF \xe2\x86\x92 RUN \xec\x83\x9d\xec\x84\xb1 |\n| `finish("RUN-ID", git_hash="...")` | Status \xec\x99\x84\xeb\xa3\x8c + Git \xec\xa6\x9d\xea\xb1\xb0 \xea\xb8\xb0\xeb\xa1\x9d |\n\n## \xeb\x8f\x84\xec\x9b\x80\xec\x9d\xb4 \xed\x95\x84\xec\x9a\x94\xed\x95\x98\xeb\xa9\xb4\n\n- \xf0\x9f\x93\x96 [README.md](../README.md) - \xec\xa0\x84\xec\xb2\xb4 \xec\x8b\x9c\xec\x8a\xa4\xed\x85\x9c \xec\x9d\xb4\xed\x95\xb4\n- \xf0\x9f\x93\x8b [00_INDEX.md](00_INDEX.md) - \xeb\xac\xb8\xec\x84\x9c \xeb\x84\xa4\xeb\xb9\x84\xea\xb2\x8c\xec\x9d\xb4\xec\x85\x98\n- \xf0\x9f\x94\xa7 `python memory_manager.py --doctor` - \xec\x8b\x9c\xec\x8a\xa4\xed\x85\x9c \xea\xb2\x80\xec\xa6\x9d\n\n## \xec\x98\xa8\xeb\xb3\xb4\xeb\x94\xa9 \xec\x83\x81\xed\x83\x9c\n\n> **Status**: {{STATUS}}\n> **Last Updated**: {{LAST_UPDATED}}\n\n## \xec\x82\xac\xec\x9a\xa9\xec\x9e\x90 \xeb\xa9\x94\xeb\xaa\xa8\n<!-- NOTES:BEGIN -->\n(\xec\x9e\x90\xec\x9c\xa0\xeb\xa1\xad\xea\xb2\x8c \xea\xb8\xb0\xeb\xa1\x9d)\n<!-- NOTES:END -->\n""",\n\n    # =========================================================================\n    # 00_SYSTEM/ONBOARDING_PROMPT.md (CLI Reference for LLM)\n    # =========================================================================\n    "00_SYSTEM/ONBOARDING_PROMPT.md": f"""# MemoryAtlas \xec\x98\xa8\xeb\xb3\xb4\xeb\x94\xa9 \xed\x94\x84\xeb\xa1\xac\xed\x94\x84\xed\x8a\xb8\n\n> **Version**: {CURRENT_VERSION}\n>\n> \xec\x9d\xb4 \xed\x8c\x8c\xec\x9d\xbc\xec\x9d\x80 `--guide` \xeb\xaa\x85\xeb\xa0\xb9 \xec\x8b\x9c LLM\xec\x97\x90\xea\xb2\x8c \xec\xa0\x84\xeb\x8b\xac\xeb\x90\x98\xeb\x8a\x94 \xec\x98\xa8\xeb\xb3\xb4\xeb\x94\xa9 \xed\x94\x84\xeb\xa1\xac\xed\x94\x84\xed\x8a\xb8\xec\x9e\x85\xeb\x8b\x88\xeb\x8b\xa4.\n\n---\n\n## \xf0\x9f\xa4\x96 LLM \xec\xa7\x80\xec\x8b\x9c\xec\x82\xac\xed\x95\xad\n\n\xeb\x8b\xb9\xec\x8b\xa0\xec\x9d\x80 MemoryAtlas \xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8 \xec\x84\xa4\xec\xa0\x95\xec\x9d\x84 \xeb\x8f\x84\xec\x99\x80\xec\xa3\xbc\xeb\x8a\x94 \xec\x98\xa8\xeb\xb3\xb4\xeb\x94\xa9 \xec\x96\xb4\xec\x8b\x9c\xec\x8a\xa4\xed\x84\xb4\xed\x8a\xb8\xec\x9e\x85\xeb\x8b\x88\xeb\x8b\xa4.\n\xec\x82\xac\xec\x9a\xa9\xec\x9e\x90\xea\xb0\x80 \xec\x9d\xb4 \xed\x94\x84\xeb\xa1\xac\xed\x94\x84\xed\x8a\xb8\xeb\xa5\xbc \xec\xa0\x84\xeb\x8b\xac\xed\x95\x98\xeb\xa9\xb4, \xec\x95\x84\xeb\x9e\x98 \xeb\x8b\xa8\xea\xb3\x84\xec\x97\x90 \xeb\x94\xb0\xeb\x9d\xbc \xeb\x8c\x80\xed\x99\x94\xed\x95\x98\xeb\xa9\xb0 \xec\x84\xa4\xec\xa0\x95\xec\x9d\x84 \xec\x99\x84\xeb\xa3\x8c\xed\x95\x98\xec\x84\xb8\xec\x9a\x94.\n\n### \xec\xa7\x84\xed\x96\x89 \xea\xb7\x9c\xec\xb9\x99\n1. \xec\x8b\x9c\xec\x9e\x91 \xec\x8b\x9c `GETTING_STARTED.md`\xeb\xa5\xbc \xec\x9d\xbd\xea\xb3\xa0 Status/\xec\xb2\xb4\xed\x81\xac\xeb\xa6\xac\xec\x8a\xa4\xed\x8a\xb8\xeb\xa5\xbc \xed\x99\x95\xec\x9d\xb8\xed\x95\x9c \xeb\x92\xa4, \xeb\xaf\xb8\xec\x99\x84\xeb\xa3\x8c \xeb\x8b\xa8\xea\xb3\x84\xeb\xb6\x80\xed\x84\xb0 \xec\x9d\xb4\xec\x96\xb4\xec\x84\x9c \xec\xa7\x84\xed\x96\x89\xed\x95\x98\xec\x84\xb8\xec\x9a\x94\n2. \xed\x95\x9c \xeb\xb2\x88\xec\x97\x90 1-2\xea\xb0\x9c \xec\xa7\x88\xeb\xac\xb8\xeb\xa7\x8c \xed\x95\x98\xec\x84\xb8\xec\x9a\x94\n3. \xec\x82\xac\xec\x9a\xa9\xec\x9e\x90 \xeb\x8b\xb5\xeb\xb3\x80\xec\x9d\x84 \xeb\xb0\x9b\xec\x9c\xbc\xeb\xa9\xb4 \xed\x95\xb4\xeb\x8b\xb9 \xed\x8c\x8c\xec\x9d\xbc\xec\x97\x90 \xec\xa7\x81\xec\xa0\x91 \xeb\xb0\x98\xec\x98\x81\xed\x95\x98\xec\x84\xb8\xec\x9a\x94\n4. \xea\xb0\x81 Phase \xec\x99\x84\xeb\xa3\x8c \xec\x8b\x9c `GETTING_STARTED.md`\xec\x9d\x98 \xec\xb2\xb4\xed\x81\xac\xeb\xa6\xac\xec\x8a\xa4\xed\x8a\xb8\xec\x99\x80 Status/Last Updated\xeb\xa5\xbc \xec\x97\x85\xeb\x8d\xb0\xec\x9d\xb4\xed\x8a\xb8\xed\x95\x98\xec\x84\xb8\xec\x9a\x94\n5. \xec\xb2\xb4\xed\x81\xac\xeb\xa6\xac\xec\x8a\xa4\xed\x8a\xb8 \xeb\xb3\x80\xea\xb2\xbd \xec\x8b\x9c `00_SYSTEM/state/onboarding.json`\xeb\x8f\x84 \xed\x95\xa8\xea\xbb\x98 \xea\xb0\xb1\xec\x8b\xa0\xed\x95\x98\xec\x84\xb8\xec\x9a\x94\n6. \xeb\xaa\xa8\xeb\x93\xa0 Phase \xec\x99\x84\xeb\xa3\x8c \xec\x8b\x9c \xec\xb6\x95\xed\x95\x98 \xeb\xa9\x94\xec\x8b\x9c\xec\xa7\x80\xec\x99\x80 \xeb\x8b\xa4\xec\x9d\x8c \xeb\x8b\xa8\xea\xb3\x84 \xec\x95\x88\xeb\x82\xb4\n\n---\n\n## Phase 1: \xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8 \xea\xb8\xb0\xeb\xb3\xb8 \xec\xa0\x95\xeb\xb3\xb4\n\n### Q1. \xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8 \xec\x9d\xb4\xeb\xa6\x84\n> "\xec\x9d\xb4 \xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8\xec\x9d\x98 \xec\x9d\xb4\xeb\xa6\x84\xec\x9d\x80 \xeb\xac\xb4\xec\x97\x87\xec\x9d\xb8\xea\xb0\x80\xec\x9a\x94?"\n\n\xe2\x86\x92 \xeb\xb0\x98\xec\x98\x81 \xec\x9c\x84\xec\xb9\x98: `01_PROJECT_CONTEXT/00_GOALS.md` > Name\n\n### Q2. \xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8 \xeb\xaa\xa9\xed\x91\x9c\n> "\xec\x9d\xb4 \xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8\xea\xb0\x80 \xed\x95\xb4\xea\xb2\xb0\xed\x95\x98\xeb\xa0\xa4\xeb\x8a\x94 \xeb\xac\xb8\xec\xa0\x9c\xeb\x8a\x94 \xeb\xac\xb4\xec\x97\x87\xec\x9d\xb8\xea\xb0\x80\xec\x9a\x94? \xed\x95\x9c \xeb\xac\xb8\xec\x9e\xa5\xec\x9c\xbc\xeb\xa1\x9c \xec\x84\xa4\xeb\xaa\x85\xed\x95\xb4\xec\xa3\xbc\xec\x84\xb8\xec\x9a\x94."\n\n\xe2\x86\x92 \xeb\xb0\x98\xec\x98\x81 \xec\x9c\x84\xec\xb9\x98: `01_PROJECT_CONTEXT/00_GOALS.md` > One-Line Summary\n\n### Q3. \xea\xb8\xb0\xec\x88\xa0 \xec\x8a\xa4\xed\x83\x9d\n> "\xec\x82\xac\xec\x9a\xa9\xed\x95\xa0 \xec\xa3\xbc\xec\x9a\x94 \xea\xb8\xb0\xec\x88\xa0 \xec\x8a\xa4\xed\x83\x9d\xec\x9d\x80 \xeb\xac\xb4\xec\x97\x87\xec\x9d\xb8\xea\xb0\x80\xec\x9a\x94? (\xec\x98\x88: Python, TypeScript, React \xeb\x93\xb1)"\n\n\xe2\x86\x92 \xeb\xb0\x98\xec\x98\x81 \xec\x9c\x84\xec\xb9\x98: `01_PROJECT_CONTEXT/00_GOALS.md` > Tech Stack\n\n---\n\n## Phase 2: \xea\xb0\x9c\xeb\xb0\x9c \xea\xb7\x9c\xec\xb9\x99 \xec\x84\xa4\xec\xa0\x95\n\n### Q4. \xec\xbd\x94\xeb\x94\xa9 \xec\x8a\xa4\xed\x83\x80\xec\x9d\xbc\n> "\xec\x84\xa0\xed\x98\xb8\xed\x95\x98\xeb\x8a\x94 \xec\xbd\x94\xeb\x94\xa9 \xec\x8a\xa4\xed\x83\x80\xec\x9d\xbc\xec\x9d\xb4 \xec\x9e\x88\xeb\x82\x98\xec\x9a\x94? (\xec\x98\x88: PEP8, ESLint, Prettier \xeb\x93\xb1)"\n\n\xe2\x86\x92 \xeb\xb0\x98\xec\x98\x81 \xec\x9c\x84\xec\xb9\x98: `01_PROJECT_CONTEXT/01_CONVENTIONS.md` > Coding Style\n\n### Q5. Boundaries (\xea\xb8\x88\xec\xa7\x80 \xec\x82\xac\xed\x95\xad)\n> "\xec\x9d\xb4 \xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8\xec\x97\x90\xec\x84\x9c \xec\xa0\x88\xeb\x8c\x80 \xed\x95\xb4\xec\x84\x9c\xeb\x8a\x94 \xec\x95\x88 \xeb\x90\x98\xeb\x8a\x94 \xea\xb2\x83\xec\x9d\xb4 \xec\x9e\x88\xeb\x82\x98\xec\x9a\x94? (\xec\x98\x88: \xed\x8a\xb9\xec\xa0\x95 \xeb\x9d\xbc\xec\x9d\xb4\xeb\xb8\x8c\xeb\x9f\xac\xeb\xa6\xac \xec\x82\xac\xec\x9a\xa9 \xea\xb8\x88\xec\xa7\x80, \xed\x8a\xb9\xec\xa0\x95 \xed\x8c\xa8\xed\x84\xb4 \xea\xb8\x88\xec\xa7\x80)"\n\n\xe2\x86\x92 \xeb\xb0\x98\xec\x98\x81 \xec\x9c\x84\xec\xb9\x98: `01_PROJECT_CONTEXT/01_CONVENTIONS.md` > Boundaries\n\n### Q6. \xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xec\xa0\x95\xec\xb1\x85\n> "\xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8\xeb\x8a\x94 \xec\x96\xb4\xeb\x96\xbb\xea\xb2\x8c \xec\xa7\x84\xed\x96\x89\xed\x95\xa0 \xec\x98\x88\xec\xa0\x95\xec\x9d\xb8\xea\xb0\x80\xec\x9a\x94? (\xec\x98\x88: pytest, jest, \xec\xbb\xa4\xeb\xb2\x84\xeb\xa6\xac\xec\xa7\x80 \xeb\xaa\xa9\xed\x91\x9c \xeb\x93\xb1)"\n\n\xe2\x86\x92 \xeb\xb0\x98\xec\x98\x81 \xec\x9c\x84\xec\xb9\x98: `01_PROJECT_CONTEXT/01_CONVENTIONS.md` > Testing Policy\n\n---\n\n## Phase 3: MCP \xec\x97\xb0\xeb\x8f\x99 \xed\x99\x95\xec\x9d\xb8 (\xec\x84\xa0\xed\x83\x9d)\n\n### Q7. MCP \xec\x82\xac\xec\x9a\xa9 \xec\x97\xac\xeb\xb6\x80\n> "MCP(Model Context Protocol) \xeb\x8f\x84\xea\xb5\xac\xeb\xa5\xbc \xec\x82\xac\xec\x9a\xa9\xed\x95\xa0 \xec\x98\x88\xec\xa0\x95\xec\x9d\xb8\xea\xb0\x80\xec\x9a\x94? (intake, plan, finish \xec\x9e\x90\xeb\x8f\x99\xed\x99\x94)"\n\n- Yes \xe2\x86\x92 MCP \xec\x84\xa4\xec\xa0\x95 \xec\x95\x88\xeb\x82\xb4 \xec\xa7\x84\xed\x96\x89\n- No \xe2\x86\x92 Phase \xec\x99\x84\xeb\xa3\x8c\n\n### Q8. MCP \xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 (Yes\xec\x9d\xb8 \xea\xb2\xbd\xec\x9a\xb0)\n> "MCP \xec\x84\x9c\xeb\xb2\x84\xea\xb0\x80 \xec\xa0\x95\xec\x83\x81 \xeb\x8f\x99\xec\x9e\x91\xed\x95\x98\xeb\x8a\x94\xec\xa7\x80 \xed\x99\x95\xec\x9d\xb8\xed\x95\xb4\xeb\xb3\xb4\xea\xb2\xa0\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4."\n\n\xec\x8b\xa4\xed\x96\x89: `python memory_manager.py --mcp-check`\n\n---\n\n## \xec\x99\x84\xeb\xa3\x8c \xec\x8b\x9c \xed\x96\x89\xeb\x8f\x99\n\n1. `GETTING_STARTED.md`\xec\x9d\x98 \xeb\xaa\xa8\xeb\x93\xa0 \xec\xb2\xb4\xed\x81\xac\xeb\xb0\x95\xec\x8a\xa4\xeb\xa5\xbc [x]\xeb\xa1\x9c \xeb\xb3\x80\xea\xb2\xbd\n2. `GETTING_STARTED.md`\xec\x9d\x98 Status\xeb\xa5\xbc "Completed"\xeb\xa1\x9c \xeb\xb3\x80\xea\xb2\xbd\xed\x95\x98\xea\xb3\xa0 Last Updated\xeb\xa5\xbc \xea\xb0\xb1\xec\x8b\xa0\n3. `00_SYSTEM/state/onboarding.json`\xec\x9d\x98 \xed\x95\xad\xeb\xaa\xa9\xec\x9d\x84 Completed\xeb\xa1\x9c \xea\xb0\xb1\xec\x8b\xa0\n4. \xec\x82\xac\xec\x9a\xa9\xec\x9e\x90\xec\x97\x90\xea\xb2\x8c \xeb\x8b\xa4\xec\x9d\x8c \xec\x95\x88\xeb\x82\xb4:\n   - "\xec\x84\xa4\xec\xa0\x95\xec\x9d\xb4 \xec\x99\x84\xeb\xa3\x8c\xeb\x90\x98\xec\x97\x88\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4! \xec\x9d\xb4\xec\xa0\x9c \'intake \xed\x95\xb4\xec\xa4\x98\'\xeb\xa1\x9c \xec\xb2\xab \xec\x9e\x91\xec\x97\x85\xec\x9d\x84 \xec\x8b\x9c\xec\x9e\x91\xed\x95\xb4\xeb\xb3\xb4\xec\x84\xb8\xec\x9a\x94."\n\n---\n\n## \xed\x98\x84\xec\x9e\xac \xec\xa7\x84\xed\x96\x89 \xec\x83\x81\xed\x83\x9c\n\n> \xec\x8b\xa4\xec\xa0\x9c \xec\xa7\x84\xed\x96\x89 \xec\x83\x81\xed\x83\x9c\xeb\x8a\x94 `GETTING_STARTED.md`\xec\x97\x90\xec\x84\x9c \xea\xb4\x80\xeb\xa6\xac\xed\x95\xa9\xeb\x8b\x88\xeb\x8b\xa4. \xec\x9d\xb4 \xec\x84\xb9\xec\x85\x98\xec\x9d\x80 \xec\xb0\xb8\xea\xb3\xa0\xec\x9a\xa9\xec\x9e\x85\xeb\x8b\x88\xeb\x8b\xa4.\n\n- Phase 1: [ ] Not Started\n- Phase 2: [ ] Not Started\n- Phase 3: [ ] Not Started\n- Overall: [ ] Not Started\n""",\n}\n\n# ============================================================================\n# BOOTSTRAP TEMPLATES (v2.4 - Context Bootstrapping)\n# ============================================================================\nBOOTSTRAP_PROMPT_TEMPLATE = f"""# \xf0\x9f\x9a\x80 \xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8 \xed\x82\xa5\xec\x98\xa4\xed\x94\x84 (Context Bootstrapping)\n\n> **MemoryAtlas v{CURRENT_VERSION}**\n>\n> \xec\x9d\xb4 \xed\x8c\x8c\xec\x9d\xbc\xec\x9d\x84 AI \xec\x97\x90\xec\x9d\xb4\xec\xa0\x84\xed\x8a\xb8(Claude, GPT \xeb\x93\xb1)\xec\x97\x90\xea\xb2\x8c \xec\xa0\x84\xeb\x8b\xac\xed\x95\x98\xec\x84\xb8\xec\x9a\x94.\n> AI\xea\xb0\x80 \xec\x95\x84\xeb\x9e\x98 \xec\xa3\xbc\xec\xa0\x9c\xeb\xa1\x9c \xec\x9d\xb8\xed\x84\xb0\xeb\xb7\xb0 \xed\x9b\x84, \xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8 \xed\x97\x8c\xeb\xb2\x95\xec\x9d\x84 \xec\x99\x84\xec\x84\xb1\xed\x95\xa9\xeb\x8b\x88\xeb\x8b\xa4.\n\n---\n\n## \xec\x82\xac\xec\x9a\xa9 \xeb\xb0\xa9\xeb\xb2\x95\n\n1. \xec\x9d\xb4 \xed\x8c\x8c\xec\x9d\xbc \xeb\x82\xb4\xec\x9a\xa9\xec\x9d\x84 AI \xec\xb1\x84\xed\x8c\x85\xec\xb0\xbd\xec\x97\x90 \xeb\xb3\xb5\xec\x82\xac\xed\x95\x98\xea\xb1\xb0\xeb\x82\x98, AI\xec\x97\x90\xea\xb2\x8c \xec\x9d\xb4 \xed\x8c\x8c\xec\x9d\xbc\xec\x9d\x84 \xec\x9d\xbd\xea\xb2\x8c \xed\x95\x98\xec\x84\xb8\xec\x9a\x94.\n2. AI\xea\xb0\x80 \xec\x95\x84\xeb\x9e\x98 \xec\x95\x84\xec\xa0\xa0\xeb\x8b\xa4\xec\x97\x90 \xeb\x94\xb0\xeb\x9d\xbc \xec\xa7\x88\xeb\xac\xb8\xed\x95\xa9\xeb\x8b\x88\xeb\x8b\xa4.\n3. \xeb\x8c\x80\xed\x99\x94\xea\xb0\x80 \xeb\x81\x9d\xeb\x82\x98\xeb\xa9\xb4 AI\xea\xb0\x80 \xec\x99\x84\xec\x84\xb1\xeb\x90\x9c \xeb\xac\xb8\xec\x84\x9c\xeb\xa5\xbc \xec\xb6\x9c\xeb\xa0\xa5\xed\x95\xa9\xeb\x8b\x88\xeb\x8b\xa4.\n4. \xec\xb6\x9c\xeb\xa0\xa5\xeb\x90\x9c \xeb\x82\xb4\xec\x9a\xa9\xec\x9d\x84 \xed\x95\xb4\xeb\x8b\xb9 \xed\x8c\x8c\xec\x9d\xbc\xec\x97\x90 \xec\xa0\x80\xec\x9e\xa5\xed\x95\x98\xec\x84\xb8\xec\x9a\x94.\n5. `python memory_manager.py --doctor`\xeb\xa1\x9c \xea\xb2\x80\xec\xa6\x9d\xed\x95\x98\xec\x84\xb8\xec\x9a\x94.\n\n---\n\n## \xf0\x9f\x8e\xaf \xed\x86\xa0\xec\x9d\x98 \xec\x95\x84\xec\xa0\xa0\xeb\x8b\xa4 (AI\xec\x97\x90\xea\xb2\x8c \xec\xa0\x84\xeb\x8b\xac\xed\x95\xa0 \xeb\x82\xb4\xec\x9a\xa9)\n\n### 1. Project Identity (\xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8 \xec\xa0\x95\xec\xb2\xb4\xec\x84\xb1)\n\n\xeb\x82\x98\xec\x97\x90\xea\xb2\x8c \xeb\x8b\xa4\xec\x9d\x8c\xec\x9d\x84 \xec\xa7\x88\xeb\xac\xb8\xed\x95\xb4\xec\xa3\xbc\xec\x84\xb8\xec\x9a\x94:\n- \xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8 \xec\x9d\xb4\xeb\xa6\x84\xec\x9d\x80 \xeb\xac\xb4\xec\x97\x87\xec\x9d\xb8\xea\xb0\x80\xec\x9a\x94?\n- \xed\x95\x9c \xeb\xac\xb8\xec\x9e\xa5\xec\x9c\xbc\xeb\xa1\x9c \xec\x84\xa4\xeb\xaa\x85\xed\x95\x98\xeb\xa9\xb4?\n- \xec\xa3\xbc\xec\x9a\x94 \xec\x82\xac\xec\x9a\xa9\xec\x9e\x90\xeb\x8a\x94 \xeb\x88\x84\xea\xb5\xac\xec\x9d\xb8\xea\xb0\x80\xec\x9a\x94?\n- \xed\x95\xb5\xec\x8b\xac \xea\xb0\x80\xec\xb9\x98/\xeb\xaa\xa9\xed\x91\x9c\xeb\x8a\x94 \xeb\xac\xb4\xec\x97\x87\xec\x9d\xb8\xea\xb0\x80\xec\x9a\x94?\n\n### 2. Tech Stack (\xea\xb8\xb0\xec\x88\xa0 \xec\x8a\xa4\xed\x83\x9d)\n\n\xeb\x82\x98\xec\x97\x90\xea\xb2\x8c \xeb\x8b\xa4\xec\x9d\x8c\xec\x9d\x84 \xec\xa7\x88\xeb\xac\xb8\xed\x95\xb4\xec\xa3\xbc\xec\x84\xb8\xec\x9a\x94:\n- \xed\x94\x84\xeb\xa1\x9c\xea\xb7\xb8\xeb\x9e\x98\xeb\xb0\x8d \xec\x96\xb8\xec\x96\xb4\xeb\x8a\x94? (Python, TypeScript, Go \xeb\x93\xb1)\n- \xed\x94\x84\xeb\xa0\x88\xec\x9e\x84\xec\x9b\x8c\xed\x81\xac\xeb\x8a\x94? (FastAPI, Django, React, Next.js \xeb\x93\xb1)\n- \xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xeb\x8f\x84\xea\xb5\xac\xeb\x8a\x94? (pytest, jest, vitest \xeb\x93\xb1)\n- \xeb\xa6\xb0\xed\x84\xb0/\xed\x8f\xac\xeb\xa7\xa4\xed\x84\xb0\xeb\x8a\x94? (ruff, black, eslint, prettier \xeb\x93\xb1)\n- \xeb\xb9\x8c\xeb\x93\x9c/\xeb\xb0\xb0\xed\x8f\xac \xeb\x8f\x84\xea\xb5\xac\xeb\x8a\x94?\n\n### 3. Smart Spec Boundaries (\xea\xb2\xbd\xea\xb3\x84 \xec\x84\xa4\xec\xa0\x95) \xe2\xad\x90\n\n**\xea\xb0\x80\xec\x9e\xa5 \xec\xa4\x91\xec\x9a\x94\xed\x95\xa9\xeb\x8b\x88\xeb\x8b\xa4.** \xeb\x82\x98\xec\x97\x90\xea\xb2\x8c \xeb\x8b\xa4\xec\x9d\x8c\xec\x9d\x84 \xec\xa7\x88\xeb\xac\xb8\xed\x95\xb4\xec\xa3\xbc\xec\x84\xb8\xec\x9a\x94:\n\n#### \xe2\x9c\x85 Always (AI\xea\xb0\x80 \xed\x95\xad\xec\x83\x81 \xed\x95\xb4\xec\x95\xbc \xed\x95\xa0 \xea\xb2\x83)\n- \xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xea\xb4\x80\xeb\xa0\xa8 \xea\xb7\x9c\xec\xb9\x99\xec\x9d\x80?\n- \xec\xbd\x94\xeb\x93\x9c \xed\x92\x88\xec\xa7\x88 \xea\xb4\x80\xeb\xa0\xa8 \xea\xb7\x9c\xec\xb9\x99\xec\x9d\x80?\n- \xeb\xac\xb8\xec\x84\x9c\xed\x99\x94 \xea\xb4\x80\xeb\xa0\xa8 \xea\xb7\x9c\xec\xb9\x99\xec\x9d\x80?\n\n#### \xe2\x9a\xa0\xef\xb8\x8f Ask First (\xec\x82\xac\xec\xa0\x84 \xec\x8a\xb9\xec\x9d\xb8 \xed\x95\x84\xec\x9a\x94)\n- \xec\x96\xb4\xeb\x96\xa4 \xeb\xb3\x80\xea\xb2\xbd\xec\x97\x90 \xeb\x8c\x80\xed\x95\xb4 \xeb\xa8\xbc\xec\xa0\x80 \xeb\xac\xbc\xec\x96\xb4\xeb\xb4\x90\xec\x95\xbc \xed\x95\x98\xeb\x82\x98\xec\x9a\x94?\n- \xec\x9d\x98\xec\xa1\xb4\xec\x84\xb1 \xec\xb6\x94\xea\xb0\x80/\xec\x82\xad\xec\xa0\x9c\xeb\x8a\x94 \xec\x96\xb4\xeb\x96\xbb\xea\xb2\x8c?\n- DB\xeb\x82\x98 API \xeb\xb3\x80\xea\xb2\xbd\xec\x9d\x80?\n\n#### \xf0\x9f\x9a\xab Never (\xec\xa0\x88\xeb\x8c\x80 \xea\xb8\x88\xec\xa7\x80)\n- \xec\x9d\xb4 \xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8\xec\x97\x90\xec\x84\x9c \xec\xa0\x88\xeb\x8c\x80 \xed\x95\x98\xeb\xa9\xb4 \xec\x95\x88 \xeb\x90\x98\xeb\x8a\x94 \xea\xb2\x83\xec\x9d\x80?\n- \xeb\xb3\xb4\xec\x95\x88 \xea\xb4\x80\xeb\xa0\xa8 \xea\xb8\x88\xec\xa7\x80 \xec\x82\xac\xed\x95\xad\xec\x9d\x80?\n- \xeb\x8d\xb0\xec\x9d\xb4\xed\x84\xb0 \xea\xb4\x80\xeb\xa0\xa8 \xea\xb8\x88\xec\xa7\x80 \xec\x82\xac\xed\x95\xad\xec\x9d\x80?\n\n### 4. Project Structure (\xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8 \xea\xb5\xac\xec\xa1\xb0)\n\n\xeb\x82\x98\xec\x97\x90\xea\xb2\x8c \xeb\x8b\xa4\xec\x9d\x8c\xec\x9d\x84 \xec\xa7\x88\xeb\xac\xb8\xed\x95\xb4\xec\xa3\xbc\xec\x84\xb8\xec\x9a\x94:\n- \xec\x86\x8c\xec\x8a\xa4 \xec\xbd\x94\xeb\x93\x9c \xed\x8f\xb4\xeb\x8d\x94 \xea\xb5\xac\xec\xa1\xb0\xeb\x8a\x94?\n- \xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xed\x8f\xb4\xeb\x8d\x94 \xea\xb5\xac\xec\xa1\xb0\xeb\x8a\x94?\n- \xec\x84\xa4\xec\xa0\x95 \xed\x8c\x8c\xec\x9d\xbc\xeb\x93\xa4\xec\x9d\x80 \xec\x96\xb4\xeb\x94\x94\xec\x97\x90?\n\n### 5. Git Workflow (Git \xea\xb7\x9c\xec\xb9\x99)\n\n\xeb\x82\x98\xec\x97\x90\xea\xb2\x8c \xeb\x8b\xa4\xec\x9d\x8c\xec\x9d\x84 \xec\xa7\x88\xeb\xac\xb8\xed\x95\xb4\xec\xa3\xbc\xec\x84\xb8\xec\x9a\x94:\n- \xeb\xb8\x8c\xeb\x9e\x9c\xec\xb9\x98 \xeb\x84\xa4\xec\x9d\xb4\xeb\xb0\x8d \xea\xb7\x9c\xec\xb9\x99\xec\x9d\x80?\n- \xec\xbb\xa4\xeb\xb0\x8b \xeb\xa9\x94\xec\x8b\x9c\xec\xa7\x80 \xed\x98\x95\xec\x8b\x9d\xec\x9d\x80?\n- PR \xea\xb7\x9c\xec\xb9\x99\xec\x9d\x80?\n\n---\n\n## \xf0\x9f\x93\x8b AI\xec\x97\x90\xea\xb2\x8c \xec\xa7\x80\xec\x8b\x9c\n\n\xec\x9c\x84 \xec\x95\x84\xec\xa0\xa0\xeb\x8b\xa4\xec\x97\x90 \xeb\x94\xb0\xeb\x9d\xbc \xeb\x82\x98\xeb\xa5\xbc \xec\x9d\xb8\xed\x84\xb0\xeb\xb7\xb0\xed\x95\x9c \xed\x9b\x84, **\xeb\x8b\xa4\xec\x9d\x8c 2\xea\xb0\x9c \xed\x8c\x8c\xec\x9d\xbc\xec\x9d\x84 \xec\x99\x84\xec\x84\xb1\xeb\x90\x9c \xed\x98\x95\xed\x83\x9c\xeb\xa1\x9c \xec\xb6\x9c\xeb\xa0\xa5**\xed\x95\xb4\xec\xa3\xbc\xec\x84\xb8\xec\x9a\x94:\n\n1. **`01_PROJECT_CONTEXT/00_GOALS.md`**\n   - \xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8 \xec\xa0\x95\xec\xb2\xb4\xec\x84\xb1, \xeb\xaa\xa9\xed\x91\x9c, \xeb\xb2\x94\xec\x9c\x84\n\n2. **`01_PROJECT_CONTEXT/01_CONVENTIONS.md`**\n   - Commands \xed\x85\x8c\xec\x9d\xb4\xeb\xb8\x94 (\xec\x8b\xa4\xec\xa0\x9c \xeb\xaa\x85\xeb\xa0\xb9\xec\x96\xb4\xeb\xa1\x9c \xec\xb1\x84\xec\x9b\x80)\n   - Project Structure (\xec\x8b\xa4\xec\xa0\x9c \xea\xb5\xac\xec\xa1\xb0\xeb\xa1\x9c \xec\xb1\x84\xec\x9b\x80)\n   - Code Style (\xec\x8b\xa4\xec\xa0\x9c \xeb\x8f\x84\xea\xb5\xac\xec\x99\x80 \xea\xb7\x9c\xec\xb9\x99\xec\x9c\xbc\xeb\xa1\x9c \xec\xb1\x84\xec\x9b\x80)\n   - Testing Strategy (\xec\x8b\xa4\xec\xa0\x9c \xec\xa0\x84\xeb\x9e\xb5\xec\x9c\xbc\xeb\xa1\x9c \xec\xb1\x84\xec\x9b\x80)\n   - Git Workflow (\xec\x8b\xa4\xec\xa0\x9c \xea\xb7\x9c\xec\xb9\x99\xec\x9c\xbc\xeb\xa1\x9c \xec\xb1\x84\xec\x9b\x80)\n   - **Boundaries** (\xec\x9d\xb8\xed\x84\xb0\xeb\xb7\xb0 \xea\xb2\xb0\xea\xb3\xbc\xeb\xa1\x9c \xec\xb1\x84\xec\x9b\x80) \xe2\xad\x90\n\n---\n\n## \xe2\x9a\xa0\xef\xb8\x8f \xec\xa3\xbc\xec\x9d\x98\xec\x82\xac\xed\x95\xad\n\n- \xea\xb8\xb0\xeb\xb3\xb8 \xed\x85\x9c\xed\x94\x8c\xeb\xa6\xbf\xec\x9d\x98 \xec\x98\x88\xec\x8b\x9c\xea\xb0\x80 \xec\x95\x84\xeb\x8b\x8c, **\xec\x8b\xa4\xec\xa0\x9c \xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8\xec\x97\x90 \xeb\xa7\x9e\xeb\x8a\x94 \xeb\x82\xb4\xec\x9a\xa9**\xec\x9c\xbc\xeb\xa1\x9c \xec\xb1\x84\xec\x9b\x8c\xec\xa3\xbc\xec\x84\xb8\xec\x9a\x94.\n- Boundaries\xeb\x8a\x94 \xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8 \xed\x8a\xb9\xec\x84\xb1\xec\x97\x90 \xeb\xa7\x9e\xea\xb2\x8c \xea\xb5\xac\xec\xb2\xb4\xec\xa0\x81\xec\x9c\xbc\xeb\xa1\x9c \xec\x9e\x91\xec\x84\xb1\xed\x95\xb4\xec\xa3\xbc\xec\x84\xb8\xec\x9a\x94.\n- \xeb\xb6\x88\xed\x99\x95\xec\x8b\xa4\xed\x95\x9c \xeb\xb6\x80\xeb\xb6\x84\xec\x9d\x80 `[TODO: \xed\x99\x95\xec\xa0\x95 \xed\x95\x84\xec\x9a\x94]`\xeb\xa1\x9c \xed\x91\x9c\xec\x8b\x9c\xed\x95\xb4\xec\xa3\xbc\xec\x84\xb8\xec\x9a\x94.\n\n---\n\n## \xec\x99\x84\xeb\xa3\x8c \xed\x9b\x84\n\n1. AI\xea\xb0\x80 \xec\xb6\x9c\xeb\xa0\xa5\xed\x95\x9c \xeb\x82\xb4\xec\x9a\xa9\xec\x9d\x84 \xea\xb0\x81 \xed\x8c\x8c\xec\x9d\xbc\xec\x97\x90 \xec\xa0\x80\xec\x9e\xa5\n2. `python memory_manager.py --doctor` \xec\x8b\xa4\xed\x96\x89\xed\x95\x98\xec\x97\xac \xea\xb2\x80\xec\xa6\x9d\n3. \xec\x9d\xb4 \xed\x8c\x8c\xec\x9d\xbc(`BOOTSTRAP_PROMPT.md`)\xec\x9d\x80 \xec\x82\xad\xec\xa0\x9c\xed\x95\x98\xea\xb1\xb0\xeb\x82\x98 `99_ARCHIVE/`\xeb\xa1\x9c \xec\x9d\xb4\xeb\x8f\x99\n"""\n\nBOOTSTRAP_CONVENTIONS_TEMPLATE = f"""# Coding Conventions & Rules (Smart Spec)\n\n> **ID**: CTX-CONV-001\n> **Last Updated**: [TODO: AI\xec\x99\x80 \xed\x86\xa0\xec\x9d\x98\xed\x95\x98\xec\x97\xac \xea\xb2\xb0\xec\xa0\x95]\n> **Template-Version**: {TEMPLATE_VERSION}\n\n---\n\n## 1. Commands (\xec\x8b\xa4\xed\x96\x89 \xeb\xaa\x85\xeb\xa0\xb9\xec\x96\xb4)\n\n> [TODO: AI\xec\x99\x80 \xed\x86\xa0\xec\x9d\x98\xed\x95\x98\xec\x97\xac \xea\xb2\xb0\xec\xa0\x95]\n\n| Action | Command | Description |\n|--------|---------|-------------|\n| **Test** | `[TODO]` | Run all unit tests |\n| **Test (specific)** | `[TODO]` | Run specific test file |\n| **Lint** | `[TODO]` | Check code style |\n| **Format** | `[TODO]` | Auto-format code |\n| **Run** | `[TODO]` | Run the application |\n| **Build** | `[TODO]` | Build for production |\n\n---\n\n## 2. Project Structure (\xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8 \xea\xb5\xac\xec\xa1\xb0)\n\n> [TODO: AI\xec\x99\x80 \xed\x86\xa0\xec\x9d\x98\xed\x95\x98\xec\x97\xac \xea\xb2\xb0\xec\xa0\x95]\n\n```\nproject_root/\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 [TODO]/              # \xec\x86\x8c\xec\x8a\xa4 \xec\xbd\x94\xeb\x93\x9c\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 [TODO]/              # \xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xec\xbd\x94\xeb\x93\x9c\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 .memory/             # \xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8 \xeb\xac\xb8\xec\x84\x9c (MemoryAtlas)\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 [TODO]               # \xea\xb8\xb0\xed\x83\x80 \xed\x8c\x8c\xec\x9d\xbc\xeb\x93\xa4\n```\n\n---\n\n## 3. Code Style (\xec\xbd\x94\xeb\x93\x9c \xec\x8a\xa4\xed\x83\x80\xec\x9d\xbc)\n\n> [TODO: AI\xec\x99\x80 \xed\x86\xa0\xec\x9d\x98\xed\x95\x98\xec\x97\xac \xea\xb2\xb0\xec\xa0\x95]\n\n### [Language]\n- **Formatter**: `[TODO]`\n- **Linter**: `[TODO]`\n- **Type Hints**: [TODO]\n- **Docstrings**: [TODO]\n\n### Naming Conventions\n| Type | Style | Example |\n|------|-------|---------|\n| Variables/Functions | `[TODO]` | |\n| Classes | `[TODO]` | |\n| Constants | `[TODO]` | |\n| Files | `[TODO]` | |\n\n---\n\n## 4. Testing Strategy (\xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xec\xa0\x84\xeb\x9e\xb5)\n\n> [TODO: AI\xec\x99\x80 \xed\x86\xa0\xec\x9d\x98\xed\x95\x98\xec\x97\xac \xea\xb2\xb0\xec\xa0\x95]\n\n### Requirements\n- [TODO]\n\n### Coverage\n- \xeb\xaa\xa9\xed\x91\x9c: [TODO]\n\n---\n\n## 5. Git Workflow (Git \xea\xb7\x9c\xec\xb9\x99)\n\n> [TODO: AI\xec\x99\x80 \xed\x86\xa0\xec\x9d\x98\xed\x95\x98\xec\x97\xac \xea\xb2\xb0\xec\xa0\x95]\n\n### Branch Naming\n- Feature: `[TODO]`\n- Bugfix: `[TODO]`\n\n### Commit Messages\n- Format: `[TODO]`\n\n---\n\n## 6. Smart Spec Boundaries (STRICT)\n\n### \xe2\x9c\x85 Always (\xed\x95\xad\xec\x83\x81 \xec\x88\x98\xed\x96\x89)\n- `RUN` \xeb\xac\xb8\xec\x84\x9c \xec\x9e\x91\xec\x84\xb1 \xec\x8b\x9c `Verification` \xec\x84\xb9\xec\x85\x98\xec\x97\x90 \xea\xb5\xac\xec\xb2\xb4\xec\xa0\x81\xec\x9d\xb8 **\xea\xb2\x80\xec\xa6\x9d \xeb\xaa\x85\xeb\xa0\xb9\xec\x96\xb4**\xeb\xa5\xbc \xed\x8f\xac\xed\x95\xa8\xed\x95\xa0 \xea\xb2\x83. (\xec\x98\x88: `pytest tests/auth/`)\n- \xeb\xaa\xa8\xeb\x93\xa0 \xed\x8d\xbc\xeb\xb8\x94\xeb\xa6\xad API/\xed\x95\xa8\xec\x88\x98\xec\x97\x90\xeb\x8a\x94 **Docstring**\xea\xb3\xbc **Type Hint**\xeb\xa5\xbc \xed\x8f\xac\xed\x95\xa8\xed\x95\xa0 \xea\xb2\x83.\n\n### \xf0\x9f\x99\x8b Ask First (\xeb\xac\xbc\xec\x96\xb4\xeb\xb3\xbc \xea\xb2\x83)\n- `requirements.txt`, `package.json` \xeb\x93\xb1 **\xec\x9d\x98\xec\xa1\xb4\xec\x84\xb1 \xec\xb6\x94\xea\xb0\x80/\xeb\xb3\x80\xea\xb2\xbd**.\n- **DB \xec\x8a\xa4\xed\x82\xa4\xeb\xa7\x88 \xeb\xb3\x80\xea\xb2\xbd** (`migration` \xed\x8c\x8c\xec\x9d\xbc \xec\x83\x9d\xec\x84\xb1).\n- \xea\xb8\xb0\xec\xa1\xb4 `01_CONVENTIONS`\xeb\x82\x98 \xec\x8b\x9c\xec\x8a\xa4\xed\x85\x9c \xed\x85\x9c\xed\x94\x8c\xeb\xa6\xbf \xec\x88\x98\xec\xa0\x95.\n\n### \xf0\x9f\x9a\xab Never (\xec\xa0\x88\xeb\x8c\x80 \xea\xb8\x88\xec\xa7\x80)\n- **Secret Key**, Password, API Key\xeb\xa5\xbc \xec\xbd\x94\xeb\x93\x9c\xeb\x82\x98 \xeb\xac\xb8\xec\x84\x9c\xec\x97\x90 \xed\x95\x98\xeb\x93\x9c\xec\xbd\x94\xeb\x94\xa9.\n- **Mock Data**\xeb\xa5\xbc \xed\x94\x84\xeb\xa1\x9c\xeb\x8d\x95\xec\x85\x98 \xec\xbd\x94\xeb\x93\x9c\xec\x97\x90 \xeb\x82\xa8\xea\xb8\xb0\xeb\x8a\x94 \xed\x96\x89\xec\x9c\x84.\n- `REQ` \xeb\xac\xb8\xec\x84\x9c\xec\x9d\x98 **Decision** \xec\x84\xb9\xec\x85\x98\xec\x9d\x84 \xec\x88\x98\xec\xa0\x95\xed\x95\x98\xec\xa7\x80 \xec\x95\x8a\xea\xb3\xa0 \xed\x95\x98\xeb\x8b\xa8\xec\x97\x90 "\xec\xb6\x94\xea\xb0\x80 \xec\x82\xac\xed\x95\xad"\xec\x9c\xbc\xeb\xa1\x9c \xeb\x8d\xa7\xeb\xb6\x99\xec\x9d\xb4\xeb\x8a\x94 \xed\x96\x89\xec\x9c\x84.\n\n---\n\n## 7. Documentation Maintenance Policy\n1. **SSOT (Single Source of Truth)**: `REQ` \xeb\xac\xb8\xec\x84\x9c\xeb\x8a\x94 \xed\x95\xad\xec\x83\x81 **\xed\x98\x84\xec\x9e\xac \xec\x8b\x9c\xec\xa0\x90\xec\x9d\x98 \xec\xb5\x9c\xec\xa2\x85 \xeb\xaa\x85\xec\x84\xb8**\xec\x97\xac\xec\x95\xbc \xed\x95\x9c\xeb\x8b\xa4.\n2. **Rewrite, Don\'t Append**: \xec\x9a\x94\xea\xb5\xac\xec\x82\xac\xed\x95\xad\xec\x9d\xb4 \xeb\xb3\x80\xea\xb2\xbd\xeb\x90\x98\xeb\xa9\xb4 \xea\xb8\xb0\xec\xa1\xb4 \xed\x85\x8d\xec\x8a\xa4\xed\x8a\xb8\xeb\xa5\xbc \xec\x88\x98\xec\xa0\x95(Refactor)\xed\x95\x98\xeb\x9d\xbc. \xeb\xb0\x91\xec\x97\x90 "Update 1..." \xec\x8b\x9d\xec\x9c\xbc\xeb\xa1\x9c \xeb\x8d\xa7\xeb\xb6\x99\xec\x9d\xb4\xec\xa7\x80 \xeb\xa7\x88\xeb\x9d\xbc.\n3. **Change Log**: \xeb\xb3\x80\xea\xb2\xbd \xec\x9d\xb4\xeb\xa0\xa5\xec\x9d\x80 \xeb\xac\xb8\xec\x84\x9c \xec\xb5\x9c\xec\x83\x81\xeb\x8b\xa8\xec\x9d\x98 `Change Log` \xed\x85\x8c\xec\x9d\xb4\xeb\xb8\x94\xec\x97\x90\xeb\xa7\x8c \xea\xb8\xb0\xeb\xa1\x9d\xed\x95\x98\xeb\x9d\xbc.\n\n---\n\n## 8. AI Agent Quick Reference\n\n### Reading Priority (P0 = Must Read)\n1. **P0**: \xec\x9d\xb4 \xed\x8c\x8c\xec\x9d\xbc (`01_CONVENTIONS.md`)\n2. **P0**: Target REQ\xec\x9d\x98 `**Must-Read**` \xed\x95\x84\xeb\x93\x9c\n3. **P1**: `02_REQUIREMENTS/invariants/` (\xec\xa0\x84\xec\xb2\xb4)\n4. **P1.5**: `02_REQUIREMENTS/competencies/` (\xec\xb0\xb8\xec\xa1\xb0\xeb\x90\x9c CQ\xeb\xa7\x8c)\n5. **P2**: `98_KNOWLEDGE/` (\xeb\xb3\xb5\xec\x9e\xa1\xed\x95\x9c \xea\xb8\xb0\xeb\x8a\xa5 \xec\x8b\x9c)\n\n### Execution Checklist\n1. [ ] CONVENTIONS\xec\x9d\x98 Boundaries \xed\x99\x95\xec\x9d\xb8\n2. [ ] Target REQ \xec\x9d\xbd\xea\xb8\xb0\n3. [ ] Must-Read \xeb\xac\xb8\xec\x84\x9c \xec\x9d\xbd\xea\xb8\xb0\n4. [ ] RUN \xeb\xac\xb8\xec\x84\x9c \xec\x9e\x91\xec\x84\xb1 (Self-Check \xed\x8f\xac\xed\x95\xa8)\n5. [ ] \xea\xb5\xac\xed\x98\x84 \xe2\x86\x92 \xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xe2\x86\x92 \xea\xb2\x80\xec\xa6\x9d\n6. [ ] RUN \xeb\xac\xb8\xec\x84\x9c \xec\x99\x84\xeb\xa3\x8c \xec\xb2\x98\xeb\xa6\xac\n"""\n\nBOOTSTRAP_GOALS_TEMPLATE = f"""# Project Goals\n\n> **ID**: CTX-GOALS-001\n> **Last Updated**: [TODO: AI\xec\x99\x80 \xed\x86\xa0\xec\x9d\x98\xed\x95\x98\xec\x97\xac \xea\xb2\xb0\xec\xa0\x95]\n> **Template-Version**: {TEMPLATE_VERSION}\n\n---\n\n## 1. Project Identity\n\n### Name\n[TODO: AI\xec\x99\x80 \xed\x86\xa0\xec\x9d\x98\xed\x95\x98\xec\x97\xac \xea\xb2\xb0\xec\xa0\x95]\n\n### One-Line Summary\n[TODO: AI\xec\x99\x80 \xed\x86\xa0\xec\x9d\x98\xed\x95\x98\xec\x97\xac \xea\xb2\xb0\xec\xa0\x95]\n\n### Core Value\n[TODO: AI\xec\x99\x80 \xed\x86\xa0\xec\x9d\x98\xed\x95\x98\xec\x97\xac \xea\xb2\xb0\xec\xa0\x95]\n\n---\n\n## 2. Target Users\n\n- **Primary**: [TODO: AI\xec\x99\x80 \xed\x86\xa0\xec\x9d\x98\xed\x95\x98\xec\x97\xac \xea\xb2\xb0\xec\xa0\x95]\n- **Secondary**: [TODO: AI\xec\x99\x80 \xed\x86\xa0\xec\x9d\x98\xed\x95\x98\xec\x97\xac \xea\xb2\xb0\xec\xa0\x95]\n\n---\n\n## 3. Success Criteria\n\n- [ ] [TODO: AI\xec\x99\x80 \xed\x86\xa0\xec\x9d\x98\xed\x95\x98\xec\x97\xac \xea\xb2\xb0\xec\xa0\x95]\n\n---\n\n## 4. Scope\n\n### In-Scope\n- [TODO: AI\xec\x99\x80 \xed\x86\xa0\xec\x9d\x98\xed\x95\x98\xec\x97\xac \xea\xb2\xb0\xec\xa0\x95]\n\n### Out-of-Scope\n- [TODO: AI\xec\x99\x80 \xed\x86\xa0\xec\x9d\x98\xed\x95\x98\xec\x97\xac \xea\xb2\xb0\xec\xa0\x95]\n\n---\n\n## 5. Milestones\n\n| Phase | Description | Target Date | Status |\n|-------|-------------|-------------|--------|\n| Phase 1 | [TODO] | [TODO] | Not Started |\n"""\n\nBOOTSTRAP_TEMPLATES = {\n    "BOOTSTRAP_PROMPT.md": BOOTSTRAP_PROMPT_TEMPLATE,\n}\n\n# ============================================================================\n# MCP DEFINITIONS (SYSTEM-GENERATED)\n# ============================================================================\nMCP_DEFINITIONS = {\n    "apply_req": {\n        "signature": "apply_req(req_id, dry_run=false, create_spec=\\"auto\\")",\n        "summary": "Orchestrate the REQ -> RUN pipeline with validation gates.",\n        "inputs": [\n            "`req_id` (str): Target REQ ID.",\n            "`dry_run` (bool): Preview only.",\n            "`create_spec` (bool | \\"auto\\"): Create spec draft when true or auto-triggered.",\n        ],\n        "outputs": [\n            "RUN document created/updated in `04_TASK_LOGS/active/`.",\n            "DISC draft path on failure.",\n            "Stage/result report.",\n        ],\n        "behavior": [\n            "Requires REQ `Status=Active`.",\n            "Runs `validate(lint)`, `validate(req)`, `validate(links)` gates.",\n            "Creates 03 specs when `create_spec` is true or auto-triggered.",\n            "Does not edit code by default.",\n        ],\n    },\n    "apply_req_full": {\n        "signature": "apply_req_full(req_id, dry_run=false)",\n        "summary": "One-shot orchestration that drives the state machine and returns follow-up hints.",\n        "inputs": [\n            "`req_id` (str): Target REQ ID.",\n            "`dry_run` (bool): Preview only.",\n        ],\n        "outputs": [\n            "State-aware report (`state`, `run_id`, `next_action`).",\n            "`instructions` plus `continue_with` / `continue_args` for client-driven steps.",\n            "DISC draft path on failure.",\n        ],\n        "behavior": [\n            "Runs lint/req/links validation on the first pass.",\n            "Creates RUN when validation passes.",\n            "Returns implementation instructions; code edits are performed by the client/agent.",\n            "Runs `--doctor` and finalizes when state is ready.",\n        ],\n    },\n    "continue_req": {\n        "signature": "continue_req(req_id, implementation_done=false)",\n        "summary": "Advance the REQ state machine after implementation or verification.",\n        "inputs": [\n            "`req_id` (str): Target REQ ID.",\n            "`implementation_done` (bool): Set true when implementation is complete.",\n        ],\n        "outputs": [\n            "State-aware report with next action and any validation errors.",\n        ],\n        "behavior": [\n            "Transitions RUN_CREATED \xe2\x86\x92 IMPLEMENTING.",\n            "Transitions IMPLEMENTING \xe2\x86\x92 VERIFYING/READY_TO_FINALIZE based on checks.",\n            "Re-runs validation gates when requested.",\n        ],\n    },\n    "validate": {\n        "signature": "validate(scope)",\n        "summary": "Run a single validation check and return issue count.",\n        "inputs": [\n            "`scope` (str): lint | req | links | doctor.",\n        ],\n        "outputs": [\n            "Issue count and console report.",\n        ],\n        "behavior": [\n            "Uses the same checks as `memory_manager.py`.",\n        ],\n    },\n    "create_run": {\n        "signature": "create_run(req_id)",\n        "summary": "Create a RUN document from template for a REQ.",\n        "inputs": [\n            "`req_id` (str): Target REQ ID.",\n        ],\n        "outputs": [\n            "RUN document created in `04_TASK_LOGS/active/`.",\n        ],\n        "behavior": [\n            "Includes Objective/Scope/Plan, Design Summary, Validation Gates, Exit Criteria.",\n            "Keeps required RUN metadata fields.",\n        ],\n    },\n    "finish": {\n        "signature": "finish(run_id, success=True, git_hash=\'\')",\n        "summary": "Mark a RUN as completed with Git evidence.",\n        "inputs": [\n            "`run_id` (str): RUN ID.",\n            "`success` (bool): Whether the run succeeded.",\n            "`git_hash` (str): Git commit hash as evidence.",\n        ],\n        "outputs": [\n            "RUN updated in `04_TASK_LOGS/active/` (no archive move).",\n        ],\n        "behavior": [\n            "Updates Status to Completed/Failed.",\n            "Records Git hash as evidence.",\n            "RUN stays in active/ (v3.4+ policy).",\n        ],\n    },\n    "finalize_run": {\n        "signature": "finalize_run(run_id, success=True, git_hash=\'\')",\n        "summary": "(Alias) See finish().",\n        "inputs": ["`run_id` (str)", "`success` (bool)", "`git_hash` (str)"],\n        "outputs": ["Same as finish()."],\n        "behavior": ["Alias for finish() - kept for backward compatibility."],\n    },\n    "create_disc_from_failure": {\n        "signature": "create_disc_from_failure(context)",\n        "summary": "Generate a DISC draft for a failed stage.",\n        "inputs": [\n            "`context` (dict): stage, errors, files, rules, logs, req_id/target_id.",\n        ],\n        "outputs": [\n            "DISC draft created in `02_REQUIREMENTS/discussions/`.",\n        ],\n        "behavior": [\n            "Includes summary, evidence, hypotheses, fix options, next steps.",\n            "One DISC per failure event.",\n        ],\n    },\n    "intake": {\n        "signature": "intake(description, domain=\'GEN\')",\n        "summary": "Intake a new user request and create a BRIEF document.",\n        "inputs": [\n            "`description` (str): User request logic/features.",\n            "`domain` (str): Domain code (default \'GEN\')."\n        ],\n        "outputs": [\n            "BRIEF document path (key: `brief_path`)."\n        ],\n        "behavior": [\n            "Creates a new BRIEF in active logs.",\n            "Use this to start a new feature or task."\n        ],\n    },\n    "plan": {\n        "signature": "plan(brief_id)",\n        "summary": "Create a RUN document from an existing BRIEF.",\n        "inputs": [\n            "`brief_id` (str): Target Brief ID."\n        ],\n        "outputs": [\n            "RUN ID (key: `run_id`).",\n            "RUN document path (key: `run_path`)."\n        ],\n        "behavior": [\n            "Creates a RUN document linked to the Brief.",\n            "Auto-creates/updates REQ documents.",\n            "Moves workflow from Intake to Execution."\n        ],\n    },\n    "plan_from_brief": {\n        "signature": "plan_from_brief(brief_id)",\n        "summary": "(Alias) See plan().",\n        "inputs": ["`brief_id` (str)"],\n        "outputs": ["Same as plan()."],\n        "behavior": ["Alias for plan() - kept for backward compatibility."],\n    },\n    "apply_req": {\n        "signature": "apply_req(req_id, dry_run=False) (Deprecated)",\n        "summary": "(Deprecated) Use plan() instead.",\n        "inputs": ["`req_id` (str)", "`dry_run` (bool)"],\n        "outputs": ["Report dict"],\n        "behavior": ["Triggers deprecation warning."],\n    },\n    "apply_req_full": {\n        "signature": "apply_req_full(req_id) (Deprecated)",\n        "summary": "(Deprecated) One-shot orchestration.",\n        "inputs": ["`req_id` (str)"],\n        "outputs": ["State dict"],\n        "behavior": ["See plan()."],\n    },\n    "req_status": {\n        "signature": "req_status(req_id)",\n        "summary": "Inspect REQ readiness without executing pipeline.",\n        "inputs": [\n            "`req_id` (str): Target REQ ID.",\n        ],\n        "outputs": [\n            "`status`: metadata status value.",\n            "`metadata`: parsed REQ metadata.",\n            "`readiness`: true/false.",\n            "`blocking_issues`: list of reasons.",\n        ],\n        "behavior": [\n            "Does not write any files.",\n            "Useful for preflight checks in UIs.",\n        ],\n    },\n    "run_report": {\n        "signature": "run_report(run_id)",\n        "summary": "Return a structured summary of a RUN document.",\n        "inputs": [\n            "`run_id` (str): RUN ID.",\n        ],\n        "outputs": [\n            "`objective`, `scope`, `status`, `validation_state`, `artifacts`.",\n        ],\n        "behavior": [\n            "Read-only; does not move or update RUN files.",\n        ],\n    },\n}\n\n# ============================================================================\n# SYSTEM TEMPLATES\n# ============================================================================\nAGENT_RULES_TEMPLATE = f"""# MemoryAtlas Agent Rules (v{CURRENT_VERSION}) - Smart Spec Edition\n\n> **SYSTEM FILE**: Managed by `memory_manager.py`. DO NOT EDIT.\n> **For custom rules**: Use `01_PROJECT_CONTEXT/01_CONVENTIONS.md`.\n\n---\n\n## 1. Smart Spec Model\n\n```\n6 Core Sections in CONVENTIONS:\n  1. Commands: Test, Lint, Run \xeb\xaa\x85\xeb\xa0\xb9\xec\x96\xb4\n  2. Project Structure: \xeb\x94\x94\xeb\xa0\x89\xed\x86\xa0\xeb\xa6\xac \xea\xb5\xac\xec\xa1\xb0\n  3. Code Style: \xed\x8f\xac\xeb\xa7\xb7\xed\x8c\x85, \xeb\x84\xa4\xec\x9d\xb4\xeb\xb0\x8d \xea\xb7\x9c\xec\xb9\x99\n  4. Testing Strategy: \xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xec\x9a\x94\xea\xb5\xac\xec\x82\xac\xed\x95\xad\n  5. Git Workflow: \xeb\xb8\x8c\xeb\x9e\x9c\xec\xb9\x98/\xec\xbb\xa4\xeb\xb0\x8b \xea\xb7\x9c\xec\xb9\x99\n  6. Boundaries: Always / Ask First / Never \xea\xb7\x9c\xec\xb9\x99\n\nBoundaries (STRICT):\n  \xe2\x9c\x85 Always: AI\xea\xb0\x80 \xed\x95\xad\xec\x83\x81 \xec\x88\x98\xed\x96\x89\xed\x95\xb4\xec\x95\xbc \xed\x95\x98\xeb\x8a\x94 \xed\x96\x89\xeb\x8f\x99\n  \xe2\x9a\xa0\xef\xb8\x8f Ask First: \xec\x82\xac\xeb\x9e\x8c \xec\x8a\xb9\xec\x9d\xb8 \xed\x9b\x84 \xec\xa7\x84\xed\x96\x89\n  \xf0\x9f\x9a\xab Never: AI\xea\xb0\x80 \xec\xa0\x88\xeb\x8c\x80 \xec\x88\x98\xed\x96\x89\xed\x95\x98\xeb\xa9\xb4 \xec\x95\x88 \xeb\x90\x98\xeb\x8a\x94 \xed\x96\x89\xeb\x8f\x99\n```\n\n---\n\n## 2. Authority Model\n\n```\n\xea\xb6\x8c\xec\x9c\x84\xec\x9d\x98 \xed\x9d\x90\xeb\xa6\x84 (Authority Flow):\n  REQ (Authority) \xe2\x86\x92 TECH_SPEC \xe2\x86\x92 CODE \xe2\x86\x92 RUN/LOG\n\n\xeb\xac\xb8\xec\x84\x9c \xeb\x93\xb1\xea\xb8\x89:\n  - DECISION: \xec\xb5\x9c\xec\xa2\x85 \xea\xb2\xb0\xec\xa0\x95 (REQ-*, RULE-*) - MUST READ\n  - DISCUSSION: \xec\xa1\xb0\xec\x9c\xa8 \xea\xb8\xb0\xeb\xa1\x9d (DISC-*) - DEFAULT SKIP\n  - RATIONALE: \xea\xb2\xb0\xec\xa0\x95 \xea\xb7\xbc\xea\xb1\xb0 (ADR-*) - READ IF REFERENCED\n  - EXECUTION: \xec\x9e\x91\xec\x97\x85 \xeb\x8b\xa8\xec\x9c\x84 (RUN-*) - CREATE/UPDATE\n```\n\n---\n\n## 3. Reading Priority\n\n### P0 (Always Read)\n1. `01_PROJECT_CONTEXT/01_CONVENTIONS.md` - **\xed\x8a\xb9\xed\x9e\x88 Boundaries \xec\x84\xb9\xec\x85\x98**\n2. Target REQ\'s `**Must-Read**` field\n3. All referenced RULE-* documents\n\n### P1 (Read for Context)\n- `02_REQUIREMENTS/invariants/` (all active)\n- `02_REQUIREMENTS/competencies/` (referenced CQs only)\n- Referenced ADR-* documents\n\n### Default Skip\n- `02_REQUIREMENTS/discussions/` - Only when explicitly referenced\n- `04_TASK_LOGS/archive/` - Only for historical context\n- `99_ARCHIVE/` - Deprecated content\n\n---\n\n## 4. Boundaries Compliance (STRICT)\n\n### \xe2\x9c\x85 Always (\xed\x95\xad\xec\x83\x81 \xec\x88\x98\xed\x96\x89)\n- RUN \xeb\xac\xb8\xec\x84\x9c \xec\xa2\x85\xeb\xa3\x8c \xec\xa0\x84 **\xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xed\x86\xb5\xea\xb3\xbc** \xed\x99\x95\xec\x9d\xb8\n- \xeb\xaa\xa8\xeb\x93\xa0 \xed\x8d\xbc\xeb\xb8\x94\xeb\xa6\xad \xed\x95\xa8\xec\x88\x98\xec\x97\x90 **Type Hint** \xec\xb6\x94\xea\xb0\x80\n- \xea\xb8\xb0\xec\xa1\xb4 \xec\xbd\x94\xeb\x93\x9c \xec\x88\x98\xec\xa0\x95 \xec\x8b\x9c **\xea\xb8\xb0\xec\xa1\xb4 \xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xed\x86\xb5\xea\xb3\xbc** \xed\x99\x95\xec\x9d\xb8\n- \xec\x83\x88 \xea\xb8\xb0\xeb\x8a\xa5 \xec\xb6\x94\xea\xb0\x80 \xec\x8b\x9c **REQ \xeb\xac\xb8\xec\x84\x9c \xec\xb0\xb8\xec\xa1\xb0** \xed\x99\x95\xec\x9d\xb8\n\n### \xe2\x9a\xa0\xef\xb8\x8f Ask First (\xec\x82\xac\xec\xa0\x84 \xec\x8a\xb9\xec\x9d\xb8 \xed\x95\x84\xec\x9a\x94)\n- `requirements.txt` \xeb\x93\xb1 **\xec\x9d\x98\xec\xa1\xb4\xec\x84\xb1 \xec\xb6\x94\xea\xb0\x80/\xec\x82\xad\xec\xa0\x9c**\n- `.memory/00_SYSTEM/` \xeb\x82\xb4\xeb\xb6\x80 \xed\x8c\x8c\xec\x9d\xbc \xec\x88\x98\xec\xa0\x95\n- **DB \xec\x8a\xa4\xed\x82\xa4\xeb\xa7\x88 \xeb\xb3\x80\xea\xb2\xbd** (migration \xeb\x93\xb1)\n- **API \xec\x97\x94\xeb\x93\x9c\xed\x8f\xac\xec\x9d\xb8\xed\x8a\xb8 \xec\x82\xad\xec\xa0\x9c/\xeb\xb3\x80\xea\xb2\xbd**\n- \xec\x84\xa4\xec\xa0\x95 \xed\x8c\x8c\xec\x9d\xbc \xea\xb5\xac\xec\xa1\xb0 \xeb\xb3\x80\xea\xb2\xbd\n\n### \xf0\x9f\x9a\xab Never (\xec\xa0\x88\xeb\x8c\x80 \xea\xb8\x88\xec\xa7\x80)\n- **Secret \xec\xbb\xa4\xeb\xb0\x8b \xea\xb8\x88\xec\xa7\x80**: API Key, Password, Token \xeb\x93\xb1\n- **\xed\x95\x98\xeb\x93\x9c\xec\xbd\x94\xeb\x94\xa9 \xea\xb8\x88\xec\xa7\x80**: \xed\x94\x84\xeb\xa1\x9c\xeb\x8d\x95\xec\x85\x98 \xeb\x8d\xb0\xec\x9d\xb4\xed\x84\xb0, mock \xeb\x8d\xb0\xec\x9d\xb4\xed\x84\xb0\n- **\xeb\xac\xbc\xeb\xa6\xac\xec\xa0\x81 \xec\x82\xad\xec\xa0\x9c \xea\xb8\x88\xec\xa7\x80**: Soft Delete \xec\x82\xac\xec\x9a\xa9\n- **Force Push \xea\xb8\x88\xec\xa7\x80**: main/master \xeb\xb8\x8c\xeb\x9e\x9c\xec\xb9\x98\n- **\xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xec\x8a\xa4\xed\x82\xb5 \xea\xb8\x88\xec\xa7\x80**: @skip\xec\x9c\xbc\xeb\xa1\x9c \xeb\xac\xb4\xec\x8b\x9c\xed\x95\x98\xec\xa7\x80 \xec\x95\x8a\xec\x9d\x8c\n\n---\n\n## 5. Writing Rules\n\n### REQ/RULE Documents (Authority)\n- **\xea\xb2\xb0\xec\xa0\x95\xeb\xa7\x8c \xec\xa0\x81\xeb\x8a\x94\xeb\x8b\xa4**: \xeb\x85\xbc\xec\x9d\x98/\xeb\x8c\x80\xec\x95\x88\xec\x9d\x80 discussions/\xec\x97\x90\n- **\xec\xa7\xa7\xea\xb2\x8c \xec\x9c\xa0\xec\xa7\x80**: \xed\x95\x9c REQ = \xed\x95\x98\xeb\x82\x98\xec\x9d\x98 \xeb\xaa\x85\xed\x99\x95\xed\x95\x9c \xea\xb2\xb0\xec\xa0\x95\n- **Must-Read \xed\x95\x84\xec\x88\x98**: RULE/ADR ID\xeb\xa7\x8c, \xeb\xa7\x81\xed\x81\xac \xed\x85\x8d\xec\x8a\xa4\xed\x8a\xb8\xeb\x8a\x94 ID\n- **Constraints \xec\x84\xa0\xed\x83\x9d\xec\xa0\x81**: \xea\xb8\xb0\xeb\x8a\xa5\xeb\xb3\x84 \xec\xb6\x94\xea\xb0\x80 \xec\xa0\x9c\xec\x95\xbd \xec\x8b\x9c\xeb\xa7\x8c \xec\x9e\x91\xec\x84\xb1\n\n### RUN Documents (Execution)\n- **1 RUN = 1 \xeb\xaa\xa9\xec\xa0\x81**: \xec\x97\xac\xeb\x9f\xac \xeb\xaa\xa9\xec\xa0\x81\xec\x9d\x84 \xec\x84\x9e\xec\xa7\x80 \xec\x95\x8a\xec\x9d\x8c\n- **Input \xeb\xaa\x85\xec\x8b\x9c**: \xec\x9d\xbd\xec\x96\xb4\xec\x95\xbc \xed\x95\xa0 \xeb\xac\xb8\xec\x84\x9c ID \xeb\xaa\xa9\xeb\xa1\x9d\n- **Verification \xeb\xaa\x85\xec\x8b\x9c**: \xec\x84\xb1\xea\xb3\xb5 \xec\xa1\xb0\xea\xb1\xb4 + Self-Check\n- **Output \xea\xb8\xb0\xeb\xa1\x9d**: \xec\x83\x9d\xec\x84\xb1/\xec\x88\x98\xec\xa0\x95 \xed\x8c\x8c\xec\x9d\xbc \xeb\xaa\xa9\xeb\xa1\x9d\n\n---\n\n## 6. Validation Requirements\n\n### Three-Way ID Consistency\n- `**ID**:` metadata (Authority)\n- Filename\n- Header `[ID]`\n\nAll three must match.\n\n### Must-Read Validation\n- Must-Read allows only RULE/ADR IDs (CTX is P0 and excluded)\n- Link text must be the ID if markdown links are used\n- All documents in `**Must-Read**` must exist\n\n---\n\n## 7. 3-Step Workflow (Intake \xe2\x86\x92 Plan \xe2\x86\x92 Finish)\n\n### MCP \xeb\x8f\x84\xea\xb5\xac (\xed\x95\xb5\xec\x8b\xac)\n\n| \xed\x8a\xb8\xeb\xa6\xac\xea\xb1\xb0 | MCP \xeb\x8f\x84\xea\xb5\xac | \xea\xb2\xb0\xea\xb3\xbc |\n|--------|----------|------|\n| "intake \xed\x95\xb4\xec\xa4\x98" | `intake(description)` | BRIEF \xec\x83\x9d\xec\x84\xb1 |\n| "plan \xeb\xa7\x8c\xeb\x93\xa4\xec\x96\xb4" | `plan(brief_id)` | RUN \xec\x83\x9d\xec\x84\xb1 |\n| "\xec\x9e\x91\xec\x97\x85 \xec\x99\x84\xeb\xa3\x8c" | `finish(run_id, git_hash)` | Status \xec\x99\x84\xeb\xa3\x8c |\n\n### Step 1: Intake\n- \xec\x82\xac\xec\x9a\xa9\xec\x9e\x90\xea\xb0\x80 "~\xed\x95\xb4\xec\xa4\x98", "intake \xed\x95\xb4\xec\xa4\x98" \xec\x9a\x94\xec\xb2\xad \xec\x8b\x9c\n- `intake("\xec\x9a\x94\xec\xb2\xad \xeb\x82\xb4\xec\x9a\xa9")` \xed\x98\xb8\xec\xb6\x9c \xe2\x86\x92 BRIEF \xec\x83\x9d\xec\x84\xb1\n- BRIEF \xea\xb2\x80\xed\x86\xa0 \xec\x9a\x94\xec\xb2\xad\n\n### Step 2: Plan\n- \xec\x82\xac\xec\x9a\xa9\xec\x9e\x90\xea\xb0\x80 "plan \xeb\xa7\x8c\xeb\x93\xa4\xec\x96\xb4", "\xea\xb3\x84\xed\x9a\x8d \xed\x99\x95\xec\xa0\x95" \xec\x9a\x94\xec\xb2\xad \xec\x8b\x9c\n- `plan("BRIEF-ID")` \xed\x98\xb8\xec\xb6\x9c \xe2\x86\x92 RUN \xec\x83\x9d\xec\x84\xb1\n- RUN \xea\xb2\x80\xed\x86\xa0 \xec\x9a\x94\xec\xb2\xad\n\n### Step 3: Finish\n- \xea\xb5\xac\xed\x98\x84 \xec\x99\x84\xeb\xa3\x8c \xed\x9b\x84\n- Git \xec\xbb\xa4\xeb\xb0\x8b \xec\x83\x9d\xec\x84\xb1\n- `finish("RUN-ID", git_hash="...")` \xed\x98\xb8\xec\xb6\x9c\n- RUN\xec\x9d\x80 active/\xec\x97\x90 \xec\x9c\xa0\xec\xa7\x80 (Archive \xec\x9d\xb4\xeb\x8f\x99 \xec\x97\x86\xec\x9d\x8c)\n\n### Self-Check (\xec\x99\x84\xeb\xa3\x8c \xec\xa0\x84 \xed\x95\x84\xec\x88\x98)\n- [ ] **Test**: \xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xed\x86\xb5\xea\xb3\xbc?\n- [ ] **Boundary**: CONVENTIONS Boundaries \xec\xa4\x80\xec\x88\x98?\n- [ ] **Spec**: REQ/BRIEF\xec\x99\x80 \xec\x9d\xbc\xec\xb9\x98?\n\n### When Discussion Needed\n1. Create DISC-* in `02_REQUIREMENTS/discussions/`\n2. Reference from REQ\'s `Related` section\n3. Update REQ with final decision\n\n---\n\n## 8. \xed\x95\x98\xec\x9c\x84 \xed\x98\xb8\xed\x99\x98 \xeb\xb3\x84\xec\xb9\xad\n\n- `plan_from_brief()` \xe2\x86\x92 `plan()` (v3.4 \xec\x9d\xb4\xec\xa0\x84 \xed\x98\xb8\xed\x99\x98)\n- `finalize_run()` \xe2\x86\x92 `finish()` (v3.4 \xec\x9d\xb4\xec\xa0\x84 \xed\x98\xb8\xed\x99\x98)\n"""\n\nSYSTEM_TEMPLATES = {\n    "00_SYSTEM/AGENT_RULES.md": AGENT_RULES_TEMPLATE,\n    "00_SYSTEM/ONBOARDING_PROMPT.md": DOC_TEMPLATES["00_SYSTEM/ONBOARDING_PROMPT.md"],\n}\n\n# README files that should be updated on version upgrade\n# These are system-managed and will be overwritten during update\nUPDATABLE_READMES = [\n    "00_INDEX.md",\n    "00_SYSTEM/README.md",\n    "02_REQUIREMENTS/README.md",\n    "02_REQUIREMENTS/_index.md",\n    "02_REQUIREMENTS/capabilities/README.md",\n    "02_REQUIREMENTS/invariants/README.md",\n    "02_REQUIREMENTS/competencies/README.md",\n    "02_REQUIREMENTS/discussions/README.md",\n    "03_TECH_SPECS/README.md",\n    "04_TASK_LOGS/README.md",\n    "04_TASK_LOGS/active/README.md",\n]\n\n# ============================================================================\n# MIGRATION\n# ============================================================================\n\n# v1.x \xe2\x86\x92 v2.x migration (legacy)\nMIGRATION_MAP_V1 = {\n    "01_PROJECT_CONTEXT/00_IDENTITY.md": None,\n    "01_PROJECT_CONTEXT/01_OVERVIEW.md": None,\n    "01_PROJECT_CONTEXT/02_ARCHITECTURE.md": "03_TECH_SPECS/architecture/SYSTEM_ARCHITECTURE.md",\n    "01_PROJECT_CONTEXT/03_DATA_MODEL.md": "03_TECH_SPECS/architecture/DATA_MODEL.md",\n    "01_PROJECT_CONTEXT/04_AGENT_GUIDE.md": None,\n    "02_SERVICES": "02_REQUIREMENTS/capabilities",\n    "03_MANAGEMENT/STATUS.md": "04_TASK_LOGS/STATUS.md",\n    "03_MANAGEMENT/CHANGELOG.md": "04_TASK_LOGS/CHANGELOG.md",\n    "03_MANAGEMENT/WORKLOG.md": None,\n    "03_MANAGEMENT/COMPONENTS.md": None,\n    "03_MANAGEMENT/MISSING_COMPONENTS.md": None,\n    "03_MANAGEMENT/tasks/active": "04_TASK_LOGS/active",\n    "03_MANAGEMENT/tasks/archive": "04_TASK_LOGS/archive",\n    "90_TOOLING/AGENT_RULES.md": "00_SYSTEM/AGENT_RULES.md",\n    "90_TOOLING/scripts": "00_SYSTEM/scripts",\n}\n\n# v2.x \xe2\x86\x92 v3.0 migration (capabilities & invariants)\nMIGRATION_MAP_V2_TO_V3 = {\n    "02_REQUIREMENTS/features": "02_REQUIREMENTS/capabilities",\n    "02_REQUIREMENTS/business_rules": "02_REQUIREMENTS/invariants",\n}\n\n# Combined for backward compatibility\nMIGRATION_MAP = {**MIGRATION_MAP_V1, **MIGRATION_MAP_V2_TO_V3}\n\nLEGACY_DIRS_TO_ARCHIVE = [\n    "02_SERVICES",\n    "03_MANAGEMENT",\n    "90_TOOLING",\n]\n')
    __stickytape_write_module('core/bootstrap_mcp.py', b'from __future__ import annotations\n\nimport json\nfrom pathlib import Path\nfrom typing import Dict, List\n\nfrom core.config import CURRENT_VERSION, MCP_DEFINITIONS, ROOT_DIR\nfrom utils.fs import update_mcp_definitions, write_file\n\nVALID_TARGETS = {"claude_code", "claude_desktop", "codex", "gemini_cli", "ci"}\nVALID_OS = {"windows", "unix"}\n\n\ndef _python_path(os_name: str) -> str:\n    if os_name == "windows":\n        return ".venv-mcp\\\\Scripts\\\\python.exe"\n    return ".venv-mcp/bin/python"\n\n\ndef _render_mcp_template(os_name: str) -> str:\n    payload = {\n        "mcpServers": {\n            "memoryatlas": {\n                "command": _python_path(os_name),\n                "args": [".memory/00_SYSTEM/mcp/mcp_server.py", "--stdio"],\n                "env": {},\n            }\n        }\n    }\n    return json.dumps(payload, indent=2)\n\n\ndef _render_prompt(target: str, os_name: str) -> str:\n    lines: List[str] = [\n        "# MCP Bootstrap Prompt",\n        "",\n        "Goal: Configure MCP so the client can auto-spawn the MemoryAtlas server on demand.",\n        f"Target client: {target}",\n        f"OS: {os_name}",\n        "Python strategy: default to .venv-mcp unless specified otherwise.",\n        "",\n        "Constraints:",\n        "- Do NOT edit anything under 02_REQUIREMENTS automatically.",\n        "- Use STDIO mode for MCP server execution.",\n        "",\n        "Project context:",\n        "- Repo root contains .memory/ and memory_manager.py",\n        "- MCP entrypoint: .memory/00_SYSTEM/mcp/mcp_server.py",\n        "",\n        "MCP tool definitions:",\n    ]\n    for name, spec in sorted(MCP_DEFINITIONS.items()):\n        lines.append(f"- {spec[\'signature\']}: {spec[\'summary\']}")\n    lines.extend(\n        [\n            "",\n            "Required outputs (fixed format):",\n            "1) List of files to create or update (with paths).",\n            "2) Full contents of each file or a unified diff patch.",\n            "3) Installation / connection steps (3-5 steps).",\n            "4) Verification steps (commands to run).",\n            "",\n            "Must include:",\n            "- apply_req_full two-call flow in MCP README.",\n            "- Requires-Spec metadata example in MCP README.",\n            "- create_disc_from_failure(context) example in MCP README.",\n            "",\n            "Default file targets:",\n            f"- .memory/00_SYSTEM/mcp/templates/{target}.mcp.json",\n            "- .memory/00_SYSTEM/scripts/run_mcp_server.ps1",\n            "- .memory/00_SYSTEM/scripts/run_mcp_server.sh",\n            "",\n            "Validation commands:",\n            "- python memory_manager.py --doctor",\n            f"- python memory_manager.py --mcp-check --target {target}",\n        ]\n    )\n    return "\\n".join(lines).rstrip() + "\\n"\n\n\ndef _render_checklist(target: str, os_name: str) -> str:\n    return (\n        "# MCP Bootstrap Checklist\\n\\n"\n        f"- [ ] Target: {target}\\n"\n        f"- [ ] OS: {os_name}\\n"\n        "- [ ] MCP README updated (auto-generated)\\n"\n        f"- [ ] Template created: .memory/00_SYSTEM/mcp/templates/{target}.mcp.json\\n"\n        "- [ ] Script created: .memory/00_SYSTEM/scripts/run_mcp_server.ps1\\n"\n        "- [ ] Script created: .memory/00_SYSTEM/scripts/run_mcp_server.sh\\n"\n        "- [ ] Client config applied from template\\n"\n        "- [ ] `python memory_manager.py --doctor` passes\\n"\n        f"- [ ] `python memory_manager.py --mcp-check --target {target}` passes\\n"\n    )\n\n\ndef _render_run_script_ps1() -> str:\n    return (\n        "$ErrorActionPreference = \\"Stop\\"\\n"\n        "$scriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path\\n"\n        "$systemDir = Split-Path -Parent $scriptDir\\n"\n        "$memoryDir = Split-Path -Parent $systemDir\\n"\n        "$repoDir = Split-Path -Parent $memoryDir\\n"\n        "$python = Join-Path $repoDir \\".venv-mcp\\\\\\\\Scripts\\\\\\\\python.exe\\"\\n"\n        "$server = Join-Path $memoryDir \\"00_SYSTEM\\\\\\\\mcp\\\\\\\\mcp_server.py\\"\\n"\n        "& $python $server --stdio\\n"\n    )\n\n\ndef _render_run_script_sh() -> str:\n    return (\n        "#!/usr/bin/env bash\\n"\n        "set -euo pipefail\\n"\n        "script_dir=\\"$(cd \\"$(dirname \\"${BASH_SOURCE[0]}\\")\\" && pwd)\\"\\n"\n        "system_dir=\\"$(cd \\"$script_dir/..\\" && pwd)\\"\\n"\n        "memory_dir=\\"$(cd \\"$system_dir/..\\" && pwd)\\"\\n"\n        "repo_dir=\\"$(cd \\"$memory_dir/..\\" && pwd)\\"\\n"\n        "python=\\"$repo_dir/.venv-mcp/bin/python\\"\\n"\n        "\\"$python\\" \\"$memory_dir/00_SYSTEM/mcp/mcp_server.py\\" --stdio\\n"\n    )\n\n\ndef bootstrap_mcp(target: str, os_name: str, dry_run: bool = False) -> None:\n    if target not in VALID_TARGETS:\n        raise ValueError(f"Unknown target: {target}. Use: {\', \'.join(sorted(VALID_TARGETS))}")\n    if os_name not in VALID_OS:\n        raise ValueError(f"Unknown OS: {os_name}. Use: windows or unix")\n\n    root = Path(ROOT_DIR)\n    mcp_dir = root / "00_SYSTEM" / "mcp"\n    templates_dir = mcp_dir / "templates"\n    scripts_dir = root / "00_SYSTEM" / "scripts"\n    mcp_dir.mkdir(parents=True, exist_ok=True)\n    templates_dir.mkdir(parents=True, exist_ok=True)\n    scripts_dir.mkdir(parents=True, exist_ok=True)\n\n    update_mcp_definitions(ROOT_DIR, dry_run=dry_run)\n\n    prompt_path = mcp_dir / f"BOOTSTRAP_MCP_PROMPT_{target}_{os_name}.md"\n    checklist_path = mcp_dir / f"BOOTSTRAP_MCP_CHECKLIST_{target}_{os_name}.md"\n    template_path = templates_dir / f"{target}.mcp.json"\n    script_ps1 = scripts_dir / "run_mcp_server.ps1"\n    script_sh = scripts_dir / "run_mcp_server.sh"\n\n    files: Dict[Path, str] = {\n        prompt_path: _render_prompt(target, os_name),\n        checklist_path: _render_checklist(target, os_name),\n        template_path: _render_mcp_template(os_name),\n        script_ps1: _render_run_script_ps1(),\n        script_sh: _render_run_script_sh(),\n    }\n\n    print("\\n" + "=" * 60)\n    print("MCP Bootstrap")\n    print("=" * 60)\n    for path, content in files.items():\n        rel = path.as_posix()\n        if dry_run:\n            print(f"  [DRY-RUN] Would write: {rel}")\n            continue\n        write_file(str(path), content)\n        print(f"  [WRITE] {rel}")\n\n    print("\\nNext steps:")\n    print(f"  1) Apply the template: {template_path.as_posix()}")\n    print("  2) Configure your client to auto-spawn the MCP server (STDIO).")\n    print("  3) Validate with --doctor and --mcp-check.")\n')
    __stickytape_write_module('utils/__init__.py', b'')
    __stickytape_write_module('utils/fs.py', b'\nimport json\nimport os\nimport re\nimport shutil\nfrom datetime import datetime\nfrom typing import List, Optional\n\nfrom core.config import (\n    CURRENT_VERSION,\n    DIRS,\n    DOC_TEMPLATES,\n    MCP_DEFINITIONS,\n    SYSTEM_TEMPLATES,\n    TEMPLATE_VERSION,\n    UPDATABLE_READMES,\n)\n\nONBOARDING_GUIDE_PATH = "GETTING_STARTED.md"\nONBOARDING_PROMPT_REL_PATH = "00_SYSTEM/ONBOARDING_PROMPT.md"\nONBOARDING_STATE_REL_PATH = "00_SYSTEM/state/onboarding.json"\nONBOARDING_NOTE_PLACEHOLDERS = {"(\xec\x9e\x90\xec\x9c\xa0\xeb\xa1\xad\xea\xb2\x8c \xea\xb8\xb0\xeb\xa1\x9d)", "(\xec\x9e\x91\xec\x84\xb1 \xeb\x82\xb4\xec\x9a\xa9 \xec\x97\x86\xec\x9d\x8c)"}\nONBOARDING_NOTES_RE = re.compile(\n    r"<!-- NOTES:BEGIN -->(.*?)<!-- NOTES:END -->", re.S\n)\nONBOARDING_ID_RE = re.compile(r"<!-- id:([a-z0-9_.-]+) -->")\nONBOARDING_CHECKBOX_RE = re.compile(\n    r"^(\\s*- \\[)(?P<mark>[ xX])(\\] .+?<!-- id:(?P<id>[^ ]+) -->\\s*)$",\n    re.M,\n)\n\ndef write_file(path: str, content: str, dry_run: bool = False) -> None:\n    """Write content to file, creating parent directories if needed."""\n    if dry_run:\n        return\n    dir_name = os.path.dirname(path)\n    if dir_name:\n        os.makedirs(dir_name, exist_ok=True)\n    with open(path, "w", encoding="utf-8") as f:\n        f.write(content)\n\ndef read_text(path: str) -> str:\n    """Read text from file with error handling."""\n    with open(path, "r", encoding="utf-8", errors="ignore") as f:\n        return f.read()\n\ndef safe_move(src: str, dest: str, dry_run: bool = False) -> bool:\n    """Safely move file/directory."""\n    if not os.path.exists(src):\n        return False\n    if dry_run:\n        return True\n    dest_dir = os.path.dirname(dest)\n    if dest_dir:\n        os.makedirs(dest_dir, exist_ok=True)\n    if os.path.exists(dest):\n        return False\n    try:\n        shutil.move(src, dest)\n        return True\n    except Exception as e:\n        print(f"  ! Failed to move {src}: {e}")\n        return False\n\ndef ensure_structure(root: str) -> None:\n    """Ensure all required directories exist."""\n    for folder in DIRS:\n        os.makedirs(os.path.join(root, folder), exist_ok=True)\n\ndef _current_date() -> str:\n    return datetime.now().strftime("%Y-%m-%d")\n\ndef _extract_onboarding_ids(template: str) -> list[str]:\n    ids = ONBOARDING_ID_RE.findall(template)\n    return sorted(set(ids))\n\ndef _normalize_notes(notes: str) -> str:\n    trimmed = notes.strip()\n    if not trimmed or trimmed in ONBOARDING_NOTE_PLACEHOLDERS:\n        return ""\n    return notes.strip("\\n").rstrip()\n\ndef _extract_notes(text: str) -> Optional[str]:\n    match = ONBOARDING_NOTES_RE.search(text)\n    if not match:\n        return None\n    return match.group(1).strip("\\n")\n\ndef load_onboarding_state(root: str, template: str) -> tuple[dict, bool, bool]:\n    """Load onboarding state and normalize missing fields."""\n    state_path = os.path.join(root, *ONBOARDING_STATE_REL_PATH.split("/"))\n    state_exists = os.path.exists(state_path)\n    state_changed = False\n\n    state: dict = {}\n    if state_exists:\n        try:\n            with open(state_path, "r", encoding="utf-8") as f:\n                data = json.load(f)\n                if isinstance(data, dict):\n                    state = data\n        except Exception:\n            state = {}\n\n    if "schema_version" not in state:\n        state["schema_version"] = 1\n        state_changed = True\n    if state.get("template_version") != TEMPLATE_VERSION:\n        state["template_version"] = TEMPLATE_VERSION\n        state_changed = True\n    if not isinstance(state.get("items"), dict):\n        state["items"] = {}\n        state_changed = True\n    if not isinstance(state.get("notes"), str):\n        state["notes"] = ""\n        state_changed = True\n    if not isinstance(state.get("last_updated"), str):\n        state["last_updated"] = "(TBD)"\n        state_changed = True\n\n    for item_id in _extract_onboarding_ids(template):\n        if item_id not in state["items"]:\n            state["items"][item_id] = False\n            state_changed = True\n\n    return state, state_changed, state_exists\n\ndef sync_onboarding_state_from_guide(guide_text: str, state: dict) -> bool:\n    """Sync checkbox state and notes from existing guide content."""\n    changed = False\n    for match in ONBOARDING_CHECKBOX_RE.finditer(guide_text):\n        item_id = match.group("id")\n        done = match.group("mark").lower() == "x"\n        current = state["items"].get(item_id)\n        if current is None or current != done:\n            state["items"][item_id] = done\n            changed = True\n\n    notes = _extract_notes(guide_text)\n    if notes is not None:\n        normalized = _normalize_notes(notes)\n        if normalized != state.get("notes", ""):\n            state["notes"] = normalized\n            changed = True\n\n    return changed\n\ndef _compute_onboarding_status(items: dict) -> str:\n    if not items:\n        return "Not Started"\n    total = len(items)\n    done = sum(1 for value in items.values() if value)\n    if done == 0:\n        return "Not Started"\n    if done == total:\n        return "Completed"\n    return "In Progress"\n\ndef render_onboarding_guide(template: str, state: dict) -> str:\n    """Render the onboarding guide template with current state."""\n    def replace_checkbox(match: re.Match) -> str:\n        item_id = match.group("id")\n        done = state.get("items", {}).get(item_id, False)\n        mark = "x" if done else " "\n        return f"{match.group(1)}{mark}{match.group(3)}"\n\n    rendered = ONBOARDING_CHECKBOX_RE.sub(replace_checkbox, template)\n    status = _compute_onboarding_status(state.get("items", {}))\n    last_updated = state.get("last_updated") or "(TBD)"\n    rendered = rendered.replace("{STATUS}", status)\n    rendered = rendered.replace("{LAST_UPDATED}", last_updated)\n\n    notes = state.get("notes", "")\n    notes_body = _normalize_notes(notes)\n    if not notes_body:\n        notes_body = "(\xec\x9e\x90\xec\x9c\xa0\xeb\xa1\xad\xea\xb2\x8c \xea\xb8\xb0\xeb\xa1\x9d)"\n    rendered = ONBOARDING_NOTES_RE.sub(\n        f"<!-- NOTES:BEGIN -->\\n{notes_body}\\n<!-- NOTES:END -->",\n        rendered,\n    )\n    return rendered\n\ndef update_onboarding_guide(root: str, dry_run: bool = False, force: bool = False) -> None:\n    """Update onboarding guide using template + state."""\n    template = DOC_TEMPLATES.get(ONBOARDING_GUIDE_PATH)\n    if not template:\n        return\n\n    state, state_changed, state_exists = load_onboarding_state(root, template)\n\n    guide_path = os.path.join(root, ONBOARDING_GUIDE_PATH)\n    if os.path.exists(guide_path):\n        guide_text = read_text(guide_path)\n        if sync_onboarding_state_from_guide(guide_text, state):\n            state_changed = True\n\n    if state_changed or not state_exists or force:\n        state["last_updated"] = _current_date()\n\n    if dry_run:\n        print(f"  - Would update onboarding guide: {ONBOARDING_GUIDE_PATH}")\n        if state_changed or not state_exists or force:\n            print(f"  - Would update onboarding state: {ONBOARDING_STATE_REL_PATH}")\n        return\n\n    if state_changed or not state_exists or force:\n        state_path = os.path.join(root, *ONBOARDING_STATE_REL_PATH.split("/"))\n        write_file(state_path, json.dumps(state, indent=2, sort_keys=True) + "\\n")\n\n    rendered = render_onboarding_guide(template, state)\n    write_file(guide_path, rendered)\n    print(f"  * Updated onboarding guide: {ONBOARDING_GUIDE_PATH}")\n\ndef update_onboarding_prompt(root: str, dry_run: bool = False) -> None:\n    """Update onboarding prompt in 00_SYSTEM for manual refresh."""\n    content = DOC_TEMPLATES.get(ONBOARDING_PROMPT_REL_PATH)\n    if not content:\n        return\n    if dry_run:\n        print(f"  - Would update onboarding prompt: {ONBOARDING_PROMPT_REL_PATH}")\n        return\n    prompt_path = os.path.join(root, *ONBOARDING_PROMPT_REL_PATH.split("/"))\n    write_file(prompt_path, content)\n    print(f"  * Updated onboarding prompt: {ONBOARDING_PROMPT_REL_PATH}")\n\ndef create_missing_docs(root: str, dry_run: bool = False) -> None:\n    """Create missing template documents."""\n    for rel_path, content in DOC_TEMPLATES.items():\n        if rel_path == ONBOARDING_GUIDE_PATH:\n            continue\n        path = os.path.join(root, rel_path)\n        if os.path.exists(path):\n            continue\n        if dry_run:\n            print(f"  - Would create doc: {rel_path}")\n            continue\n        dir_name = os.path.dirname(path)\n        if dir_name:\n            os.makedirs(dir_name, exist_ok=True)\n        write_file(path, content)\n        print(f"  + Created doc: {rel_path}")\n\ndef update_system_templates(root: str, dry_run: bool = False) -> None:\n    """Update system-managed template files."""\n    for rel_path, content in SYSTEM_TEMPLATES.items():\n        path = os.path.join(root, rel_path)\n        if dry_run:\n            print(f"  - Would update system file: {rel_path}")\n            continue\n        dir_name = os.path.dirname(path)\n        if dir_name:\n            os.makedirs(dir_name, exist_ok=True)\n        write_file(path, content)\n        print(f"  * Updated system file: {rel_path}")\n\n\ndef update_readme_files(root: str, dry_run: bool = False) -> None:\n    """Update README files that are system-managed."""\n    for rel_path in UPDATABLE_READMES:\n        if rel_path not in DOC_TEMPLATES:\n            continue\n        path = os.path.join(root, rel_path)\n        content = DOC_TEMPLATES[rel_path]\n        if dry_run:\n            print(f"  - Would update readme: {rel_path}")\n            continue\n        dir_name = os.path.dirname(path)\n        if dir_name:\n            os.makedirs(dir_name, exist_ok=True)\n        write_file(path, content)\n        print(f"  * Updated readme: {rel_path}")\n\ndef render_mcp_collection(definitions: dict) -> str:\n    """Render single MCP documentation file that covers all definitions."""\n    lines = [\n        "# MCP Definitions",\n        "",\n        "System-generated. Do not edit directly.",\n        "",\n        "Each section below documents an MCP function exposed by MemoryAtlas.",\n        "",\n    ]\n    for name, spec in sorted(definitions.items()):\n        lines.extend(\n            [\n                f"## {name}",\n                "",\n                "### Signature",\n                f"`{spec[\'signature\']}`",\n                "",\n                "### Summary",\n                spec["summary"],\n                "",\n                "### Inputs",\n            ]\n        )\n        inputs = spec.get("inputs", [])\n        if inputs:\n            lines.extend(f"- {item}" for item in inputs)\n        else:\n            lines.append("- (none)")\n        lines.extend(["", "### Outputs"])\n        outputs = spec.get("outputs", [])\n        if outputs:\n            lines.extend(f"- {item}" for item in outputs)\n        else:\n            lines.append("- (none)")\n        behavior = spec.get("behavior", [])\n        if behavior:\n            lines.extend(["", "### Behavior"])\n            lines.extend(f"- {item}" for item in behavior)\n        lines.append("")  # blank line between sections\n    lines.extend(render_mcp_connection_guide())\n    return "\\n".join(lines).rstrip() + "\\n"\n\n\ndef render_mcp_connection_guide() -> List[str]:\n    """Render connection guide and templates overview."""\n    return [\n        "## Connection Guide",\n        "",\n        "### Entry Points",\n        "- STDIO: `python .memory/00_SYSTEM/mcp/mcp_server.py --stdio`",\n        "- HTTP: `python .memory/00_SYSTEM/mcp/mcp_server.py --http --host 127.0.0.1 --port 8765`",\n        "- Module: `python -m memoryatlas_mcp --stdio`",\n        "",\n        "### Auto-Launch Behavior",\n        "- STDIO clients can auto-spawn the server process on demand using the configured command.",\n        "- This means the server does not need to be manually running in the background.",\n        "- HTTP mode still requires a long-running server process.",\n        "",\n        "### One-Shot Flow (apply_req_full)",\n        "- Call `apply_req_full(req_id)` to create the RUN and receive instructions.",\n        "- Implement changes, then call `apply_req_full(req_id)` again to verify and finalize.",\n        "",\n        "### Spec Auto-Trigger",\n        "- Set REQ metadata `> **Requires-Spec**: true` to auto-create 03 specs.",\n        "",\n        "### DISC Context Example",\n        "- `create_disc_from_failure({\\"req_id\\":\\"REQ-MCP-001\\",\\"stage\\":\\"validate\\",\\"errors\\":[{\\"type\\":\\"links\\",\\"message\\":\\"3 link issues\\"}],\\"files\\":[\\"02_REQUIREMENTS/README.md\\"],\\"rules\\":[\\"RULE-LINK-001\\"],\\"logs\\":\\"...\\"})`",\n        "",\n        "### Client Config Templates",\n        "- `claude_code.mcp.json` (STDIO)",\n        "- `codex.mcp.json` (STDIO)",\n        "- `gemini_cli.mcp.json` (STDIO)",\n        "- Bootstrap templates: `00_SYSTEM/mcp/templates/<target>.mcp.json` (from --bootstrap-mcp)",\n        "",\n        "### Notes",\n        "- Clients usually require one-time server registration.",\n        "- HTTP mode may require authentication and is optional.",\n        "",\n    ]\n\n\ndef update_mcp_definitions(root: str, dry_run: bool = False) -> None:\n    """Generate MCP definition documentation under 00_SYSTEM/mcp/."""\n    dir_path = os.path.join(root, "00_SYSTEM", "mcp")\n    os.makedirs(dir_path, exist_ok=True)\n    rel_path = os.path.join("00_SYSTEM", "mcp", "README.md")\n    path = os.path.join(root, rel_path)\n    content = render_mcp_collection(MCP_DEFINITIONS)\n    if dry_run:\n        print(f"  - Would update mcp: {rel_path}")\n        return\n    write_file(path, content)\n    print(f"  * Updated mcp: {rel_path}")\n    update_mcp_server_entrypoint(root, dry_run=dry_run)\n    update_mcp_client_templates(root, dry_run=dry_run)\n\n\ndef update_mcp_server_entrypoint(root: str, dry_run: bool = False) -> None:\n    """Write MCP server entrypoint under 00_SYSTEM/mcp/."""\n    rel_path = os.path.join("00_SYSTEM", "mcp", "mcp_server.py")\n    path = os.path.join(root, rel_path)\n    content = render_mcp_server_entrypoint()\n    if dry_run:\n        print(f"  - Would update mcp: {rel_path}")\n        return\n    write_file(path, content)\n    print(f"  * Updated mcp: {rel_path}")\n\n\ndef render_mcp_server_entrypoint() -> str:\n    return (\n        "#!/usr/bin/env python3\\n"\n        "from __future__ import annotations\\n"\n        "import argparse\\n"\n        "import sys\\n"\n        "from pathlib import Path\\n"\n        "\\n"\n        "ROOT = Path(__file__).resolve().parents[3]\\n"\n        "SRC = ROOT / \\"src\\"\\n"\n        "sys.path.insert(0, str(SRC))\\n"\n        "\\n"\n        "try:\\n"\n        "    from mcp_server import run_server\\n"\n        "except Exception as exc:\\n"\n        "    print(f\\"Failed to import MCP server: {exc}\\")\\n"\n        "    sys.exit(1)\\n"\n        "\\n"\n        "def main() -> int:\\n"\n        "    parser = argparse.ArgumentParser(description=\\"MemoryAtlas MCP Server\\")\\n"\n        "    parser.add_argument(\\"--stdio\\", action=\\"store_true\\", help=\\"Run in STDIO mode\\")\\n"\n        "    parser.add_argument(\\"--http\\", action=\\"store_true\\", help=\\"Run in HTTP mode\\")\\n"\n        "    parser.add_argument(\\"--host\\", default=\\"127.0.0.1\\", help=\\"HTTP host\\")\\n"\n        "    parser.add_argument(\\"--port\\", type=int, default=8765, help=\\"HTTP port\\")\\n"\n        "    args = parser.parse_args()\\n"\n        "    mode = \\"http\\" if args.http else \\"stdio\\"\\n"\n        "    run_server(mode=mode, host=args.host, port=args.port)\\n"\n        "    return 0\\n"\n        "\\n"\n        "if __name__ == \\"__main__\\":\\n"\n        "    raise SystemExit(main())\\n"\n    )\n\n\ndef update_mcp_client_templates(root: str, dry_run: bool = False) -> None:\n    """Write MCP client config templates."""\n    templates = {\n        "claude_code.mcp.json": render_mcp_template_stdio("memoryatlas"),\n        "codex.mcp.json": render_mcp_template_stdio("memoryatlas"),\n        "gemini_cli.mcp.json": render_mcp_template_stdio("memoryatlas"),\n    }\n    for name, content in templates.items():\n        rel_path = os.path.join("00_SYSTEM", "mcp", name)\n        path = os.path.join(root, rel_path)\n        if dry_run:\n            print(f"  - Would update mcp: {rel_path}")\n            continue\n        write_file(path, content)\n        print(f"  * Updated mcp: {rel_path}")\n\n\ndef render_mcp_template_stdio(server_name: str) -> str:\n    return (\n        "{\\n"\n        f"  \\"mcpServers\\": {{\\n"\n        f"    \\"{server_name}\\": {{\\n"\n        "      \\"command\\": \\"python\\",\\n"\n        "      \\"args\\": [\\".memory/00_SYSTEM/mcp/mcp_server.py\\", \\"--stdio\\"],\\n"\n        "      \\"env\\": {}\\n"\n        "    }\\n"\n        "  }\\n"\n        "}\\n"\n    )\n\ndef update_tooling(root: str, dry_run: bool = False) -> None:\n    """Copy current script to system scripts directory."""\n    src = os.path.abspath(__file__)\n    dest = os.path.join(root, "00_SYSTEM", "scripts", "memory_manager.py")\n    dest_dir = os.path.dirname(dest)\n    if dest_dir:\n        os.makedirs(dest_dir, exist_ok=True)\n    if os.path.abspath(src) != os.path.abspath(dest):\n        if dry_run:\n            print(f"  - Would update tool: {dest}")\n            return\n        shutil.copyfile(src, dest)\n        print(f"  * Updated tool: 00_SYSTEM/scripts/memory_manager.py")\n\ndef read_version(root: str) -> str:\n    """Read installed version from VERSION file."""\n    version_file = os.path.join(root, "VERSION")\n    if not os.path.exists(version_file):\n        return "0.0.0"\n    with open(version_file, "r", encoding="utf-8") as f:\n        return f.read().strip()\n\ndef write_version(root: str, dry_run: bool = False) -> None:\n    """Write current version to VERSION file."""\n    version_file = os.path.join(root, "VERSION")\n    if dry_run:\n        print(f"  - Would update version to: {CURRENT_VERSION}")\n        return\n    write_file(version_file, CURRENT_VERSION)\n')
    __stickytape_write_module('core/checks.py', b'\nimport os\nimport re\nfrom typing import Optional\n\nfrom core.config import *\nfrom utils.fs import read_text, read_version\n\ndef iter_md_files(root: str, dirs: list[str]) -> list[str]:\n    """Iterate over markdown files in specified directories."""\n    files = []\n    for base in dirs:\n        base_path = os.path.join(root, base)\n        if not os.path.isdir(base_path):\n            continue\n        for dirpath, _, filenames in os.walk(base_path):\n            for name in filenames:\n                if name.lower().endswith(".md"):\n                    files.append(os.path.join(dirpath, name))\n    return files\n\ndef get_doc_type(path: str) -> str:\n    """Determine document type from path."""\n    if "capabilities" in path:\n        return "capabilities"\n    if "invariants" in path:\n        return "invariants"\n    if "competencies" in path:\n        return "competencies"\n    if "decisions" in path:\n        return "decisions"\n    if "briefs" in path or "BRIEF-" in os.path.basename(path):\n        return "briefs"\n    if "discussions" in path:\n        return "discussions"\n    return "default"\n\ndef check_structure(root: str) -> int:\n    """Validate directory structure and required files."""\n    issues = 0\n    if not os.path.isdir(root):\n        print(f"! Missing root directory: {root}")\n        return 1\n\n    for folder in DIRS:\n        path = os.path.join(root, folder)\n        if not os.path.isdir(path):\n            print(f"! Missing directory: {folder}")\n            issues += 1\n\n    required_files = set(DOC_TEMPLATES.keys())\n    required_files.add("VERSION")\n    required_files.update(SYSTEM_TEMPLATES.keys())\n\n    for rel_path in sorted(required_files):\n        path = os.path.join(root, rel_path)\n        if not os.path.exists(path):\n            print(f"! Missing file: {rel_path}")\n            issues += 1\n\n    installed_version = read_version(root)\n    if installed_version != CURRENT_VERSION:\n        print(\n            f"! Version mismatch: installed {installed_version} "\n            f"vs current {CURRENT_VERSION}"\n        )\n        issues += 1\n\n    print(f"\\nStructure check: {issues} issue(s)")\n    return issues\n\ndef check_mcp(root: str, target: Optional[str] = None) -> int:\n    """Validate MCP bootstrap outputs (templates and scripts)."""\n    issues = 0\n    mcp_dir = os.path.join(root, "00_SYSTEM", "mcp")\n    templates_dir = os.path.join(mcp_dir, "templates")\n    scripts_dir = os.path.join(root, "00_SYSTEM", "scripts")\n\n    required_files = [\n        os.path.join(mcp_dir, "README.md"),\n        os.path.join(mcp_dir, "mcp_server.py"),\n    ]\n    for path in required_files:\n        if not os.path.exists(path):\n            rel = os.path.relpath(path, root)\n            print(f"! Missing MCP file: {rel}")\n            issues += 1\n\n    if not os.path.isdir(templates_dir):\n        print("! Missing MCP templates directory: 00_SYSTEM/mcp/templates")\n        issues += 1\n    else:\n        if target:\n            template_path = os.path.join(templates_dir, f"{target}.mcp.json")\n            if not os.path.exists(template_path):\n                rel = os.path.relpath(template_path, root)\n                print(f"! Missing MCP template for target: {rel}")\n                issues += 1\n        else:\n            templates = [f for f in os.listdir(templates_dir) if f.endswith(".json")]\n            if not templates:\n                print("! No MCP templates found in 00_SYSTEM/mcp/templates")\n                issues += 1\n\n    script_ps1 = os.path.join(scripts_dir, "run_mcp_server.ps1")\n    script_sh = os.path.join(scripts_dir, "run_mcp_server.sh")\n    if not os.path.exists(script_ps1):\n        print("! Missing MCP run script: 00_SYSTEM/scripts/run_mcp_server.ps1")\n        issues += 1\n    if not os.path.exists(script_sh):\n        print("! Missing MCP run script: 00_SYSTEM/scripts/run_mcp_server.sh")\n        issues += 1\n\n    print(f"MCP check: {issues} issue(s)")\n    return issues\n\ndef lint_metadata(root: str) -> int:\n    """Check metadata headers in documents."""\n    issues = 0\n    for path in iter_md_files(root, LINT_DIRS):\n        name = os.path.basename(path)\n        if name in LINT_SKIP_FILES:\n            continue\n\n        text = read_text(path)\n        head = "\\n".join(text.splitlines()[:40])\n\n        doc_type = get_doc_type(path)\n        required_fields = HEADER_FIELDS_BY_TYPE.get(\n            doc_type, HEADER_FIELDS_BY_TYPE["default"]\n        )\n\n        missing = [field for field in required_fields if field not in head]\n        if missing:\n            rel_path = os.path.relpath(path, root)\n            print(f"! Missing header fields in {rel_path}: {\', \'.join(missing)}")\n            issues += 1\n\n    print(f"Metadata lint: {issues} issue(s)")\n    return issues\n\ndef iter_links(text: str) -> list[str]:\n    """Extract markdown links from text, excluding code blocks."""\n    links = []\n    in_code = False\n    for line in text.splitlines():\n        stripped = line.strip()\n        if stripped.startswith("```"):\n            in_code = not in_code\n            continue\n        if in_code:\n            continue\n        for match in LINK_RE.finditer(line):\n            links.append(match.group(1).strip())\n    return links\n\ndef check_links(root: str, allow_absolute: bool = False) -> int:\n    """Validate links in markdown documents."""\n    issues = 0\n    for path in iter_md_files(root, LINK_SCAN_DIRS):\n        text = read_text(path)\n        for target in iter_links(text):\n            if not target:\n                continue\n            if target.startswith("#"):\n                continue\n            if re.match(r"^[a-zA-Z][a-zA-Z0-9+.-]*:", target):\n                continue\n\n            clean = target.split("#", 1)[0].split("?", 1)[0].strip()\n            if not clean:\n                continue\n            if clean.startswith("<") and clean.endswith(">"):\n                clean = clean[1:-1].strip()\n\n            is_absolute = os.path.isabs(clean) or re.match(r"^[A-Za-z]:", clean)\n            if is_absolute:\n                rel_path = os.path.relpath(path, root)\n                if not allow_absolute:\n                    print(f"! Absolute path link forbidden in {rel_path}: {target}")\n                    issues += 1\n                elif not os.path.exists(clean):\n                    print(f"! Broken absolute link in {rel_path}: {target}")\n                    issues += 1\n                continue\n\n            resolved = os.path.normpath(os.path.join(os.path.dirname(path), clean))\n            if not os.path.exists(resolved):\n                rel_path = os.path.relpath(path, root)\n                print(f"! Broken link in {rel_path}: {target}")\n                issues += 1\n\n    print(f"Link check: {issues} issue(s)")\n    return issues\n\ndef extract_id_from_filename(filename: str) -> Optional[str]:\n    """Extract document ID from filename."""\n    name = os.path.splitext(filename)[0]\n    if REQ_ID_PATTERN.match(name):\n        return name\n    if RULE_ID_PATTERN.match(name):\n        return name\n    if CQ_ID_PATTERN.match(name):\n        return name\n    if DISC_ID_PATTERN.match(name):\n        return name\n    if RUN_ID_PATTERN.match(name):\n        return name\n    if BRIEF_ID_PATTERN.match(name):\n        return name\n    return None\n\ndef extract_meta_id(text: str) -> Optional[str]:\n    """Extract document ID from **ID**: metadata line (authority source)."""\n    match = META_ID_RE.search(text)\n    if match:\n        return match.group(1)\n    return None\n\ndef parse_must_read(text: str) -> tuple[list[str], list[str], list[str]]:\n    """Parse Must-Read and return (ids, invalid_links, disallowed_ids)."""\n    match = MUST_READ_RE.search(text)\n    if not match:\n        return [], [], []\n\n    refs = match.group(1).strip()\n    ids: list[str] = []\n    invalid_links: list[str] = []\n    disallowed_ids: list[str] = []\n    seen_ids: set[str] = set()\n    seen_invalid: set[str] = set()\n    seen_disallowed: set[str] = set()\n\n    for link_match in MUST_READ_LINK_RE.finditer(refs):\n        link_text = link_match.group(1).strip()\n        if not link_text:\n            if "<empty>" not in seen_invalid:\n                invalid_links.append("<empty>")\n                seen_invalid.add("<empty>")\n            continue\n        if MUST_READ_ANY_ID_RE.fullmatch(link_text):\n            if MUST_READ_ALLOWED_ID_RE.fullmatch(link_text):\n                if link_text not in seen_ids:\n                    ids.append(link_text)\n                    seen_ids.add(link_text)\n            else:\n                if link_text not in seen_disallowed:\n                    disallowed_ids.append(link_text)\n                    seen_disallowed.add(link_text)\n        else:\n            if link_text not in seen_invalid:\n                invalid_links.append(link_text)\n                seen_invalid.add(link_text)\n\n    refs_without_links = MUST_READ_LINK_RE.sub(" ", refs)\n    for id_match in MUST_READ_ANY_ID_RE.finditer(refs_without_links):\n        candidate = id_match.group(0)\n        if MUST_READ_ALLOWED_ID_RE.fullmatch(candidate):\n            if candidate not in seen_ids:\n                ids.append(candidate)\n                seen_ids.add(candidate)\n        else:\n            if candidate not in seen_disallowed:\n                disallowed_ids.append(candidate)\n                seen_disallowed.add(candidate)\n\n    return ids, invalid_links, disallowed_ids\n\ndef extract_must_read(text: str) -> list[str]:\n    """Extract allowed Must-Read IDs from document."""\n    ids, _, _ = parse_must_read(text)\n    return ids\n\ndef extract_header_ids(\n    text: str, patterns: Optional[list[re.Pattern]] = None\n) -> list[str]:\n    """Extract IDs from header lines (for sync validation)."""\n    header_ids: list[str] = []\n    scan_patterns = patterns or [REQ_HEADER_RE, RULE_HEADER_RE]\n    for pattern in scan_patterns:\n        for match in pattern.finditer(text):\n            header_ids.append(match.group(1))\n    return header_ids\n\ndef check_requirements(root: str) -> int:\n    """Validate requirement documents with authority model."""\n    issues = 0\n    seen_ids: dict[str, str] = {}\n    all_ids: set[str] = set()\n\n    # First pass: collect all IDs\n    for path in iter_md_files(root, REQ_SCAN_DIRS):\n        text = read_text(path)\n        meta_id = extract_meta_id(text)\n        if meta_id:\n            all_ids.add(meta_id)\n\n    # Fix F: Collect DISC IDs so they can be referenced\n    for path in iter_md_files(root, ["02_REQUIREMENTS/discussions"]):\n        text = read_text(path)\n        meta_id = extract_meta_id(text)\n        if meta_id:\n            all_ids.add(meta_id)\n\n    # Also collect RULE IDs\n    for path in iter_md_files(root, ["02_REQUIREMENTS/invariants"]):\n        text = read_text(path)\n        meta_id = extract_meta_id(text)\n        if meta_id:\n            all_ids.add(meta_id)\n\n    # Also collect ADR IDs (v2.2.1: P0 fix - validate ADR references)\n    for path in iter_md_files(root, ["03_TECH_SPECS/decisions"]):\n        text = read_text(path)\n        meta_id = extract_meta_id(text)\n        if meta_id:\n            all_ids.add(meta_id)\n        else:\n            # Fallback: extract ADR ID from filename (ADR-NNN-*.md)\n            filename = os.path.basename(path)\n            adr_match = re.match(r"(ADR-\\d{3})", filename)\n            if adr_match:\n                all_ids.add(adr_match.group(1))\n\n    # Second pass: validate\n    for path in iter_md_files(root, REQ_SCAN_DIRS):\n        text = read_text(path)\n        rel_path = os.path.relpath(path, root)\n        filename = os.path.basename(path)\n\n        if filename == "README.md":\n            continue\n\n        # === AUTHORITY: Extract ID from **ID**: metadata ===\n        meta_id = extract_meta_id(text)\n        filename_id = extract_id_from_filename(filename)\n        if (filename_id and filename_id.startswith("REQ-")) or (\n            meta_id and meta_id.startswith("REQ-")\n        ):\n            expected_patterns = [REQ_HEADER_RE]\n        elif (filename_id and filename_id.startswith("RULE-")) or (\n            meta_id and meta_id.startswith("RULE-")\n        ):\n            expected_patterns = [RULE_HEADER_RE]\n        elif (filename_id and filename_id.startswith("CQ-")) or (\n            meta_id and meta_id.startswith("CQ-")\n        ):\n            expected_patterns = [CQ_HEADER_RE]\n        else:\n            expected_patterns = [REQ_HEADER_RE, RULE_HEADER_RE, CQ_HEADER_RE]\n\n        header_ids = extract_header_ids(text, patterns=expected_patterns)\n        header_ids_any = extract_header_ids(\n            text,\n            patterns=[\n                REQ_HEADER_RE,\n                RULE_HEADER_RE,\n                CQ_HEADER_RE,\n                DISC_HEADER_RE,\n                RUN_HEADER_RE,\n            ],\n        )\n\n        # --- Validation 1: **ID**: must exist ---\n        if meta_id is None:\n            print(f"! Missing **ID**: metadata in {rel_path}")\n            print(f"    -> Add: > **ID**: REQ-DOMAIN-NNN or RULE-DOMAIN-NNN or CQ-DOMAIN-NNN")\n            issues += 1\n            if filename_id:\n                meta_id = filename_id\n\n        # --- Validation 2: Filename format check ---\n        if filename_id is None:\n            print(f"! Invalid filename format in {rel_path}")\n            print(\n                f"    -> Expected: REQ-[DOMAIN]-[NNN].md or RULE-[DOMAIN]-[NNN].md or CQ-[DOMAIN]-[NNN].md"\n            )\n            issues += 1\n\n        # --- Validation 3: Filename must match **ID**: ---\n        if meta_id and filename_id and meta_id != filename_id:\n            print(f"! Filename does not match **ID**: in {rel_path}")\n            print(f"    -> **ID**: {meta_id}")\n            print(f"    -> Filename: {filename_id}")\n            issues += 1\n\n        # --- Validation 4: Header must match **ID**: ---\n        if meta_id and header_ids:\n            if meta_id not in header_ids:\n                print(f"! Header does not match **ID**: in {rel_path}")\n                print(f"    -> **ID**: {meta_id}")\n                print(f"    -> Header(s): {\', \'.join(header_ids)}")\n                issues += 1\n        elif meta_id and not header_ids:\n            if header_ids_any:\n                print(f"! Header type mismatch in {rel_path}")\n                print(f"    -> **ID**: {meta_id}")\n                print(f"    -> Header(s): {\', \'.join(header_ids_any)}")\n                issues += 1\n            else:\n                print(f"! Missing header with ID in {rel_path}")\n                print(f"    -> Fix: Add header # [{meta_id}] Feature/Rule Name")\n                issues += 1\n\n        # --- Validation 5: Must-Read field exists (v2.2) ---\n        doc_prefix = None\n        if meta_id:\n            doc_prefix = meta_id.split("-", 1)[0]\n        elif filename_id:\n            doc_prefix = filename_id.split("-", 1)[0]\n        else:\n            doc_type = get_doc_type(path)\n            if doc_type == "capabilities":\n                doc_prefix = "REQ"\n            elif doc_type == "invariants":\n                doc_prefix = "RULE"\n            elif doc_type == "competencies":\n                doc_prefix = "CQ"\n\n        if doc_prefix in ("REQ", "RULE"):\n            must_read_match = MUST_READ_RE.search(text)\n            must_read_ids, invalid_links, disallowed_ids = parse_must_read(text)\n            if must_read_match is None:\n                print(f"! Missing **Must-Read**: field in {rel_path}")\n                print(f"    -> Add: > **Must-Read**: RULE-XXX-001, ADR-XXX")\n                issues += 1\n            else:\n                if invalid_links:\n                    print(f"! Must-Read link text must be an ID in {rel_path}")\n                    print(f"    -> Invalid link text: {\', \'.join(invalid_links)}")\n                    issues += 1\n                if disallowed_ids:\n                    print(f"! Must-Read allows only RULE/ADR IDs in {rel_path}")\n                    print(f"    -> Disallowed ID(s): {\', \'.join(disallowed_ids)}")\n                    issues += 1\n                # Fix B: Fail if Must-Read is empty (but present)\n                if not must_read_ids:\n                    print(f"! Empty **Must-Read**: list in {rel_path}")\n                    print(\n                        f"    -> MUST specify at least one ID (or \'None\' if genuinely none, though rare)"\n                    )\n                    issues += 1\n\n            # --- Validation 6: Must-Read references exist (v2.2.1: includes ADR) ---\n            for ref_id in must_read_ids:\n                if ref_id and ref_id not in all_ids:\n                    print(f"! Must-Read reference not found in {rel_path}: {ref_id}")\n                    issues += 1\n\n        # --- Validation 7: Duplicate ID check ---\n        if meta_id:\n            if meta_id in seen_ids:\n                print(\n                    f"! Duplicate ID {meta_id} in {rel_path} "\n                    f"(also in {seen_ids[meta_id]})"\n                )\n                issues += 1\n            else:\n                seen_ids[meta_id] = rel_path\n\n    print(f"Requirement check: {issues} issue(s)")\n    return issues\n\ndef check_runs(root: str) -> int:\n    """Validate RUN documents (Execution Unit model) with 3-way ID consistency."""\n    issues = 0\n\n    for path in iter_md_files(root, RUN_SCAN_DIRS):\n        text = read_text(path)\n        rel_path = os.path.relpath(path, root)\n        filename = os.path.basename(path)\n\n        if filename == "README.md":\n            continue\n\n        # === v2.2.1: 3-way ID consistency for RUN documents ===\n        meta_id = extract_meta_id(text)\n        filename_id = os.path.splitext(filename)[0]  # RUN ID is full filename\n        header_match = RUN_HEADER_RE.search(text)\n        header_id = header_match.group(1) if header_match else None\n\n        # Check filename format\n        if not RUN_ID_PATTERN.match(filename_id):\n            print(f"! Invalid RUN filename format: {rel_path} (ID: {filename_id})")\n            print(f"    -> Expected: RUN-REQ-[DOMAIN]-[NNN]-step-[NN].md")\n            issues += 1\n\n        # --- Validation: **ID**: must exist ---\n        if meta_id is None:\n            print(f"! Missing **ID**: metadata in {rel_path}")\n            print(f"    -> Add: > **ID**: {filename_id}")\n            issues += 1\n            meta_id = filename_id  # Fallback for subsequent checks\n\n        # --- Validation: Filename must match **ID**: ---\n        if meta_id and meta_id != filename_id:\n            print(f"! Filename does not match **ID**: in {rel_path}")\n            print(f"    -> **ID**: {meta_id}")\n            print(f"    -> Filename: {filename_id}")\n            issues += 1\n\n        # --- Validation: Header must match **ID**: ---\n        if meta_id and header_id and meta_id != header_id:\n            print(f"! Header does not match **ID**: in {rel_path}")\n            print(f"    -> **ID**: {meta_id}")\n            print(f"    -> Header: {header_id}")\n            issues += 1\n        elif meta_id and not header_id:\n            print(f"! Missing header with ID in {rel_path}")\n            print(f"    -> Fix: Add header # [{meta_id}] Step Description")\n            issues += 1\n\n        # Check required fields\n        # Check required fields\n        # Fix E: Use regex search instead of string containment\n        if not RUN_INPUT_RE.search(text):\n            print(f"! Missing **Input**: field in {rel_path}")\n            issues += 1\n\n        if not RUN_VERIFICATION_RE.search(text):\n            print(f"! Missing **Verification**: field in {rel_path}")\n            issues += 1\n\n        # Check Output section exists\n        # Fix D: RUN_OUTPUT_RE updated to support ### Output\n        if not RUN_OUTPUT_RE.search(text):\n            print(f"! Missing ## Output section in {rel_path}")\n            issues += 1\n\n    print(f"RUN document check: {issues} issue(s)")\n    return issues\n\ndef check_discussions(root: str) -> int:\n    """Validate DISCUSSION documents (3-way ID consistency)."""\n    issues = 0\n    # Fix F: Add DISC validation\n    for path in iter_md_files(root, ["02_REQUIREMENTS/discussions"]):\n        text = read_text(path)\n        rel_path = os.path.relpath(path, root)\n        filename = os.path.basename(path)\n\n        if filename == "README.md":\n            continue\n\n        meta_id = extract_meta_id(text)\n        filename_id = extract_id_from_filename(filename)\n        header_ids = extract_header_ids(text, patterns=[DISC_HEADER_RE])\n\n        # 1. **ID**: metadata existence\n        if meta_id is None:\n            print(f"! Missing **ID**: metadata in {rel_path}")\n            issues += 1\n            if filename_id:\n                meta_id = filename_id\n\n        # 2. Filename format\n        if filename_id is None:\n            print(f"! Invalid DISC filename format in {rel_path}")\n            issues += 1\n\n        # 3. Filename vs Meta ID\n        if meta_id and filename_id and meta_id != filename_id:\n            print(f"! Filename does not match **ID**: in {rel_path}")\n            print(f"    -> **ID**: {meta_id}")\n            print(f"    -> Filename: {filename_id}")\n            issues += 1\n\n        # 4. Header vs Meta ID\n        if meta_id and header_ids:\n            if meta_id not in header_ids:\n                print(f"! Header does not match **ID**: in {rel_path}")\n                print(f"    -> **ID**: {meta_id}")\n                print(f"    -> Header(s): {\', \'.join(header_ids)}")\n                issues += 1\n        elif meta_id and not header_ids:\n            print(f"! Missing header with ID in {rel_path}")\n            print(f"    -> Fix: Add header # [{meta_id}] Discussion Title")\n            issues += 1\n\n    print(f"Discussion check: {issues} issue(s)")\n    return issues\n\ndef check_briefs(root: str) -> int:\n    """Validate BRIEF documents (3-way ID consistency)."""\n    issues = 0\n    # Scan in BRIEF_SCAN_DIRS or fallback/specific dir if needed\n    # config.py defines BRIEF_SCAN_DIRS = ["04_TASK_LOGS/active"] usually,\n    # or wherever briefs are stored. Adjust scanning logic as appropriate.\n    for path in iter_md_files(root, BRIEF_SCAN_DIRS):\n        filename = os.path.basename(path)\n        if not filename.startswith("BRIEF-"):\n            continue\n\n        text = read_text(path)\n        rel_path = os.path.relpath(path, root)\n\n        meta_id = extract_meta_id(text)\n        filename_id = extract_id_from_filename(filename)\n        header_ids = extract_header_ids(text, patterns=[BRIEF_HEADER_RE])\n\n        # 1. **ID**: metadata existence\n        if meta_id is None:\n            print(f"! Missing **ID**: metadata in {rel_path}")\n            issues += 1\n            if filename_id:\n                meta_id = filename_id\n\n        # 2. Filename format (already checked partly by startswith, but strict check here)\n        if filename_id is None:\n            print(f"! Invalid BRIEF filename format in {rel_path}")\n            issues += 1\n\n        # 3. Filename vs Meta ID\n        if meta_id and filename_id and meta_id != filename_id:\n            print(f"! Filename does not match **ID**: in {rel_path}")\n            print(f"    -> **ID**: {meta_id}")\n            print(f"    -> Filename: {filename_id}")\n            issues += 1\n\n        # 4. Header vs Meta ID\n        if meta_id and header_ids:\n            if meta_id not in header_ids:\n                print(f"! Header does not match **ID**: in {rel_path}")\n                print(f"    -> **ID**: {meta_id}")\n                print(f"    -> Header(s): {\', \'.join(header_ids)}")\n                issues += 1\n        elif meta_id and not header_ids:\n            print(f"! Missing header with ID in {rel_path}")\n            print(f"    -> Fix: Add header # [{meta_id}] Brief Title")\n            issues += 1\n\n    print(f"Brief check: {issues} issue(s)")\n    return issues\n\ndef doctor(root: str, allow_absolute_links: bool = False) -> int:\n    """Run all checks at once."""\n    print("\\n" + "=" * 60)\n    print("  MemoryAtlas Doctor - Full System Check")\n    print("=" * 60)\n\n    total_issues = 0\n\n    print("\\n[1/7] Structure Check")\n    print("-" * 40)\n    total_issues += check_structure(root)\n\n    print("\\n[2/7] Metadata Lint")\n    print("-" * 40)\n    total_issues += lint_metadata(root)\n\n    print("\\n[3/7] Link Validation")\n    print("-" * 40)\n    total_issues += check_links(root, allow_absolute=allow_absolute_links)\n\n    print("\\n[4/7] Requirement Validation (Authority)")\n    print("-" * 40)\n    total_issues += check_requirements(root)\n\n    print("\\n[5/7] RUN Document Validation (Execution)")\n    print("-" * 40)\n    total_issues += check_runs(root)\n\n    print("\\n[6/7] Discussion Validation (Reference)")\n    print("-" * 40)\n    total_issues += check_discussions(root)\n\n    print("\\n[7/7] Brief Validation")\n    print("-" * 40)\n    total_issues += check_briefs(root)\n\n    print("\\n" + "=" * 60)\n    if total_issues == 0:\n        print("  [OK] All checks passed!")\n    else:\n        print(f"  [!] Total issues found: {total_issues}")\n\n\n# ============================================================================\n# MAIN\n# ============================================================================\n')
    __stickytape_write_module('core/automation.py', b'from __future__ import annotations\n\nimport re\nimport shutil\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional, Tuple\n\nfrom core.config import REQ_ID_PATTERN, ROOT_DIR, TEMPLATE_VERSION\n\nMETA_RE = re.compile(r"> \\*\\*(.+?)\\*\\*:\\s*(.+)")\nAFFECTED_LINE_RE = re.compile(r"^\\s*-\\s*\\*{0,2}(Modify|Create|Delete|Read)\\*{0,2}\\s*:\\s*(.+)$", re.I)\nMD_LINK_RE = re.compile(r"\\[[^\\]]+\\]\\(([^)]+)\\)")\n\n\n\nclass Board:\n    """Handler for 01_PROJECT_BOARD.md updates."""\n    def __init__(self, root: Path):\n        self.path = root / "01_PROJECT_BOARD.md"\n        if not self.path.exists() and (root.parent / "01_PROJECT_BOARD.md").exists():\n            self.path = root.parent / "01_PROJECT_BOARD.md"\n\n    def _read_lines(self) -> List[str]:\n        if not self.path.exists(): return []\n        return self.path.read_text(encoding="utf-8").splitlines()\n\n    def _write_lines(self, lines: List[str]) -> None:\n        self.path.write_text("\\n".join(lines) + "\\n", encoding="utf-8")\n\n    def add_to_queue(self, item_id: str, summary: str) -> None:\n        lines = self._read_lines()\n        new_lines = []\n        in_section = False\n        inserted = False\n        entry = f"- `{item_id}` - {summary}"\n\n        for line in lines:\n            if line.startswith("## Queue"):\n                in_section = True\n                new_lines.append(line)\n                continue\n            if in_section and line.startswith("## "):\n                if not inserted:\n                    new_lines.append(entry)\n                    inserted = True\n                in_section = False\n            if in_section and "(Empty)" in line:\n                continue\n            new_lines.append(line)\n        \n        if in_section and not inserted:\n            new_lines.append(entry)\n            \n        self._write_lines(new_lines)\n\n    def promote_to_active(self, brief_id: str, run_id: str) -> None:\n        lines = self._read_lines()\n        summary = "Implementation"\n        # 1. Remove from Queue\n        temp_lines = []\n        for line in lines:\n            if f"`{brief_id}`" in line:\n                parts = line.split(" - ", 1)\n                if len(parts) > 1: summary = parts[1]\n                continue\n            temp_lines.append(line)\n        \n        # 2. Add to Active\n        final_lines = []\n        in_section = False\n        inserted = False\n        entry = f"- `{run_id}` - {summary}"\n\n        for line in temp_lines:\n            if line.startswith("## Active"):\n                in_section = True\n                final_lines.append(line)\n                continue\n            if in_section and line.startswith("## "):\n                if not inserted:\n                    final_lines.append(entry)\n                    inserted = True\n                in_section = False\n            if in_section and "(Empty)" in line:\n                continue\n            final_lines.append(line)\n\n        if in_section and not inserted:\n            final_lines.append(entry)\n        \n        self._write_lines(final_lines)\n\n    def complete_task(self, run_id: str) -> None:\n        lines = self._read_lines()\n        summary = "Completed"\n        # 1. Remove from Active\n        temp_lines = []\n        for line in lines:\n            if f"`{run_id}`" in line:\n                parts = line.split(" - ", 1)\n                if len(parts) > 1: summary = parts[1]\n                continue\n            temp_lines.append(line)\n\n        # 2. Add to Completed\n        final_lines = []\n        in_section = False\n        inserted = False\n        entry = f"- `{run_id}` - {summary}"\n\n        for line in temp_lines:\n            if line.startswith("## Completed"):\n                in_section = True\n                final_lines.append(line)\n                continue\n            if in_section and line.startswith("## "):\n                if not inserted:\n                    final_lines.append(entry)\n                    inserted = True\n                in_section = False\n            if in_section and "(Empty)" in line:\n                continue\n            final_lines.append(line)\n\n        if in_section and not inserted:\n            final_lines.append(entry)\n        \n        self._write_lines(final_lines)\n\nclass Automator:\n    """Automation engine for MCP pipelines."""\n\n    def __init__(self, root: Optional[str] = None):\n        self.root = Path(root or ROOT_DIR)\n        self.req_dir = self.root / "02_REQUIREMENTS" / "capabilities"\n        self.spec_dir = self.root / "03_TECH_SPECS" / "architecture"\n        self.run_dir = self.root / "04_TASK_LOGS" / "active"\n        self.archive_dir = self.root / "04_TASK_LOGS" / "archive"\n        self.disc_dir = self.root / "02_REQUIREMENTS" / "discussions"\n        self.brief_dir = self.disc_dir / "briefs"\n        self.last_error: Optional[str] = None\n\n    def _req_path(self, req_id: str) -> Path:\n        return self.req_dir / f"{req_id}.md"\n\n    def _parse_metadata(self, text: str) -> Dict[str, str]:\n        metadata: Dict[str, str] = {}\n        for line in text.splitlines():\n            match = META_RE.match(line.strip())\n            if not match:\n                continue\n            key, value = match.groups()\n            metadata[key] = value.strip()\n        return metadata\n\n    def _req_parts(self, req_id: str) -> Optional[Dict[str, str]]:\n        match = REQ_ID_PATTERN.match(req_id)\n        if not match:\n            return None\n        domain, index = match.groups()\n        return {"domain": domain, "index": index}\n\n    def _format_run_id(self, req_id: str) -> str:\n        parts = self._req_parts(req_id)\n        if not parts:\n            return f"RUN-{req_id}-step-01"\n        return f"RUN-REQ-{parts[\'domain\']}-{parts[\'index\']}-step-01"\n\n    def _now_date(self) -> str:\n        return datetime.utcnow().date().isoformat()\n\n    def _parse_bool(self, value: Optional[str]) -> bool:\n        if value is None:\n            return False\n        return value.strip().lower() in {"true", "yes", "1", "y"}\n\n    def _requires_spec(self, req_id: str) -> bool:\n        metadata = self._parse_metadata(self._req_path(req_id).read_text(encoding="utf-8"))\n        return self._parse_bool(metadata.get("Requires-Spec"))\n\n    def _update_meta_line(self, text: str, key: str, value: str) -> str:\n        pattern = re.compile(rf"^>\\s*\\*\\*{re.escape(key)}\\*\\*:\\s*.*$", re.MULTILINE)\n        line = f"> **{key}**: {value}"\n        if pattern.search(text):\n            return pattern.sub(line, text)\n        lines = text.splitlines()\n        insertion = None\n        for i, ln in enumerate(lines):\n            if ln.strip().startswith("> **"):\n                insertion = i + 1\n                break\n        if insertion is not None:\n            lines.insert(insertion, line)\n            return "\\n".join(lines)\n        return line + "\\n" + text\n\n    def validate_req(self, req_id: str) -> bool:\n        report = self.req_status(req_id)\n        self.last_error = "; ".join(report["blocking_issues"]) if not report["readiness"] else None\n        return report["readiness"]\n\n    def req_status(self, req_id: str) -> Dict[str, Any]:\n        """Inspect REQ readiness without executing pipeline."""\n        issues = []\n        metadata: Dict[str, str] = {}\n        path = self._req_path(req_id)\n        if not path.exists():\n            issues.append(f"REQ not found: {req_id}")\n            return {\n                "status": None,\n                "metadata": {},\n                "readiness": False,\n                "blocking_issues": issues,\n            }\n        if not self._req_parts(req_id):\n            issues.append(f"Invalid REQ ID format: {req_id}")\n        metadata = self._parse_metadata(path.read_text(encoding="utf-8"))\n        status = metadata.get("Status", "")\n        if status.lower() != "active":\n            issues.append(f"REQ is not Active (status={status or \'missing\'})")\n        readiness = len(issues) == 0\n        return {\n            "status": status or None,\n            "metadata": metadata,\n            "readiness": readiness,\n            "blocking_issues": issues,\n        }\n\n    def _spec_content(self, req_id: str) -> str:\n        metadata = self._parse_metadata(self._req_path(req_id).read_text(encoding="utf-8"))\n        title = metadata.get("Title", req_id)\n        return (\n            f"# [SPEC-{req_id}] {title} Implementation\\n\\n"\n            f"> **ID**: SPEC-{req_id}\\n"\n            f"> **Related-REQ**: {req_id}\\n"\n            "> **Status**: Draft\\n"\n            f"> **Template-Version**: {TEMPLATE_VERSION}\\n\\n"\n            "## Purpose\\n"\n            f"This spec captures how we intend to implement {req_id}.\\n\\n"\n            "## Design Summary\\n"\n            " - TODO: capture key decisions\\n\\n"\n            "## Verification\\n"\n            " - RUN document covers the validation gates.\\n"\n        )\n\n    def create_spec_draft(self, req_id: str, dry_run: bool = False) -> Path:\n        """Create a lightweight spec draft in 03_TECH_SPECS/architecture."""\n        req_path = self._req_path(req_id)\n        if not req_path.exists():\n            raise FileNotFoundError(f"REQ missing: {req_id}")\n        self.spec_dir.mkdir(parents=True, exist_ok=True)\n        spec_path = self.spec_dir / f"SPEC-{req_id}.md"\n        if dry_run:\n            return spec_path\n        spec_path.write_text(self._spec_content(req_id), encoding="utf-8")\n        return spec_path\n\n    def _run_content(self, run_id: str, req_id: str, spec_ref: str) -> str:\n        return (\n            f"# [{run_id}] Implement {req_id}\\n\\n"\n            f"> **ID**: {run_id}\\n"\n            "> **Status**: Active\\n"\n            f"> **Started**: {self._now_date()}\\n"\n            f"> **Input**: {req_id}\\n"\n            "> **Verification**: apply_req pipeline\\n"\n            f"> **Template-Version**: {TEMPLATE_VERSION}\\n\\n"\n            "## Objective (\xeb\xaa\xa9\xed\x91\x9c)\\n"\n            "Deliver the change described in the authority document.\\n\\n"\n            "## Scope (\xeb\xb2\x94\xec\x9c\x84)\\n"\n            "### In Scope\\n"\n            "- Implementation and validation steps referenced from the REQ.\\n\\n"\n            "### Out of Scope\\n"\n            "- Anything not already described in the authority doc.\\n\\n"\n            "## Steps (\xeb\x8b\xa8\xea\xb3\x84)\\n"\n            "1. Analyze current code.\\n"\n            "2. Implement the requested behavior.\\n"\n            "3. Run validation gates (`python memory_manager.py --doctor`).\\n\\n"\n            "## Verification (Self-Check)\\n"\n            "- [ ] Tests\\n"\n            "- [ ] Boundaries\\n"\n            "- [ ] Spec reference\\n\\n"\n            "## Output (\xea\xb2\xb0\xea\xb3\xbc\xeb\xac\xbc)\\n"\n            f"- RUN references spec draft: {spec_ref}\\n"\n        )\n\n    def create_run(\n        self, req_id: str, spec_path: Optional[Path] = None, dry_run: bool = False\n    ) -> Path:\n        """Create a RUN in 04_TASK_LOGS/active matching the REQ."""\n        self.run_dir.mkdir(parents=True, exist_ok=True)\n        run_id = self._format_run_id(req_id)\n        run_path = self.run_dir / f"{run_id}.md"\n        spec_ref = spec_path.name if spec_path else "n/a"\n        if dry_run:\n            return run_path\n        run_path.write_text(self._run_content(run_id, req_id, spec_ref), encoding="utf-8")\n        return run_path\n\n    def finish(self, run_id: str, success: bool = True, git_hash: str = "") -> Path:\n        """Finalize a RUN by updating status and recording evidence.\n\n        RUN remains in active/ (no archive move per v3.4 policy).\n\n        Args:\n            run_id: The RUN document ID\n            success: Whether the run was successful\n            git_hash: Git commit hash as evidence (optional, can be \'no-commit\')\n\n        Returns:\n            Path to the updated RUN document (stays in active/)\n        """\n        source = self.run_dir / f"{run_id}.md"\n        if not source.exists():\n            raise FileNotFoundError(f"RUN not found: {run_id}")\n        text = source.read_text(encoding="utf-8")\n\n        # Update metadata\n        text = self._update_meta_line(text, "Status", "Completed" if success else "Failed")\n        text = self._update_meta_line(text, "Completed", self._now_date())\n        if git_hash:\n            text = self._update_meta_line(text, "Git", git_hash)\n\n        # Add result note\n        note = "\\n## Result\\n"\n        note += "Success\\n" if success else "Failure - requires follow-up\\n"\n        if git_hash:\n            note += f"\\n**Git Evidence**: `{git_hash}`\\n"\n\n        source.write_text(text + note, encoding="utf-8")\n\n        # Archive move (v2.0: Always move completed tasks to archive)\n        # However, to support safe review, we might want to keep it briefly?\n        # User spec: "finish(run_id) -> move to archive"\n        if success:\n            archive_path = self.archive_dir / source.name\n            self.archive_dir.mkdir(parents=True, exist_ok=True)\n            shutil.move(str(source), str(archive_path))\n            source = archive_path\n            \n            # Board Update\n            Board(self.root).complete_task(run_id)\n\n        return source\n\n    def create_disc_from_failure(self, target_id: str, error_log: str) -> Path:\n        """Create a DISC entry describing the failure."""\n        self.disc_dir.mkdir(parents=True, exist_ok=True)\n        domain = target_id.split("-")[1] if "-" in target_id else "GEN"\n        suffix = datetime.utcnow().strftime("%Y%m%d%H%M%S")\n        disc_id = f"DISC-{domain}-{suffix}"\n        disc_path = self.disc_dir / f"{disc_id}.md"\n        content = (\n            f"# [{disc_id}] Automated failure for {target_id}\\n\\n"\n            f"> **ID**: {disc_id}\\n"\n            f"> **Related-REQ**: {target_id}\\n"\n            f"> **Date**: {self._now_date()}\\n\\n"\n            "## Summary\\n"\n            "Automated pipeline encountered a failure.\\n\\n"\n            "## Evidence\\n"\n            f"```\\n{error_log}\\n```\\n\\n"\n            "## Hypotheses\\n"\n            "1. Required metadata missing.\\n"\n            "2. Run template could not be created due to permissions.\\n\\n"\n            "## Fix Options\\n"\n            "- Correct metadata and rerun.\\n"\n            "- Clear the active RUN and retry.\\n\\n"\n            "## Next Steps\\n"\n            "- Review the log.\\n"\n            "- Re-run `apply_req` if content is ready.\\n"\n        )\n        disc_path.write_text(content, encoding="utf-8")\n        return disc_path\n\n    def run_report(self, run_id: str) -> Dict[str, Any]:\n        """Return a structured summary of a RUN document."""\n        run_path = self.run_dir / f"{run_id}.md"\n        if not run_path.exists():\n            candidates = list(self.archive_dir.rglob(f"{run_id}.md"))\n            if candidates:\n                run_path = candidates[0]\n            else:\n                raise FileNotFoundError(f"RUN not found: {run_id}")\n        text = run_path.read_text(encoding="utf-8")\n        metadata = self._parse_metadata(text)\n        objective = self._extract_section(text, "Objective")\n        scope = self._extract_section(text, "Scope")\n        output = self._extract_section(text, "Output")\n        artifacts = [line[2:].strip() for line in output.splitlines() if line.startswith("- ")]\n        return {\n            "run_id": run_id,\n            "path": str(run_path),\n            "status": metadata.get("Status"),\n            "objective": objective.strip() if objective else None,\n            "scope": scope.strip() if scope else None,\n            "validation_state": metadata.get("Verification"),\n            "artifacts": artifacts,\n        }\n\n    def _extract_section(self, text: str, heading: str) -> str:\n        pattern = re.compile(rf"^##\\\\s+{re.escape(heading)}(?:.*)?$", re.M)\n        match = pattern.search(text)\n        if not match:\n            return ""\n        start = match.end()\n        next_heading = re.search(r"^##\\\\s+", text[start:], re.M)\n        end = start + next_heading.start() if next_heading else len(text)\n        return text[start:end].strip()\n\n    def apply_req(\n        self, req_id: str, dry_run: bool = False, create_spec: Optional[object] = "auto"\n    ) -> Dict[str, Any]:\n        """Orchestrate the pipeline and return a report. Note: Deprecated in v3.4.0."""\n        print(f"Warning: apply_req() is deprecated. Use plan_from_brief() for new workflows.")\n        report: Dict[str, Any] = {\n            "req_id": req_id,\n            "dry_run": dry_run,\n            "status": "started",\n            "artifacts": {},\n            "errors": [],\n            "disc": None,\n        }\n        try:\n            from core.checks import check_links, check_requirements, lint_metadata\n\n            errors = []\n            if not self.validate_req(req_id):\n                errors.append(self.last_error or "Validation failed")\n            lint_issues = lint_metadata(ROOT_DIR)\n            if lint_issues > 0:\n                errors.append(f"{lint_issues} lint issue(s) found")\n            req_issues = check_requirements(ROOT_DIR)\n            if req_issues > 0:\n                errors.append(f"{req_issues} requirement issue(s) found")\n            link_issues = check_links(ROOT_DIR)\n            if link_issues > 0:\n                errors.append(f"{link_issues} link issue(s) found")\n\n            if errors:\n                raise ValueError("; ".join(errors))\n\n            create_spec_mode = create_spec\n            if isinstance(create_spec_mode, str) and create_spec_mode.lower() == "auto":\n                create_spec_mode = self._requires_spec(req_id)\n            if create_spec_mode not in (True, False):\n                create_spec_mode = True\n\n            if dry_run:\n                spec_path = (\n                    self.spec_dir / f"SPEC-{req_id}.md" if create_spec_mode else None\n                )\n                run_path = self.run_dir / f"{self._format_run_id(req_id)}.md"\n                report["status"] = "planned"\n                report["artifacts"] = {\n                    "spec_path": str(spec_path) if spec_path else None,\n                    "run_path": str(run_path),\n                }\n                return report\n            spec = (\n                self.create_spec_draft(req_id, dry_run=False)\n                if create_spec_mode\n                else None\n            )\n            run_path = self.create_run(req_id, spec_path=spec, dry_run=False)\n            report["status"] = "created"\n            report["artifacts"] = {\n                "spec_path": str(spec) if spec else None,\n                "run_path": str(run_path),\n            }\n            return report\n        except Exception as exc:\n            err = str(exc)\n            report["status"] = "failed"\n            report["errors"].append(err)\n            disc = self.create_disc_from_failure(req_id, err)\n            report["disc"] = str(disc)\n            return report\n\n    def create_disc_from_context(self, context: Dict[str, Any]) -> Path:\n        target_id = (\n            context.get("req_id")\n            or context.get("target_id")\n            or context.get("id")\n            or "REQ-GEN-000"\n        )\n        lines = []\n        if context.get("stage"):\n            lines.append(f"Stage: {context[\'stage\']}")\n        if context.get("errors"):\n            lines.append("Errors:")\n            for item in context["errors"]:\n                if isinstance(item, dict):\n                    msg = item.get("message") or item.get("type") or str(item)\n                else:\n                    msg = str(item)\n                lines.append(f"- {msg}")\n        if context.get("rules"):\n            lines.append("Rules:")\n            for rule in context["rules"]:\n                lines.append(f"- {rule}")\n        if context.get("files"):\n            lines.append("Files:")\n            for file_path in context["files"]:\n                lines.append(f"- {file_path}")\n        if context.get("logs"):\n            lines.append("Logs:")\n            lines.append(str(context["logs"]))\n        error_log = "\\n".join(lines) if lines else "No additional context provided."\n        return self.create_disc_from_failure(str(target_id), error_log)\n\n    def _generate_brief_id(self, domain: str = "GEN") -> str:\n        """Generate a unique BRIEF ID."""\n        # Simple incremental logic: scan existing briefs\n        existing = list(self.brief_dir.glob(f"BRIEF-{domain}-*.md"))\n        max_idx = 0\n        for p in existing:\n            match = re.search(r"-(\\d{3})\\.md$", p.name)\n            if match:\n                idx = int(match.group(1))\n                if idx > max_idx:\n                    max_idx = idx\n        new_idx = max_idx + 1\n        return f"BRIEF-{domain}-{new_idx:03d}"\n\n    def intake(self, description: str | List[str], domain: str = "GEN") -> Path:\n        """Create a BRIEF from a user request description or inbox files."""\n        self.brief_dir.mkdir(parents=True, exist_ok=True)\n        brief_id = self._generate_brief_id(domain)\n        date_str = self._now_date()\n        \n        if isinstance(description, list):\n            # Inbox mode\n            full_desc = []\n            for f in description:\n                fp = Path(f)\n                if fp.exists():\n                    full_desc.append(f"### File: {fp.name}\\n{fp.read_text(encoding=\'utf-8\')}")\n            desc_text = "\\n\\n".join(full_desc)\n            summary_line = f"Inbox Intake ({len(description)} files)"\n        else:\n            desc_text = description\n            summary_line = description[:50].replace("\\n", " ")\n\n        content = (\n            f"# [{brief_id}] Request: {summary_line}...\\n\\n"\n            f"> **ID**: {brief_id}\\n"\n            f"> **Date**: {date_str}\\n"\n            f"> **Status**: Active\\n"\n            f"> **Template-Version**: {TEMPLATE_VERSION}\\n\\n"\n            "## 1. User Request (\xec\x9b\x90\xeb\xb3\xb8 \xec\x9a\x94\xec\xb2\xad)\\n"\n            f"{desc_text}\\n\\n"\n            "## 2. Intent Summary (\xec\x9d\x98\xeb\x8f\x84 \xec\x9a\x94\xec\x95\xbd)\\n"\n            "> \xe2\x9a\xa0\xef\xb8\x8f **LLM \xec\x9e\x91\xec\x97\x85**: \xec\x95\x84\xeb\x9e\x98 \xec\x9b\x90\xeb\xb3\xb8 \xec\x9a\x94\xec\xb2\xad\xec\x9d\x98 \xed\x95\xb5\xec\x8b\xac \xec\x9d\x98\xeb\x8f\x84\xeb\xa5\xbc \xeb\xb6\x84\xec\x84\x9d\xed\x95\x98\xec\x84\xb8\xec\x9a\x94.\\n\\n"\n            "- **\xec\xa3\xbc\xec\x9a\x94 \xeb\xaa\xa9\xed\x91\x9c**: (TBD - LLM\xec\x9d\xb4 \xeb\xb6\x84\xec\x84\x9d)\\n"\n            "- **\xed\x95\xb4\xea\xb2\xb0\xed\x95\xa0 \xeb\xac\xb8\xec\xa0\x9c**: (TBD - LLM\xec\x9d\xb4 \xeb\xb6\x84\xec\x84\x9d)\\n"\n            "- **CQ \xed\x98\x95\xec\x8b\x9d \xec\x9e\x85\xeb\xa0\xa5 \xed\x97\x88\xec\x9a\xa9**: \xec\xa0\x95\xeb\xa6\xac \xec\x95\x88 \xeb\x90\x9c \xec\x83\x9d\xea\xb0\x81/\xeb\xa9\x94\xeb\xaa\xa8\xeb\x8f\x84 \xea\xb0\x80\xeb\x8a\xa5\\n\\n"\n            "## 3. Affected Artifacts (\xec\x98\x81\xed\x96\xa5\xeb\xb0\x9b\xeb\x8a\x94 \xeb\xac\xb8\xec\x84\x9c)\\n"\n            "> \xe2\x9a\xa0\xef\xb8\x8f **\xeb\xb0\x98\xeb\x93\x9c\xec\x8b\x9c \xea\xb5\xac\xec\xb2\xb4\xec\xa0\x81\xec\x9d\xb8 \xea\xb2\xbd\xeb\xa1\x9c/\xeb\xa7\x81\xed\x81\xac\xeb\xa1\x9c \xec\x9e\x91\xec\x84\xb1** (REQ-XXX \xea\xb8\x88\xec\xa7\x80)  \\n"\n            "> \xec\x98\x88: `02_REQUIREMENTS/capabilities/REQ-AUTH-001.md`\\n\\n"\n            "- **Modify**: (TBD - LLM\xec\x9d\xb4 \xeb\xb6\x84\xec\x84\x9d)\\n"\n            "- **Create**: (TBD - LLM\xec\x9d\xb4 \xeb\xb6\x84\xec\x84\x9d)\\n"\n            "- **Read**: (TBD - \xec\xb0\xb8\xea\xb3\xa0 \xeb\xac\xb8\xec\x84\x9c)\\n\\n"\n            "## 4. Proposed Changes (\xeb\xb3\x80\xea\xb2\xbd \xec\xa0\x9c\xec\x95\x88)\\n"\n            "> \xe2\x9a\xa0\xef\xb8\x8f **LLM \xec\x9e\x91\xec\x97\x85**: \xea\xb5\xac\xec\xb2\xb4\xec\xa0\x81\xec\x9d\xb8 \xeb\xb3\x80\xea\xb2\xbd\xec\x82\xac\xed\x95\xad\xec\x9d\x84 \xeb\x82\x98\xec\x97\xb4\xed\x95\x98\xec\x84\xb8\xec\x9a\x94.\\n\\n"\n            "1. (TBD - \xea\xb5\xac\xec\xb2\xb4\xec\xa0\x81 \xeb\xb3\x80\xea\xb2\xbd\xec\x82\xac\xed\x95\xad)\\n\\n"\n            "## 5. Verification Criteria (\xea\xb2\x80\xec\xa6\x9d \xea\xb8\xb0\xec\xa4\x80)\\n"\n            "> \xe2\x9a\xa0\xef\xb8\x8f **LLM \xec\x9e\x91\xec\x97\x85**: \xea\xb2\x80\xec\xa6\x9d \xea\xb0\x80\xeb\x8a\xa5\xed\x95\x9c \xea\xb5\xac\xec\xb2\xb4\xec\xa0\x81 \xec\xa1\xb0\xea\xb1\xb4\xec\x9d\x84 \xec\x9e\x91\xec\x84\xb1\xed\x95\x98\xec\x84\xb8\xec\x9a\x94.\\n\\n"\n            "- [ ] (TBD - \xea\xb5\xac\xec\xb2\xb4\xec\xa0\x81 \xea\xb2\x80\xec\xa6\x9d \xec\xa1\xb0\xea\xb1\xb4)\\n"\n        )\n        \n        path = self.brief_dir / f"{brief_id}.md"\n        path.write_text(content, encoding="utf-8")\n        \n        # Board Update\n        Board(self.root).add_to_queue(brief_id, summary_line)\n        return path\n\n    def _extract_brief_section(self, text: str, heading: str) -> str:\n        pattern = re.compile(rf"^##\\s*(?:\\d+\\.)?\\s*{re.escape(heading)}(?:.*)?$", re.M)\n        match = pattern.search(text)\n        if not match:\n            return ""\n        start = match.end()\n        next_heading = re.search(r"^##\\s+", text[start:], re.M)\n        end = start + next_heading.start() if next_heading else len(text)\n        return text[start:end].strip()\n\n    def _resolve_artifact_path(self, path_str: str) -> Path:\n        path = Path(path_str)\n        if path.is_absolute():\n            full = path\n        elif path.parts and path.parts[0] == self.root.name:\n            full = self.root.parent / path\n        else:\n            full = self.root / path\n        full = full.resolve()\n        root = self.root.resolve()\n        try:\n            full.relative_to(root)\n        except ValueError as exc:\n            raise ValueError(f"Artifact path must live under {self.root.as_posix()}") from exc\n        return full\n\n    def _is_full_path(self, path_str: str) -> bool:\n        # Relaxed check: allow any path that looks like a file path\n        # Assuming relative to root if no slash, or allow it.\n        # Just check it\'s not a bare ID.\n        return "." in path_str or "/" in path_str or "\\\\" in path_str\n\n    def _is_req_path(self, path: Path) -> bool:\n        req_root = self.req_dir.resolve()\n        try:\n            path.resolve().relative_to(req_root)\n        except ValueError:\n            return False\n        return True\n\n    def _parse_affected_artifacts(self, text: str) -> List[Dict[str, str]]:\n        section = self._extract_brief_section(text, "Affected Artifacts")\n        if not section:\n            return []\n        entries: List[Dict[str, str]] = []\n        for line in section.splitlines():\n            match = AFFECTED_LINE_RE.match(line)\n            if not match:\n                continue\n            action, target = match.groups()\n            target = target.strip()\n            link_match = MD_LINK_RE.search(target)\n            target_path = link_match.group(1) if link_match else target\n            entries.append({"action": action.title(), "raw": target, "path": target_path})\n        return entries\n\n    def _create_req_stub(self, req_path: Path, req_id: str) -> None:\n        parts = self._req_parts(req_id)\n        if not parts:\n            raise ValueError(f"Invalid REQ ID format: {req_id}")\n        domain = parts["domain"]\n        req_path.parent.mkdir(parents=True, exist_ok=True)\n        content = (\n            f"# [{req_id}] (TBD)\\n\\n"\n            f"> **ID**: {req_id}\\n"\n            f"> **Domain**: {domain}\\n"\n            "> **Status**: Draft\\n"\n            f"> **Last Updated**: {self._now_date()}\\n"\n            "> **Must-Read**: RULE-ID-001, RULE-META-001\\n"\n            f"> **Template-Version**: {TEMPLATE_VERSION}\\n\\n"\n            "---\\n\\n"\n            "## Decision\\n"\n            "- (TBD)\\n\\n"\n            "## Input\\n"\n            "- (TBD)\\n\\n"\n            "## Output\\n"\n            "- (TBD)\\n\\n"\n            "## Acceptance Criteria\\n"\n            "- [ ] (TBD)\\n\\n"\n            "## Validation\\n\\n"\n            "```bash\\n"\n            "# (TBD)\\n"\n            "```\\n"\n        )\n        req_path.write_text(content, encoding="utf-8")\n\n    def _touch_req_metadata(self, req_path: Path, status: str = "Active") -> None:\n        text = req_path.read_text(encoding="utf-8")\n        text = self._update_meta_line(text, "Last Updated", self._now_date())\n        if status:\n            text = self._update_meta_line(text, "Status", status)\n        req_path.write_text(text, encoding="utf-8")\n\n    def plan(self, brief_id: str) -> Path:\n        """Create a RUN document based on a BRIEF.\n\n        This is the main planning function. Given a BRIEF ID, it:\n        1. Validates the BRIEF exists and has proper Affected Artifacts\n        2. Auto-creates/updates REQ documents as needed\n        3. Creates a RUN document for execution tracking\n\n        Args:\n            brief_id: The BRIEF document ID (e.g., "BRIEF-MCP-003")\n\n        Returns:\n            Path to the created RUN document\n        """\n        # Locate brief\n        brief_path = self.brief_dir / f"{brief_id}.md"\n        if not brief_path.exists():\n             raise FileNotFoundError(f"Brief not found: {brief_id}")\n\n        text = brief_path.read_text(encoding="utf-8")\n\n        artifacts = self._parse_affected_artifacts(text)\n        errors = []\n        if not artifacts:\n            errors.append("Affected Artifacts section is missing or empty")\n\n        req_targets: List[Tuple[str, Path]] = []\n        for entry in artifacts:\n            if not self._is_full_path(entry["path"]):\n                errors.append(f"Affected Artifacts must use full paths or links: {entry[\'raw\']}")\n                continue\n            resolved = self._resolve_artifact_path(entry["path"])\n            if self._is_req_path(resolved):\n                req_targets.append((entry["action"], resolved))\n            elif "REQ-" in entry["path"]:\n                errors.append(\n                    f"REQ must live under 02_REQUIREMENTS/capabilities: {entry[\'raw\']}"\n                )\n\n        if not req_targets:\n            errors.append("No REQ entries found in Affected Artifacts.")\n\n        if errors:\n            raise ValueError("Brief validation failed: " + "; ".join(errors))\n\n        for action_raw, req_path in req_targets:\n            action = action_raw.lower()\n            req_id = req_path.stem\n            if action == "create":\n                if req_path.exists():\n                    raise ValueError(f"REQ already exists: {req_path}")\n                self._create_req_stub(req_path, req_id)\n            elif action == "modify":\n                if not req_path.exists():\n                    raise FileNotFoundError(f"REQ not found for modify: {req_path}")\n                self._touch_req_metadata(req_path, status="Active")\n\n        # Parse Brief ID to create correlated RUN ID? \n        # Or just use the Brief ID as the RUN base?\n        # Strategy: RUN-BRIEF-[DOMAIN]-[NNN]-step-01\n        \n        # Use simple mapping for now\n        run_id = f"RUN-{brief_id}-step-01"\n        run_path = self.run_dir / f"{run_id}.md"\n        \n        if run_path.exists():\n            # If step-01 exists, maybe increment? sticking to step-01 for simplicity of this logic\n            pass\n            \n        content = (\n            f"# [{run_id}] Execution for {brief_id}\\n\\n"\n            f"> **ID**: {run_id}\\n"\n            f"> **Input**: {brief_id}\\n"\n            f"> **Status**: Active\\n"\n            f"> **Started**: {self._now_date()}\\n"\n            f"> **Verification**: `python memory_manager.py --doctor`\\n"\n            f"> **Template-Version**: {TEMPLATE_VERSION}\\n\\n"\n            "## Objective (\xeb\xaa\xa9\xed\x91\x9c)\\n"\n            f"Execute the requirements defined in {brief_id}. ({brief_id}\xec\x97\x90 \xec\xa0\x95\xec\x9d\x98\xeb\x90\x9c \xec\x9a\x94\xea\xb5\xac\xec\x82\xac\xed\x95\xad \xec\x8b\xa4\xed\x96\x89)\\n\\n"\n            "## Scope (\xeb\xb2\x94\xec\x9c\x84)\\n\\n"\n            "### In Scope\\n"\n            f"- Implement changes requested in {brief_id}\\n"\n            "- (\xec\xb6\x94\xea\xb0\x80 \xeb\xb2\x94\xec\x9c\x84\xeb\x8a\x94 BRIEF\xec\x9d\x98 Affected Artifacts\xeb\xa5\xbc \xec\xb0\xb8\xea\xb3\xa0\xed\x95\x98\xec\x97\xac \xea\xb5\xac\xec\xb2\xb4\xed\x99\x94)\\n\\n"\n            "### Out of Scope\\n"\n            "- (\xeb\xaa\x85\xec\x8b\x9c\xec\xa0\x81\xec\x9c\xbc\xeb\xa1\x9c \xec\xa0\x9c\xec\x99\xb8\xeb\x90\x98\xeb\x8a\x94 \xea\xb2\x83)\\n\\n"\n            "## Steps (\xeb\x8b\xa8\xea\xb3\x84)\\n"\n            "> \xe2\x9a\xa0\xef\xb8\x8f **LLM \xec\x9e\x91\xec\x97\x85**: BRIEF \xeb\x82\xb4\xec\x9a\xa9\xec\x9d\x84 \xeb\xb0\x98\xec\x98\x81\xed\x95\x9c \xea\xb5\xac\xec\xb2\xb4\xec\xa0\x81 \xeb\x8b\xa8\xea\xb3\x84\xeb\xa5\xbc \xec\x9e\x91\xec\x84\xb1\xed\x95\x98\xec\x84\xb8\xec\x9a\x94.\\n\\n"\n            f"- [ ] 1. Review {brief_id} details (\xeb\xb8\x8c\xeb\xa6\xac\xed\x94\x84 \xeb\x82\xb4\xec\x9a\xa9 \xea\xb2\x80\xed\x86\xa0)\\n"\n            "- [ ] 2. Implement code changes (\xec\xbd\x94\xeb\x93\x9c \xeb\xb3\x80\xea\xb2\xbd \xea\xb5\xac\xed\x98\x84)\\n"\n            f"- [ ] 3. Verify against {brief_id} goals (\xeb\xb8\x8c\xeb\xa6\xac\xed\x94\x84 \xeb\xaa\xa9\xed\x91\x9c \xea\xb2\x80\xec\xa6\x9d)\\n\\n"\n            "## Verification (Self-Check)\\n"\n            "> \xec\x9e\x91\xec\x97\x85 \xec\x99\x84\xeb\xa3\x8c \xec\xa0\x84 \xeb\xb0\x98\xeb\x93\x9c\xec\x8b\x9c \xed\x99\x95\xec\x9d\xb8\\n\\n"\n            "- [ ] **Test**: `pytest` \xeb\x98\x90\xeb\x8a\x94 \xea\xb4\x80\xeb\xa0\xa8 \xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xed\x86\xb5\xea\xb3\xbc?\\n"\n            "- [ ] **Boundary**: CONVENTIONS Boundaries \xec\xa4\x80\xec\x88\x98?\\n"\n            f"- [ ] **Spec**: {brief_id}\xea\xb3\xbc \xec\x9d\xbc\xec\xb9\x98?\\n"\n            "- [ ] **Doctor**: `python memory_manager.py --doctor` \xed\x86\xb5\xea\xb3\xbc?\\n\\n"\n            "## Evidence (Implementation Proof)\\n"\n            "> \xea\xb5\xac\xed\x98\x84 \xec\x99\x84\xeb\xa3\x8c \xed\x9b\x84 \xec\x9e\x91\xec\x84\xb1\\n\\n"\n            "- **Tests**: (\xed\x86\xb5\xea\xb3\xbc\xed\x95\x9c \xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8 \xed\x8c\x8c\xec\x9d\xbc/\xea\xb2\xb0\xea\xb3\xbc)\\n"\n            "- **Commands**: (\xec\x8b\xa4\xed\x96\x89\xed\x95\x9c \xeb\xaa\x85\xeb\xa0\xb9\xec\x96\xb4)\\n"\n            "- **Code**: (\xec\x83\x9d\xec\x84\xb1/\xec\x88\x98\xec\xa0\x95\xeb\x90\x9c \xed\x8c\x8c\xec\x9d\xbc)\\n"\n            "- **Logs**: (\xea\xb4\x80\xeb\xa0\xa8 \xeb\xa1\x9c\xea\xb7\xb8)\\n\\n"\n            "## Output (\xea\xb2\xb0\xea\xb3\xbc\xeb\xac\xbc)\\n"\n            f"- Implemented features from {brief_id} ({brief_id} \xea\xb8\xb0\xeb\x8a\xa5 \xea\xb5\xac\xed\x98\x84)\\n"\n            "- (\xec\x83\x9d\xec\x84\xb1/\xec\x88\x98\xec\xa0\x95\xeb\x90\x9c \xea\xb5\xac\xec\xb2\xb4\xec\xa0\x81 \xed\x8c\x8c\xec\x9d\xbc \xeb\xaa\xa9\xeb\xa1\x9d)\\n"\n        )\n        \n        run_path.write_text(content, encoding="utf-8")\n        \n        # Board Update\n        Board(self.root).promote_to_active(brief_id, run_id)\n        return run_path\n\n    # Aliases for backward compatibility\n    def plan_from_brief(self, brief_id: str) -> Path:\n        """Alias for plan() - kept for backward compatibility."""\n        return self.plan(brief_id)\n\n    def finalize_run(self, run_id: str, success: bool = True, git_hash: str = "") -> Path:\n        """Alias for finish() - kept for backward compatibility."""\n        return self.finish(run_id, success, git_hash)\n')
    __stickytape_write_module('core/status.py', b'\nimport os\nfrom datetime import datetime\n\ndef status_report(root: str, show_recent: int = 5) -> int:\n    """Report on active tasks and knowledge base."""\n    print("\\n=== Status Report ===")\n\n    # Count active tasks\n    active_dir = os.path.join(root, "04_TASK_LOGS", "active")\n    active_tasks: list[tuple[str, float]] = []\n    if os.path.isdir(active_dir):\n        for f in os.listdir(active_dir):\n            if f.endswith(".md") and f != "README.md":\n                fpath = os.path.join(active_dir, f)\n                mtime = os.path.getmtime(fpath)\n                active_tasks.append((f, mtime))\n\n    active_tasks.sort(key=lambda x: x[1], reverse=True)\n\n    # Count archived tasks\n    archive_dir = os.path.join(root, "04_TASK_LOGS", "archive")\n    archive_count = 0\n    if os.path.isdir(archive_dir):\n        for root_dir, dirs, files in os.walk(archive_dir):\n            for f in files:\n                if f.endswith(".md") and f != "README.md":\n                    archive_count += 1\n\n    # Count by type\n    req_count = 0\n    rule_count = 0\n    cq_count = 0\n    disc_count = 0\n\n    for scan_dir in ["02_REQUIREMENTS/capabilities"]:\n        req_path = os.path.join(root, scan_dir)\n        if os.path.isdir(req_path):\n            for f in os.listdir(req_path):\n                if f.endswith(".md") and f != "README.md":\n                    req_count += 1\n\n    for scan_dir in ["02_REQUIREMENTS/invariants"]:\n        rule_path = os.path.join(root, scan_dir)\n        if os.path.isdir(rule_path):\n            for f in os.listdir(rule_path):\n                if f.endswith(".md") and f != "README.md":\n                    rule_count += 1\n\n    for scan_dir in ["02_REQUIREMENTS/competencies"]:\n        cq_path = os.path.join(root, scan_dir)\n        if os.path.isdir(cq_path):\n            for f in os.listdir(cq_path):\n                if f.endswith(".md") and f != "README.md":\n                    cq_count += 1\n\n    disc_path = os.path.join(root, "02_REQUIREMENTS", "discussions")\n    if os.path.isdir(disc_path):\n        for f in os.listdir(disc_path):\n            if f.endswith(".md") and f != "README.md":\n                disc_count += 1\n\n    # Knowledge articles\n    knowledge_dir = os.path.join(root, "98_KNOWLEDGE")\n    knowledge_count = 0\n    if os.path.isdir(knowledge_dir):\n        for root_dir, dirs, files in os.walk(knowledge_dir):\n            for f in files:\n                if f.endswith(".md") and f != "README.md":\n                    knowledge_count += 1\n\n    print(f"\\n  [Active RUN Tasks]: {len(active_tasks)}")\n    if active_tasks and show_recent > 0:\n        print(f"    Recent (top {min(show_recent, len(active_tasks))}):")\n        for task, mtime in active_tasks[:show_recent]:\n            dt = datetime.fromtimestamp(mtime)\n            print(f"      - {task} (modified: {dt.strftime(\'%Y-%m-%d %H:%M\')})")\n\n    print(f"\\n  [Archived Tasks]: {archive_count}")\n    print(f"\\n  [Authority Documents]:")\n    print(f"    - Capabilities (REQ): {req_count}")\n    print(f"    - Invariants (RULE): {rule_count}")\n    print(f"    - Competencies (CQ): {cq_count}")\n    print(f"    - Discussions: {disc_count}")\n    print(f"\\n  [Knowledge Articles]: {knowledge_count}")\n\n    return 0\n\n\ndef list_runs(root: str, status_filter: str = None, limit: int = 20) -> int:\n    """List RUN documents with optional status filtering.\n\n    Args:\n        root: Memory root directory\n        status_filter: Filter by status (active, completed, failed, all)\n        limit: Maximum number of RUNs to show\n\n    Returns:\n        0 on success\n    """\n    import re\n\n    active_dir = os.path.join(root, "04_TASK_LOGS", "active")\n    runs = []\n\n    if not os.path.isdir(active_dir):\n        print("No active directory found.")\n        return 0\n\n    # Parse RUN metadata\n    status_re = re.compile(r\'>\\s*\\*\\*Status\\*\\*:\\s*(\\w+)\', re.I)\n    started_re = re.compile(r\'>\\s*\\*\\*Started\\*\\*:\\s*([\\d-]+)\', re.I)\n    git_re = re.compile(r\'>\\s*\\*\\*Git\\*\\*:\\s*([^\\n]+)\', re.I)\n    summary_re = re.compile(r\'>\\s*\\*\\*Summary\\*\\*:\\s*([^\\n]+)\', re.I)\n\n    for f in os.listdir(active_dir):\n        if not f.endswith(".md") or f == "README.md":\n            continue\n\n        fpath = os.path.join(active_dir, f)\n        try:\n            with open(fpath, \'r\', encoding=\'utf-8\') as fp:\n                text = fp.read()\n        except:\n            continue\n\n        run_id = os.path.splitext(f)[0]\n\n        # Extract metadata\n        status_match = status_re.search(text)\n        status = status_match.group(1) if status_match else "Unknown"\n\n        started_match = started_re.search(text)\n        started = started_match.group(1) if started_match else "N/A"\n\n        git_match = git_re.search(text)\n        git = git_match.group(1).strip() if git_match else "-"\n\n        summary_match = summary_re.search(text)\n        summary = summary_match.group(1).strip()[:40] if summary_match else "-"\n\n        mtime = os.path.getmtime(fpath)\n\n        runs.append({\n            \'id\': run_id,\n            \'status\': status,\n            \'started\': started,\n            \'git\': git[:12] if git != "-" else git,\n            \'summary\': summary,\n            \'mtime\': mtime\n        })\n\n    # Sort by modification time (most recent first)\n    runs.sort(key=lambda x: x[\'mtime\'], reverse=True)\n\n    # Filter by status\n    if status_filter and status_filter.lower() != \'all\':\n        filter_status = status_filter.lower()\n        runs = [r for r in runs if r[\'status\'].lower() == filter_status]\n\n    # Limit results\n    runs = runs[:limit]\n\n    # Print results\n    print(f"\\n{\'=\'*80}")\n    print(f"RUN Documents" + (f" (Status: {status_filter})" if status_filter else " (All)"))\n    print(f"{\'=\'*80}")\n\n    if not runs:\n        print("No RUN documents found.")\n        return 0\n\n    # Table header\n    print(f"{\'Status\':<12} {\'Started\':<12} {\'Git\':<14} {\'RUN ID\'}")\n    print(f"{\'-\'*12} {\'-\'*12} {\'-\'*14} {\'-\'*40}")\n\n    for run in runs:\n        status_icon = {"active": "[*]", "completed": "[v]", "failed": "[X]"}.get(\n            run[\'status\'].lower(), "[ ]"\n        )\n        print(f"{status_icon} {run[\'status\']:<8} {run[\'started\']:<12} {run[\'git\']:<14} {run[\'id\']}")\n\n    print(f"\\nTotal: {len(runs)} RUN(s)")\n    return 0\n')
    __stickytape_write_module('core/update.py', b'\nfrom core.config import CURRENT_VERSION, ROOT_DIR\nfrom core.migrate import is_v1_structure, is_v2_structure, migrate_v1_to_v2, migrate_v2_to_v3\nfrom utils.fs import (\n    create_missing_docs,\n    ensure_structure,\n    read_version,\n    update_onboarding_guide,\n    update_mcp_definitions,\n    update_readme_files,\n    update_system_templates,\n    update_tooling,\n    write_version,\n)\n\n\ndef init_or_update(dry_run: bool = False, force_migrate: bool = False) -> None:\n    """Initialize or update the memory system."""\n    installed_version = read_version(ROOT_DIR)\n    print(\n        f"Checking Memory System: Installed({installed_version}) "\n        f"vs Current({CURRENT_VERSION})"\n    )\n\n    # v1.x \xe2\x86\x92 v2.x migration\n    needs_v1_migration = force_migrate or (\n        installed_version.startswith("1.") and is_v1_structure(ROOT_DIR)\n    )\n\n    if needs_v1_migration:\n        print("\\n[!] Detected v1.x structure. Migration required.")\n        migrate_v1_to_v2(ROOT_DIR, dry_run=dry_run)\n\n    # v2.x \xe2\x86\x92 v3.0 migration (features/business_rules \xe2\x86\x92 capabilities/invariants)\n    needs_v2_migration = is_v2_structure(ROOT_DIR)\n    \n    if needs_v2_migration:\n        print("\\n[!] Detected v2.x structure. Migration to v3.0 required.")\n        migrate_v2_to_v3(ROOT_DIR, dry_run=dry_run)\n\n    ensure_structure(ROOT_DIR)\n    create_missing_docs(ROOT_DIR, dry_run=dry_run)\n    update_system_templates(ROOT_DIR, dry_run=dry_run)\n    update_onboarding_guide(ROOT_DIR, dry_run=dry_run)\n    update_readme_files(ROOT_DIR, dry_run=dry_run)\n    update_mcp_definitions(ROOT_DIR, dry_run=dry_run)\n    update_tooling(ROOT_DIR, dry_run=dry_run)\n\n    if installed_version != CURRENT_VERSION:\n        write_version(ROOT_DIR, dry_run=dry_run)\n        if dry_run:\n            print(f"\\nWould update to v{CURRENT_VERSION}")\n        else:\n            print(f"\\n[OK] Updated to v{CURRENT_VERSION}")\n    else:\n        print("\\n[OK] Already up to date.")\n\n\n# ============================================================================\n# VALIDATION FUNCTIONS\n# ============================================================================\n')
    __stickytape_write_module('core/migrate.py', b'\nimport os\nimport shutil\n\nfrom core.config import LEGACY_DIRS_TO_ARCHIVE, MIGRATION_MAP_V1, MIGRATION_MAP_V2_TO_V3\nfrom utils.fs import safe_move\n\n\ndef migrate_v1_to_v2(root: str, dry_run: bool = False) -> None:\n    """Migrate from v1.x structure to v2.x structure."""\n    archive_dir = os.path.join(root, "99_ARCHIVE", "v1_migration")\n    print("\\n=== Migrating v1.x -> v2.x ===")\n\n    for old_rel, new_rel in MIGRATION_MAP_V1.items():\n        old_path = os.path.join(root, old_rel)\n        if not os.path.exists(old_path):\n            continue\n\n        if new_rel is None:\n            archive_path = os.path.join(archive_dir, old_rel)\n            if dry_run:\n                print(f"  - Would archive: {old_rel}")\n            else:\n                if safe_move(old_path, archive_path):\n                    print(f"  * Archived: {old_rel}")\n        else:\n            new_path = os.path.join(root, new_rel)\n            if dry_run:\n                print(f"  - Would move: {old_rel} -> {new_rel}")\n            else:\n                if safe_move(old_path, new_path):\n                    print(f"  * Moved: {old_rel} -> {new_rel}")\n\n    for legacy_dir in LEGACY_DIRS_TO_ARCHIVE:\n        legacy_path = os.path.join(root, legacy_dir)\n        if os.path.isdir(legacy_path):\n            archive_path = os.path.join(archive_dir, legacy_dir)\n            if dry_run:\n                print(f"  - Would archive directory: {legacy_dir}")\n            else:\n                if not os.path.exists(archive_path):\n                    shutil.move(legacy_path, archive_path)\n                    print(f"  * Archived and removed: {legacy_dir}")\n                else:\n                    shutil.rmtree(legacy_path)\n                    print(f"  * Removed legacy (already archived): {legacy_dir}")\n\n\ndef migrate_v2_to_v3(root: str, dry_run: bool = False) -> None:\n    """Migrate from v2.x structure to v3.0 structure (capabilities & invariants)."""\n    print("\\n=== Migrating v2.x -> v3.0 (Capabilities & Invariants) ===")\n    \n    migrated = False\n    for old_rel, new_rel in MIGRATION_MAP_V2_TO_V3.items():\n        old_path = os.path.join(root, old_rel)\n        new_path = os.path.join(root, new_rel)\n        \n        if not os.path.exists(old_path):\n            continue\n        \n        if not os.path.isdir(old_path):\n            continue\n        \n        # Move all files from old to new (merge if target exists)\n        files_moved = 0\n        for item in os.listdir(old_path):\n            src = os.path.join(old_path, item)\n            dst = os.path.join(new_path, item)\n            \n            if os.path.exists(dst):\n                if dry_run:\n                    print(f"  - Would skip (exists): {old_rel}/{item}")\n                else:\n                    print(f"  ! Skipped (exists): {old_rel}/{item}")\n                continue\n            \n            if dry_run:\n                print(f"  - Would move: {old_rel}/{item} -> {new_rel}/{item}")\n                files_moved += 1\n            else:\n                # Ensure target directory exists (only when actually moving)\n                os.makedirs(new_path, exist_ok=True)\n                shutil.move(src, dst)\n                print(f"  * Moved: {old_rel}/{item} -> {new_rel}/{item}")\n                files_moved += 1\n        \n        # Remove old directory if empty or only README.md remains\n        if not dry_run and os.path.exists(old_path):\n            remaining = os.listdir(old_path)\n            if not remaining:\n                os.rmdir(old_path)\n                print(f"  * Removed empty: {old_rel}/")\n            elif remaining == ["README.md"]:\n                # README.md will be regenerated in new folder, safe to delete\n                os.remove(os.path.join(old_path, "README.md"))\n                os.rmdir(old_path)\n                print(f"  * Removed old: {old_rel}/ (README.md only)")\n            else:\n                print(f"  ! Old folder not empty: {old_rel}/ ({len(remaining)} items remain)")\n        \n        if files_moved > 0:\n            migrated = True\n    \n    if not migrated and not dry_run:\n        print("  (No v2.x files to migrate)")\n\n\ndef is_v1_structure(root: str) -> bool:\n    """Check if the current structure is v1.x"""\n    v1_markers = [\n        os.path.join(root, "02_SERVICES"),\n        os.path.join(root, "03_MANAGEMENT"),\n        os.path.join(root, "90_TOOLING"),\n    ]\n    return any(os.path.exists(m) for m in v1_markers)\n\n\ndef is_v2_structure(root: str) -> bool:\n    """Check if the current structure is v2.x (has features/business_rules)"""\n    v2_markers = [\n        os.path.join(root, "02_REQUIREMENTS", "features"),\n        os.path.join(root, "02_REQUIREMENTS", "business_rules"),\n    ]\n    return any(os.path.exists(m) for m in v2_markers)\n')
    __stickytape_write_module('core/reverse.py', b'\nimport os\nfrom pathlib import Path\nfrom typing import List\n\nfrom core.config import ROOT_DIR\n\nREVERSE_PROMPT_TEMPLATE = """# \xf0\x9f\xa7\xa9 Partial Reverse Engineering Request\n\n> **Focus Area**: `{focus_path}`\n\n## 1. Instructions\n\xeb\x8b\xb9\xec\x8b\xa0\xec\x9d\x80 \xed\x98\x84\xec\x9e\xac \xea\xb1\xb0\xeb\x8c\x80\xed\x95\x9c \xec\x8b\x9c\xec\x8a\xa4\xed\x85\x9c\xec\x9d\x98 **\xec\x9d\xbc\xeb\xb6\x80 \xeb\xaa\xa8\xeb\x93\x88(`{focus_path}`)**\xeb\xa7\x8c\xec\x9d\x84 \xeb\xb3\xb4\xea\xb3\xa0 \xec\x9e\x88\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4.\n\xec\xa0\x84\xec\xb2\xb4 \xec\x8b\x9c\xec\x8a\xa4\xed\x85\x9c\xec\x9d\x84 \xeb\x8b\xa4 \xec\x95\x8c\xec\xa7\x80 \xeb\xaa\xbb\xed\x95\x98\xeb\xaf\x80\xeb\xa1\x9c, \xeb\xaa\xa8\xeb\xa5\xb4\xeb\x8a\x94 \xeb\xb6\x80\xeb\xb6\x84\xec\x9d\x80 \xec\x84\xa3\xeb\xb6\x88\xeb\xa6\xac \xea\xb0\x80\xec\xa0\x95\xed\x95\x98\xec\xa7\x80 \xeb\xa7\x90\xea\xb3\xa0 **\xed\x98\x84\xec\x9e\xac \xec\xbd\x94\xeb\x93\x9c \xeb\x82\xb4\xec\x9d\x98 \xeb\xa1\x9c\xec\xa7\x81\xec\x97\x90\xeb\xa7\x8c \xec\xa7\x91\xec\xa4\x91**\xed\x95\x98\xec\x84\xb8\xec\x9a\x94.\n\n## 2. Existing Knowledge (Context)\n\xed\x98\x84\xec\x9e\xac \xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8\xec\x97\x90\xeb\x8a\x94 \xec\x9d\xb4\xeb\xaf\xb8 \xeb\x8b\xa4\xec\x9d\x8c \xeb\xac\xb8\xec\x84\x9c\xeb\x93\xa4\xec\x9d\xb4 \xec\xa0\x95\xec\x9d\x98\xeb\x90\x98\xec\x96\xb4 \xec\x9e\x88\xec\x8a\xb5\xeb\x8b\x88\xeb\x8b\xa4. \n**\xea\xb8\xb0\xec\xa1\xb4 \xea\xb7\x9c\xec\xb9\x99\xec\x9d\x84 \xec\xa4\x80\xec\x88\x98\xed\x95\x98\xea\xb3\xa0, \xec\xa4\x91\xeb\xb3\xb5\xeb\x90\x9c \xeb\xac\xb8\xec\x84\x9c\xeb\xa5\xbc \xec\x83\x9d\xec\x84\xb1\xed\x95\x98\xec\xa7\x80 \xeb\xa7\x88\xec\x84\xb8\xec\x9a\x94.**\n\n### Existing Rules (Business Rules)\n{existing_rules}\n\n### Existing Features (Requirements)\n{existing_reqs}\n\n## 3. Analysis Strategy\n1. **Local Rules**: \xec\x9d\xb4 \xeb\xaa\xa8\xeb\x93\x88 \xeb\x82\xb4\xeb\xb6\x80\xec\x97\x90\xec\x84\x9c\xeb\xa7\x8c \xec\x93\xb0\xec\x9d\xb4\xeb\x8a\x94 \xea\xb7\x9c\xec\xb9\x99\xec\x9d\x80 `RULE-[DOMAIN]-XXX`\xeb\xa1\x9c \xec\xa0\x95\xec\x9d\x98\xed\x95\x98\xec\x84\xb8\xec\x9a\x94.\n2. **Global Rules**: \xed\x94\x84\xeb\xa1\x9c\xec\xa0\x9d\xed\x8a\xb8 \xec\xa0\x84\xeb\xb0\x98\xec\x97\x90 \xec\x93\xb0\xec\x9d\xbc \xea\xb2\x83 \xea\xb0\x99\xec\x9d\x80 \xea\xb7\x9c\xec\xb9\x99\xec\x9d\xb4 \xeb\xb3\xb4\xec\x9d\xb4\xeb\xa9\xb4, `RULE-CORE-XXX`\xeb\xa1\x9c \xec\xa0\x9c\xec\x95\x88\xed\x95\x98\xeb\x90\x98 "\xed\x99\x95\xec\x9d\xb8 \xed\x95\x84\xec\x9a\x94"\xeb\x9d\xbc\xea\xb3\xa0 \xeb\xa9\x94\xeb\xaa\xa8\xed\x95\x98\xec\x84\xb8\xec\x9a\x94.\n3. **Features**: \xea\xb0\x81 \xec\xa3\xbc\xec\x9a\x94 \xea\xb8\xb0\xeb\x8a\xa5\xec\x9d\x84 `REQ-[DOMAIN]-XXX`\xeb\xa1\x9c \xec\xa0\x95\xec\x9d\x98\xed\x95\x98\xec\x84\xb8\xec\x9a\x94.\n\n---\n\n## 4. Target Code\n(\xec\x95\x84\xeb\x9e\x98 \xec\xbd\x94\xeb\x93\x9c\xeb\x8a\x94 `{focus_path}` \xea\xb2\xbd\xeb\xa1\x9c\xec\x9d\x98 \xed\x8c\x8c\xec\x9d\xbc\xeb\x93\xa4\xec\x9e\x85\xeb\x8b\x88\xeb\x8b\xa4.)\n\n{code_content}\n"""\n\ndef get_file_list(directory: str) -> List[str]:\n    """Get list of markdown files in a directory (without extension)."""\n    if not os.path.exists(directory):\n        return ["(None)"]\n    \n    files = [\n        f for f in os.listdir(directory) \n        if f.endswith(".md") and f != "README.md"\n    ]\n    return [os.path.splitext(f)[0] for f in sorted(files)] or ["(None)"]\n\ndef read_code_files(root: str, focus_subpath: str) -> str:\n    """Read code files from the focus path."""\n    target_path = os.path.join(root, focus_subpath)\n    \n    if not os.path.exists(target_path):\n        return f"Error: Path \'{target_path}\' does not exist."\n\n    code_content = []\n    \n    # If it\'s a file\n    if os.path.isfile(target_path):\n        try:\n            with open(target_path, "r", encoding="utf-8") as f:\n                code_content.append(f"### `{focus_subpath}`\\n```python\\n{f.read()}\\n```")\n        except Exception as e:\n            code_content.append(f"Error reading {target_path}: {e}")\n            \n    # If it\'s a directory\n    elif os.path.isdir(target_path):\n        for dirpath, _, filenames in os.walk(target_path):\n            for name in sorted(filenames):\n                # Simple filter: only python files, skip hidden/cache\n                if not name.endswith(".py") or name.startswith("__"):\n                    continue\n                    \n                full_path = os.path.join(dirpath, name)\n                rel_path = os.path.relpath(full_path, root)\n                \n                try:\n                    with open(full_path, "r", encoding="utf-8") as f:\n                        content = f.read()\n                        code_content.append(f"### `{rel_path}`\\n```python\\n{content}\\n```")\n                except Exception as e:\n                    code_content.append(f"Error reading {rel_path}: {e}")\n    \n    if not code_content:\n        return "(No Python files found in this path)"\n        \n    return "\\n\\n".join(code_content)\n\ndef generate_reverse_prompt(root: str, focus_path: str) -> None:\n    """Generate the reverse engineering prompt."""\n    print(f"\\n\xf0\x9f\x94\x8d Generating Reverse Engineering Prompt...")\n    print(f"   Focus: {focus_path}")\n    \n    # 1. Scan Context\n    # root is ".memory" folder\n    rules_dir = os.path.join(root, "02_REQUIREMENTS", "invariants")\n    reqs_dir = os.path.join(root, "02_REQUIREMENTS", "capabilities")\n    \n    existing_rules = get_file_list(rules_dir)\n    existing_reqs = get_file_list(reqs_dir)\n    \n    print(f"   Context: Found {len(existing_rules)} invariants and {len(existing_reqs)} capabilities.")\n    \n    # 2. Read Target Code\n    # Assuming root is relative ".memory", project root is current dir or parent of absolute root\n    # Since we run from project root, we can just use focus_path relative to CWD, \n    # or derive project_root from root if it is absolute.\n    # Let\'s derive safely:\n    if os.path.isabs(root):\n        project_root = os.path.dirname(root)\n    else:\n        project_root = "." # Assuming running from root\n        \n    code_content = read_code_files(project_root, focus_path)\n    \n    # 3. Generate Prompt\n    prompt = REVERSE_PROMPT_TEMPLATE.format(\n        focus_path=focus_path,\n        existing_rules="- " + "\\n- ".join(existing_rules),\n        existing_reqs="- " + "\\n- ".join(existing_reqs),\n        code_content=code_content\n    )\n    \n    output_path = os.path.join(root, "00_REVERSE_PROMPT.md")\n    with open(output_path, "w", encoding="utf-8") as f:\n        f.write(prompt)\n        \n    print(f"\xe2\x9c\x85 Generated: {output_path}")\n    print("\xf0\x9f\x93\x8b Next Step: Copy the content of 00_REVERSE_PROMPT.md to your AI Agent.\\n")\n')
    #!/usr/bin/env python3
    """
    MemoryAtlas v2.4.0 - Memory-Driven Development Tool (Context Bootstrapping)
    
    === VERSION HISTORY ===
    
    v2.0.0: Initial What-How-Log structure
    v2.1.0: Bug fixes, --doctor, template versioning
    v2.1.1: **ID**: as authority, three-way validation
    
    v2.2.0 - Authority Separation & Execution Unit:
    1. REQ split into 3 layers: DECISION (authority) / DISCUSSION / RATIONALE
    2. Must-Read field enforced in all REQ documents
    3. Execution documents split into small units (RUN-*)
    4. New folder structure: discussions/, rationale/
    5. Validation for Must-Read links
    6. RUN document format enforcement
    
    v2.2.1 - P0/P1 Fixes:
      - Fixed header regex to support H1 (#) in addition to H2/H3
      - Fixed Must-Read existence check to use regex instead of string contains
      - Added ADR existence validation (no longer skipped)
      - Expanded LINT_DIRS to include discussions and active RUNs
      - Added 3-way ID consistency check for RUN documents
      - Improved Must-Read parsing to return clean IDs (no links)
    
    v2.3.0 - Smart Spec Edition:
      - CONVENTIONS rewritten with 6 core sections + Boundaries
      - Added Commands section for explicit test/lint/run commands
      - Added Boundaries (Always/Ask First/Never) for AI behavior control
      - REQ template updated with optional Constraints & Boundaries section
      - RUN template updated with Self-Check verification checklist
      - AGENT_RULES updated to enforce Boundaries compliance
      - Enhanced AI predictability through explicit behavioral rules
    
    v2.5.0 (Current) - Reverse Engineering & Context Bootstrapping:
      - Added --reverse mode for partial code analysis (Reverse Engineering)
      - Added --focus argument for targeted analysis
      - Context Bootstrapping (v2.4) features included
      - "LLM   LLM "  
    
    === SMART SPEC MODEL ===
    
    6 Core Sections in CONVENTIONS:
      1. Commands: Test, Lint, Run commands
      2. Project Structure: Directory layout
      3. Code Style: Formatting, naming conventions
      4. Testing Strategy: Test requirements
      5. Git Workflow: Branch/commit conventions
      6. Boundaries: Always / Ask First / Never rules
    
    Boundaries (STRICT):
       Always: Actions AI must always perform
       Ask First: Actions requiring human approval
       Never: Actions AI must never perform
    
    === AUTHORITY MODEL ===
    
      (Authority Flow):
      REQ (Authority)  TECH_SPEC  CODE  RUN/LOG
    
      (Document Grades):
      - DECISION (Authority):  .  .
      - DISCUSSION: -AI  . LLM   .
      - RATIONALE/ADR:   .  .
      - EXECUTION (RUN):  . 1 + 1 + 1.
    
    === EXECUTION UNIT ===
    
      = 1  + 1   + 1 
    - RUN-REQ-AUTH-001-step-01.md
    - RUN-REQ-AUTH-001-step-02.md
    - ...
    
      :
    - Input:   ID  (P0 + Must-Read)
    - Steps: /
    - Verification:   + Self-Check
    - Output: /  
    """
    
    import argparse
    import sys
    from pathlib import Path
    
    from core.bootstrap import bootstrap_init
    from core.bootstrap_mcp import bootstrap_mcp
    from core.checks import (
        check_links,
        check_requirements,
        check_runs,
        check_structure,
        check_mcp,
        doctor,
        lint_metadata,
    )
    from core.automation import Automator
    from core.config import CURRENT_VERSION, ROOT_DIR
    from core.status import status_report, list_runs
    from core.update import init_or_update
    from core.reverse import generate_reverse_prompt
    from utils.fs import ensure_structure, update_onboarding_guide, update_onboarding_prompt
    
    def parse_args() -> "argparse.Namespace":
        parser = argparse.ArgumentParser(
            description=f"MemoryAtlas v{CURRENT_VERSION} - Memory-Driven Development Tool",
            formatter_class=argparse.RawDescriptionHelpFormatter,
            epilog="""
    Examples:
      python memory_manager.py              # Initialize/update system
      python memory_manager.py --doctor     # Run all checks
      python memory_manager.py --status     # Show task summary
      python memory_manager.py --guide      # Show onboarding guide and prompt
      python memory_manager.py --refresh-guide  # Regenerate onboarding guide from state
      python memory_manager.py --dry-run    # Preview changes
            """
        )
    
        parser.add_argument(
            "command",
            nargs="?",
            choices=["apply-req", "intake", "plan", "finish"],
            help="Optional automation command (apply-req, intake, plan, finish).",
        )
        parser.add_argument(
            "--id",
            dest="command_req_id",
            help="REQ ID for automation commands such as apply-req.",
        )
        parser.add_argument(
            "--no-spec",
            action="store_true",
            help="Skip spec draft creation when running apply-req.",
        )
        parser.add_argument(
            "--input",
            dest="input_data",
            help="Input text or file path for intake command.",
        )
        parser.add_argument(
            "--git",
            dest="git_hash",
            help="Git hash for finish command.",
        )
    
        update_group = parser.add_argument_group("Update Commands")
        update_group.add_argument(
            "--migrate",
            action="store_true",
            help="Force migration from v1.x to v2.x structure.",
        )
        update_group.add_argument(
            "--update",
            action="store_true",
            help="Run init/update even when using checks.",
        )
        update_group.add_argument(
            "--bootstrap",
            action="store_true",
            help="Create BOOTSTRAP_PROMPT.md for AI-driven project initialization (Context Bootstrapping).",
        )
        update_group.add_argument(
            "--bootstrap-mcp",
            action="store_true",
            help="Create MCP bootstrap prompt and templates for a target client.",
        )
        update_group.add_argument(
            "--reverse",
            action="store_true",
            help="Generate reverse engineering prompt for partial code analysis.",
        )
        update_group.add_argument(
            "--guide",
            action="store_true",
            help="Show onboarding guide location and output LLM prompt for interactive setup.",
        )
        update_group.add_argument(
            "--refresh-guide",
            action="store_true",
            help="Regenerate onboarding guide from state without full update.",
        )
        update_group.add_argument(
            "--focus",
            type=str,
            help="Focus path for reverse engineering (e.g., src/auth).",
        )
        update_group.add_argument(
            "--target",
            type=str,
            help="Target client for bootstrap-mcp or mcp-check (claude_code, claude_desktop, codex, gemini_cli, ci).",
        )
        update_group.add_argument(
            "--os",
            dest="os_name",
            type=str,
            choices=["windows", "unix"],
            help="Target OS for bootstrap-mcp (windows or unix).",
        )
    
        check_group = parser.add_argument_group("Check Commands")
        check_group.add_argument(
            "--doctor",
            action="store_true",
            help="Run all checks (structure, lint, links, requirements, runs).",
        )
        check_group.add_argument(
            "--check",
            action="store_true",
            help="Validate structure and required files.",
        )
        check_group.add_argument(
            "--lint",
            action="store_true",
            help="Check metadata headers in key documents.",
        )
        check_group.add_argument(
            "--links",
            action="store_true",
            help="Validate links in .memory docs.",
        )
        check_group.add_argument(
            "--allow-absolute-links",
            action="store_true",
            help="Allow absolute paths in links (not recommended).",
        )
        check_group.add_argument(
            "--req",
            action="store_true",
            help="Validate requirement documents (authority model).",
        )
        check_group.add_argument(
            "--runs",
            action="store_true",
            help="Validate RUN documents (execution unit model).",
        )
        check_group.add_argument(
            "--mcp-check",
            action="store_true",
            help="Validate MCP bootstrap outputs (templates and scripts).",
        )
    
        status_group = parser.add_argument_group("Status Commands")
        status_group.add_argument(
            "--status",
            action="store_true",
            help="Show status report of tasks and knowledge.",
        )
        status_group.add_argument(
            "--recent",
            type=int,
            default=5,
            metavar="N",
            help="Number of recent active tasks to show (default: 5).",
        )
        status_group.add_argument(
            "--list-runs",
            nargs="?",
            const="all",
            metavar="STATUS",
            help="List RUN documents. Filter by status: active, completed, failed, all (default: all).",
        )
    
        parser.add_argument(
            "--dry-run",
            action="store_true",
            help="Preview changes without writing.",
        )
    
        return parser.parse_args()
    
    def main() -> int:
        args = parse_args()
    
        if args.command == "apply-req":
            req_id = args.command_req_id
            if not req_id:
                print("Error: --id is required when running apply-req")
                return 1
            automator = Automator()
            report = automator.apply_req(
                req_id, dry_run=args.dry_run, create_spec=not args.no_spec
            )
            if report["status"] == "failed":
                print("apply-req failed:")
                for err in report["errors"]:
                    print(f"  - {err}")
                if report["disc"]:
                    print(f"  DISC created: {report['disc']}")
                return 1
            print(f"apply-req {report['status']}:")
            for name, path in report["artifacts"].items():
                print(f"  {name}: {path}")
            return 0
    
        if args.command == "intake":
            if not args.input_data:
                 print("Error: --input is required for intake (text or file path)")
                 return 1
            
            automator = Automator()
            input_path = Path(args.input_data)
            if input_path.exists():
                val = [str(input_path)]
            else:
                val = args.input_data
                
            brief_path = automator.intake(val)
            print(f"Intake successful. Brief created: {brief_path}")
            return 0
    
        if args.command == "plan":
            if not args.command_req_id:
                print("Error: --id (Brief ID) is required for plan")
                return 1
            automator = Automator()
            run_path = automator.plan(args.command_req_id)
            print(f"Plan created. RUN: {run_path}")
            return 0
    
        if args.command == "finish":
            if not args.command_req_id:
                print("Error: --id (RUN ID) is required for finish")
                return 1
            automator = Automator()
            result_path = automator.finish(args.command_req_id, success=True, git_hash=args.git_hash or "manual-finish")
            print(f"Task Finished. Archived to: {result_path}")
            return 0
    
        if args.bootstrap_mcp:
            if not args.target or not args.os_name:
                print("Error: --target and --os are required when running --bootstrap-mcp")
                return 1
            bootstrap_mcp(args.target, args.os_name, dry_run=args.dry_run)
            return 0
    
        # Bootstrap mode: create AI kick-off meeting files and exit
        if args.bootstrap:
            bootstrap_init(dry_run=args.dry_run)
            return 0
    
        if args.reverse:
            if not args.focus:
                print("Error: --focus is required when using --reverse (e.g., --focus src/core)")
                return 1
            generate_reverse_prompt(ROOT_DIR, args.focus)
            return 0
    
        if args.guide:
            init_or_update(dry_run=args.dry_run, force_migrate=args.migrate)
    
            memory_root = Path(ROOT_DIR)
            guide_path = memory_root / "GETTING_STARTED.md"
            prompt_path = memory_root / "00_SYSTEM" / "ONBOARDING_PROMPT.md"
    
            print("\n" + "=" * 60)
            print(" MemoryAtlas  ")
            print("=" * 60 + "\n")
    
            print("   :")
            print(f"   -  : {guide_path}")
            print(f"   -  : {prompt_path}\n")
    
            missing = []
            if not guide_path.exists():
                missing.append(str(guide_path))
            if not prompt_path.exists():
                missing.append(str(prompt_path))
    
            if missing:
                print("    :")
                for item in missing:
                    print(f"   - {item}")
                if args.dry_run:
                    print("    --dry-run    .")
                    print("     : python memory_manager.py --guide")
                else:
                    print("     'python memory_manager.py'  .memory  .")
                return 1
    
            print("=" * 60)
            print("   LLM :")
            print("=" * 60 + "\n")
            print(prompt_path.read_text(encoding="utf-8"))
            return 0
    
        if args.refresh_guide:
            ensure_structure(ROOT_DIR)
            update_onboarding_prompt(ROOT_DIR, dry_run=args.dry_run)
            update_onboarding_guide(ROOT_DIR, dry_run=args.dry_run, force=True)
            return 0
    
        run_checks = any([
            args.doctor,
            args.check,
            args.lint,
            args.links,
            args.req,
            args.runs,
            args.mcp_check,
            args.status,
        ])
        run_update = args.update or args.migrate or not run_checks
    
        exit_code = 0
    
        if run_update:
            init_or_update(dry_run=args.dry_run, force_migrate=args.migrate)
    
        if args.doctor:
            exit_code = doctor(ROOT_DIR, allow_absolute_links=args.allow_absolute_links)
        else:
            if args.check:
                exit_code += check_structure(ROOT_DIR)
            if args.lint:
                exit_code += lint_metadata(ROOT_DIR)
            if args.links:
                exit_code += check_links(ROOT_DIR, allow_absolute=args.allow_absolute_links)
            if args.req:
                exit_code += check_requirements(ROOT_DIR)
            if args.runs:
                exit_code += check_runs(ROOT_DIR)
            if args.mcp_check:
                exit_code += check_mcp(ROOT_DIR, target=args.target)
    
        if args.status:
            status_report(ROOT_DIR, show_recent=args.recent)
    
        if args.list_runs:
            list_runs(ROOT_DIR, status_filter=args.list_runs)
    
        return exit_code
    
    
    if __name__ == "__main__":
        sys.exit(main())
    
    