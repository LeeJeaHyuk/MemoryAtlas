#!/usr/bin/env python
import contextlib as __stickytape_contextlib

@__stickytape_contextlib.contextmanager
def __stickytape_temporary_dir():
    import tempfile
    import shutil
    dir_path = tempfile.mkdtemp()
    try:
        yield dir_path
    finally:
        shutil.rmtree(dir_path)

with __stickytape_temporary_dir() as __stickytape_working_dir:
    def __stickytape_write_module(path, contents):
        import os, os.path

        def make_package(path):
            parts = path.split("/")
            partial_path = __stickytape_working_dir
            for part in parts:
                partial_path = os.path.join(partial_path, part)
                if not os.path.exists(partial_path):
                    os.mkdir(partial_path)
                    with open(os.path.join(partial_path, "__init__.py"), "wb") as f:
                        f.write(b"\n")

        make_package(os.path.dirname(path))

        full_path = os.path.join(__stickytape_working_dir, path)
        with open(full_path, "wb") as module_file:
            module_file.write(contents)

    import sys as __stickytape_sys
    __stickytape_sys.path.insert(0, __stickytape_working_dir)

    #!/usr/bin/env python3
    """Atlas vNext CLI."""
    
    import argparse
    import json
    import os
    import re
    import sys
    import subprocess
    from datetime import datetime, timedelta
    from pathlib import Path
    from typing import Iterable, Optional
    
    ATLAS_VERSION = "0.3.0"
    
    CHANGELOG = {
        "0.3.0": [
            "Refactor: SSOT-first structure (views/adr/drafts/inbox/archive).",
            "Feature: capture/run workflow with REQ-based RUN IDs.",
            "Feature: finish writes Implemented-Git/Linked-RUN to REQ.",
            "Feature: doctor validates view refs and git evidence.",
            "Templates: add VIEW/ADR; update RUN/REQ."
        ],
        "0.2.0": [
            "Feature: Auto-detection of version updates.",
            "Feature: Print changelog on update.",
        ],
        "0.1.0": [
            "Initial release."
        ]
    }
    
    # If running from src/atlas_cli.py, parents[1] is the root.
    # If bundled as atlas.py in the root, parents[0] (or .parent) is the root.
    _path = Path(__file__).resolve()
    if _path.name == "atlas_cli.py":
        REPO_ROOT = _path.parents[1]
    else:
        REPO_ROOT = _path.parent
    
    ATLAS_ROOT = REPO_ROOT / ".atlas"
    SYSTEM_ROOT = ATLAS_ROOT / ".system"
    TEMPLATES_DIR = SYSTEM_ROOT / "templates"
    STATE_DIR = SYSTEM_ROOT / "state"
    LAST_RUN_PATH = STATE_DIR / "last_run.json"
    VERSION_PATH = SYSTEM_ROOT / "VERSION"
    SRC_DEFAULTS_ROOT = REPO_ROOT / "src" / ".system_defaults"
    SRC_DEFAULT_TEMPLATES_DIR = SRC_DEFAULTS_ROOT / "templates"
    SRC_DEFAULT_TOP_DOCS_DIR = SRC_DEFAULTS_ROOT / "top_docs"
    SRC_DEFAULT_PROMPTS_DIR = SRC_DEFAULTS_ROOT / "prompts"
    
    REQ_DIR = ATLAS_ROOT / "req"
    RULE_DIR = ATLAS_ROOT / "rule"
    ADR_DIR = ATLAS_ROOT / "adr"
    CQ_DIR = ATLAS_ROOT / "cq"
    VIEWS_DIR = ATLAS_ROOT / "views"
    INBOX_DIR = ATLAS_ROOT / "inbox"  # Unstructured notes, excluded from doctor
    DRAFTS_DIR = ATLAS_ROOT / "drafts"
    BRIEF_DIR = DRAFTS_DIR / "brief"
    RUN_DIR = ATLAS_ROOT / "runs"
    ARCHIVE_DIR = ATLAS_ROOT / "archive"
    
    REQUIRED_TOP_DOCS = [
        ATLAS_ROOT / "FRONT.md",
        ATLAS_ROOT / "BOARD.md",
        ATLAS_ROOT / "CONVENTIONS.md",
    ]
    
    OPTIONAL_TOP_DOCS = [
        ATLAS_ROOT / "GOALS.md",
    ]
    
    REQ_ID_PATTERN = re.compile(r"^REQ-([A-Z]+)-(\d{3})$")
    RULE_ID_PATTERN = re.compile(r"^RULE-([A-Z]+)-(\d{3})$")
    ADR_ID_PATTERN = re.compile(r"^ADR-([A-Z]+)-(\d{3})$")
    CQ_ID_PATTERN = re.compile(r"^CQ-([A-Z]+)-(\d{3})$")
    BRIEF_ID_PATTERN = re.compile(r"^BRIEF-([A-Z]+)-(\d{3})$")
    RUN_ID_PATTERN = re.compile(r"^RUN-(BRIEF|REQ)-([A-Z]+)-(\d{3})-step-(\d{2})$")
    
    META_RE = re.compile(r"^>\s*\*\*([^*]+)\*\*:\s*(.+)$")
    HEADER_ID_RE = re.compile(r"^#\s+\[([^\]]+)\]", re.M)
    LINK_RE = re.compile(r"\[[^\]]*\]\(([^)]+)\)")
    
    ALLOWED_MUST_READ_PREFIXES = {"RULE"}
    
    PATCH_DIR = ATLAS_ROOT / "patch"
    
    # Embedded source code (populated by build.py)
    # __EMBEDDED_SRC_PLACEHOLDER__ will be replaced with base64-encoded source
    EMBEDDED_SRC_B64 = "IyEvdXNyL2Jpbi9lbnYgcHl0aG9uMwoiIiJBdGxhcyB2TmV4dCBDTEkuIiIiCgppbXBvcnQgYXJncGFyc2UKaW1wb3J0IGpzb24KaW1wb3J0IG9zCmltcG9ydCByZQppbXBvcnQgc3lzCmltcG9ydCBzdWJwcm9jZXNzCmZyb20gZGF0ZXRpbWUgaW1wb3J0IGRhdGV0aW1lLCB0aW1lZGVsdGEKZnJvbSBwYXRobGliIGltcG9ydCBQYXRoCmZyb20gdHlwaW5nIGltcG9ydCBJdGVyYWJsZSwgT3B0aW9uYWwKCkFUTEFTX1ZFUlNJT04gPSAiMC4zLjAiCgpDSEFOR0VMT0cgPSB7CiAgICAiMC4zLjAiOiBbCiAgICAgICAgIlJlZmFjdG9yOiBTU09ULWZpcnN0IHN0cnVjdHVyZSAodmlld3MvYWRyL2RyYWZ0cy9pbmJveC9hcmNoaXZlKS4iLAogICAgICAgICJGZWF0dXJlOiBjYXB0dXJlL3J1biB3b3JrZmxvdyB3aXRoIFJFUS1iYXNlZCBSVU4gSURzLiIsCiAgICAgICAgIkZlYXR1cmU6IGZpbmlzaCB3cml0ZXMgSW1wbGVtZW50ZWQtR2l0L0xpbmtlZC1SVU4gdG8gUkVRLiIsCiAgICAgICAgIkZlYXR1cmU6IGRvY3RvciB2YWxpZGF0ZXMgdmlldyByZWZzIGFuZCBnaXQgZXZpZGVuY2UuIiwKICAgICAgICAiVGVtcGxhdGVzOiBhZGQgVklFVy9BRFI7IHVwZGF0ZSBSVU4vUkVRLiIKICAgIF0sCiAgICAiMC4yLjAiOiBbCiAgICAgICAgIkZlYXR1cmU6IEF1dG8tZGV0ZWN0aW9uIG9mIHZlcnNpb24gdXBkYXRlcy4iLAogICAgICAgICJGZWF0dXJlOiBQcmludCBjaGFuZ2Vsb2cgb24gdXBkYXRlLiIsCiAgICBdLAogICAgIjAuMS4wIjogWwogICAgICAgICJJbml0aWFsIHJlbGVhc2UuIgogICAgXQp9CgojIElmIHJ1bm5pbmcgZnJvbSBzcmMvYXRsYXNfY2xpLnB5LCBwYXJlbnRzWzFdIGlzIHRoZSByb290LgojIElmIGJ1bmRsZWQgYXMgYXRsYXMucHkgaW4gdGhlIHJvb3QsIHBhcmVudHNbMF0gKG9yIC5wYXJlbnQpIGlzIHRoZSByb290LgpfcGF0aCA9IFBhdGgoX19maWxlX18pLnJlc29sdmUoKQppZiBfcGF0aC5uYW1lID09ICJhdGxhc19jbGkucHkiOgogICAgUkVQT19ST09UID0gX3BhdGgucGFyZW50c1sxXQplbHNlOgogICAgUkVQT19ST09UID0gX3BhdGgucGFyZW50CgpBVExBU19ST09UID0gUkVQT19ST09UIC8gIi5hdGxhcyIKU1lTVEVNX1JPT1QgPSBBVExBU19ST09UIC8gIi5zeXN0ZW0iClRFTVBMQVRFU19ESVIgPSBTWVNURU1fUk9PVCAvICJ0ZW1wbGF0ZXMiClNUQVRFX0RJUiA9IFNZU1RFTV9ST09UIC8gInN0YXRlIgpMQVNUX1JVTl9QQVRIID0gU1RBVEVfRElSIC8gImxhc3RfcnVuLmpzb24iClZFUlNJT05fUEFUSCA9IFNZU1RFTV9ST09UIC8gIlZFUlNJT04iClNSQ19ERUZBVUxUU19ST09UID0gUkVQT19ST09UIC8gInNyYyIgLyAiLnN5c3RlbV9kZWZhdWx0cyIKU1JDX0RFRkFVTFRfVEVNUExBVEVTX0RJUiA9IFNSQ19ERUZBVUxUU19ST09UIC8gInRlbXBsYXRlcyIKU1JDX0RFRkFVTFRfVE9QX0RPQ1NfRElSID0gU1JDX0RFRkFVTFRTX1JPT1QgLyAidG9wX2RvY3MiClNSQ19ERUZBVUxUX1BST01QVFNfRElSID0gU1JDX0RFRkFVTFRTX1JPT1QgLyAicHJvbXB0cyIKClJFUV9ESVIgPSBBVExBU19ST09UIC8gInJlcSIKUlVMRV9ESVIgPSBBVExBU19ST09UIC8gInJ1bGUiCkFEUl9ESVIgPSBBVExBU19ST09UIC8gImFkciIKQ1FfRElSID0gQVRMQVNfUk9PVCAvICJjcSIKVklFV1NfRElSID0gQVRMQVNfUk9PVCAvICJ2aWV3cyIKSU5CT1hfRElSID0gQVRMQVNfUk9PVCAvICJpbmJveCIgICMgVW5zdHJ1Y3R1cmVkIG5vdGVzLCBleGNsdWRlZCBmcm9tIGRvY3RvcgpEUkFGVFNfRElSID0gQVRMQVNfUk9PVCAvICJkcmFmdHMiCkJSSUVGX0RJUiA9IERSQUZUU19ESVIgLyAiYnJpZWYiClJVTl9ESVIgPSBBVExBU19ST09UIC8gInJ1bnMiCkFSQ0hJVkVfRElSID0gQVRMQVNfUk9PVCAvICJhcmNoaXZlIgoKUkVRVUlSRURfVE9QX0RPQ1MgPSBbCiAgICBBVExBU19ST09UIC8gIkZST05ULm1kIiwKICAgIEFUTEFTX1JPT1QgLyAiQk9BUkQubWQiLAogICAgQVRMQVNfUk9PVCAvICJDT05WRU5USU9OUy5tZCIsCl0KCk9QVElPTkFMX1RPUF9ET0NTID0gWwogICAgQVRMQVNfUk9PVCAvICJHT0FMUy5tZCIsCl0KClJFUV9JRF9QQVRURVJOID0gcmUuY29tcGlsZShyIl5SRVEtKFtBLVpdKyktKFxkezN9KSQiKQpSVUxFX0lEX1BBVFRFUk4gPSByZS5jb21waWxlKHIiXlJVTEUtKFtBLVpdKyktKFxkezN9KSQiKQpBRFJfSURfUEFUVEVSTiA9IHJlLmNvbXBpbGUociJeQURSLShbQS1aXSspLShcZHszfSkkIikKQ1FfSURfUEFUVEVSTiA9IHJlLmNvbXBpbGUociJeQ1EtKFtBLVpdKyktKFxkezN9KSQiKQpCUklFRl9JRF9QQVRURVJOID0gcmUuY29tcGlsZShyIl5CUklFRi0oW0EtWl0rKS0oXGR7M30pJCIpClJVTl9JRF9QQVRURVJOID0gcmUuY29tcGlsZShyIl5SVU4tKEJSSUVGfFJFUSktKFtBLVpdKyktKFxkezN9KS1zdGVwLShcZHsyfSkkIikKCk1FVEFfUkUgPSByZS5jb21waWxlKHIiXj5ccypcKlwqKFteKl0rKVwqXCo6XHMqKC4rKSQiKQpIRUFERVJfSURfUkUgPSByZS5jb21waWxlKHIiXiNccytcWyhbXlxdXSspXF0iLCByZS5NKQpMSU5LX1JFID0gcmUuY29tcGlsZShyIlxbW15cXV0qXF1cKChbXildKylcKSIpCgpBTExPV0VEX01VU1RfUkVBRF9QUkVGSVhFUyA9IHsiUlVMRSJ9CgpQQVRDSF9ESVIgPSBBVExBU19ST09UIC8gInBhdGNoIgoKIyBFbWJlZGRlZCBzb3VyY2UgY29kZSAocG9wdWxhdGVkIGJ5IGJ1aWxkLnB5KQojIF9fRU1CRURERURfU1JDX1BMQUNFSE9MREVSX18gd2lsbCBiZSByZXBsYWNlZCB3aXRoIGJhc2U2NC1lbmNvZGVkIHNvdXJjZQpFTUJFRERFRF9TUkNfQjY0ID0gIl9fRU1CRURERURfU1JDX1BMQUNFSE9MREVSX18iCgojIENoZWNrYm94IHBhdHRlcm5zCkNIRUNLQk9YX1VOQ0hFQ0tFRCA9IHJlLmNvbXBpbGUociJeKFxzKiktXHMqXFtccypcXSguKikkIikKQ0hFQ0tCT1hfQ0hFQ0tFRCA9IHJlLmNvbXBpbGUociJeKFxzKiktXHMqXFt4XF0oLiopJCIsIHJlLklHTk9SRUNBU0UpClRSQUNFQUJJTElUWV9MSU5LX1JFID0gcmUuY29tcGlsZShyIlwqXCooPzpJbXBsZW1lbnRzfEFuc3dlcnN8U29sdmVkIGJ5fEltcGxlbWVudGVkIGJ5KVwqXCo6XHMqXFsoW15cXV0rKVxdXCgoW14pXSspXCkiKQoKREVGQVVMVF9UT1BfRE9DUyA9IHsKICAgIEFUTEFTX1JPT1QgLyAiRlJPTlQubWQiOiAiIiIjIEF0bGFzXG5cblRoaXMgcmVwbyB1c2VzIEF0bGFzIHZOZXh0LlxuVXNlOiBgcHl0aG9uIGF0bGFzLnB5IGluaXRgXG5cblF1aWNrIGZsb3c6XG4xKSBgcHl0aG9uIGF0bGFzLnB5IGNhcHR1cmUgXCIuLi5cIiAtLWRvbWFpbiBHRU5gXG4yKSBgcHl0aG9uIGF0bGFzLnB5IHJ1biBSRVEtR0VOLTAwMWBcbjMpIGBweXRob24gYXRsYXMucHkgZmluaXNoIFJVTi1SRVEtR0VOLTAwMS1zdGVwLTAxIC0tZ2l0IDxoYXNofG5vLWNvbW1pdD4gLS1zdWNjZXNzIHRydWVgXG5cbkxpbmtzOiBCT0FSRC5tZCwgQ09OVkVOVElPTlMubWQsIEdPQUxTLm1kXG4iIiIsCiAgICBBVExBU19ST09UIC8gIkJPQVJELm1kIjogIiIiIyBCT0FSRFxuXG4+IOydtCDrrLjshJzripQg7ZSE66Gc7KCd7Yq47J2YICoq7ZiE7J6sIOyekeyXhSDsg4Htg5wg7Iqk64OF7IO3KirsnYQg64KY7YOA64OF64uI64ukLlxuPiDruYTslrQg7J6I64qUIOqyveyasCwg7ZW064u5IOyDge2DnOyXkCDtlbTri7ntlZjripQg7J6R7JeF7J20IOyXhuydjOydhCDsnZjrr7jtlanri4jri6QuXG5cbiMjIFF1ZXVlXG4tIChlbXB0eSlcblxuIyMgQWN0aXZlXG4tIChlbXB0eSlcblxuIyMgRG9uZVxuLSAoZW1wdHkpXG5cbj4gTGFzdCBSZXZpZXdlZDogWVlZWS1NTS1ERFxuIiIiLAogICAgQVRMQVNfUk9PVCAvICJDT05WRU5USU9OUy5tZCI6ICIiIiMgQ09OVkVOVElPTlNcblxuIyMgQm91bmRhcmllc1xuXG4jIyMgQWx3YXlzXG4tIEtlZXAgUkVRL1JVTEUvQURSL0NRIGFzIGF1dGhvcml0eTsgZG8gbm90IGF1dG8tZWRpdCB3aXRob3V0IGludGVudC5cbi0gUmVjb3JkIHZlcmlmaWNhdGlvbiBzdGVwcyBpbiBSVU4uXG5cbiMjIyBBc2sgRmlyc3Rcbi0gQWRkIG9yIHJlbW92ZSBkZXBlbmRlbmNpZXMuXG4tIENoYW5nZSBzdG9yYWdlIGxheW91dCB1bmRlciBgLmF0bGFzL2AuXG5cbiMjIyBOZXZlclxuLSBIYXJkY29kZSBzZWNyZXRzLlxuLSBNb2RpZnkgZXhpc3RpbmcgUkVRL1JVTEUvQURSL0NRIHNpbGVudGx5LlxuXG4jIyBSb2xlcyAob25lLWxpbmUpXG4tIFJFUTogd2hhdCB0aGUgc3lzdGVtIG11c3QgZG8gKFNTT1QpLlxuLSBSVUxFOiBjb25zdHJhaW50cyB0aGF0IG11c3QgYWx3YXlzIGhvbGQgKFNTT1QpLlxuLSBBRFI6IGFyY2hpdGVjdHVyYWwgZGVjaXNpb25zIChTU09UKS5cbi0gQ1E6IHF1ZXN0aW9ucyB0aGUgc3lzdGVtIG11c3QgYW5zd2VyLlxuLSBWSUVXOiBodW1hbi1yZWFkYWJsZSBjb250ZXh0LlxuLSBEUkFGVDogb3B0aW9uYWwgaW50YWtlIHNjcmF0Y2hwYWQuXG4tIFJVTjogZXhlY3V0aW9uIHBsYW4gYW5kIGV2aWRlbmNlLlxuXG4jIyBWZXJpZmljYXRpb25cbi0gYHB5dGhvbiBhdGxhcy5weSBkb2N0b3JgXG4tIChwcm9qZWN0IHRlc3RzIGFzIGRlZmluZWQpXG4iIiIsCiAgICBBVExBU19ST09UIC8gIkdPQUxTLm1kIjogIiIiIyBHT0FMU1xuXG4tIFB1cnBvc2U6IChmaWxsIGluKVxuLSBJbiBzY29wZTogKGZpbGwgaW4pXG4tIE91dCBvZiBzY29wZTogKGZpbGwgaW4pXG4iIiIsCn0KCkRFRkFVTFRfVEVNUExBVEVTID0gewogICAgIlJFUS5tZCI6ICIiIiMgW1JFUS1YWFgtMDAxXSBUaXRsZVxuXG4+ICoqSUQqKjogUkVRLVhYWC0wMDFcbj4gKipEb21haW4qKjogWFhYXG4+ICoqU3RhdHVzKio6IERyYWZ0XG4+ICoqTGFzdCBVcGRhdGVkKio6IFlZWVktTU0tRERcbj4gKipJbXBsZW1lbnRlZC1HaXQqKjogLVxuPiAqKkxpbmtlZC1SVU4qKjogLVxuPiAqKk11c3QtUmVhZCoqOiBSVUxFLVhYWC0wMDFcblxuLS0tXG5cbiMjIERlY2lzaW9uXG4tICh3aGF0IG11c3QgYmUgdHJ1ZSlcblxuIyMgSW5wdXRcbi0gKGlucHV0cylcblxuIyMgT3V0cHV0XG4tIChvdXRwdXRzKVxuXG4jIyBBY2NlcHRhbmNlIENyaXRlcmlhXG4tIFsgXSAoY3JpdGVyaWEpXG4iIiIsCiAgICAiUlVMRS5tZCI6ICIiIiMgW1JVTEUtWFhYLTAwMV0gVGl0bGVcblxuPiAqKklEKio6IFJVTEUtWFhYLTAwMVxuPiAqKkRvbWFpbioqOiBYWFhcbj4gKipQcmlvcml0eSoqOiBNZWRpdW1cbj4gKipMYXN0IFVwZGF0ZWQqKjogWVlZWS1NTS1ERFxuPiAqKk11c3QtUmVhZCoqOiBSVUxFLVhYWC0wMDFcblxuLS0tXG5cbiMjIFJ1bGUgU3RhdGVtZW50XG4tIChhbHdheXMgdHJ1ZSAvIGZvcmJpZGRlbilcblxuIyMgU2NvcGVcbi0gKHdoZXJlIGl0IGFwcGxpZXMpXG5cbiMjIFZpb2xhdGlvblxuLSAod2hhdCBjb3VudHMgYXMgYSB2aW9sYXRpb24pXG5cbiMjIEV4YW1wbGVzXG5cbiMjIyBDb3JyZWN0XG4tIChleGFtcGxlKVxuXG4jIyMgSW5jb3JyZWN0XG4tIChleGFtcGxlKVxuIiIiLAogICAgIkNRLm1kIjogIiIiIyBbQ1EtWFhYLTAwMV0gVGl0bGVcblxuPiAqKklEKio6IENRLVhYWC0wMDFcbj4gKipEb21haW4qKjogWFhYXG4+ICoqU3RhdHVzKio6IERyYWZ0XG4+ICoqTGFzdCBVcGRhdGVkKio6IFlZWVktTU0tRERcblxuLS0tXG5cbiMjIFF1ZXN0aW9uXG4tICh3aGF0IG11c3QgdGhlIHN5c3RlbSBhbnN3ZXI/KVxuXG4jIyBFeHBlY3RlZCBBbnN3ZXIgKENyaXRlcmlhKVxuMS4gLi4uXG4yLiAuLi5cblxuIyMgVHJhY2VhYmlsaXR5XG4tICoqU29sdmVzIGJ5Kio6IFtSRVEtWFhYLTAwMV0oLi4vcmVxL1JFUS1YWFgtMDAxLm1kKVxuLSAqKkNvbnN0cmFpbmVkIGJ5Kio6IFtSVUxFLVhYWC0wMDFdKC4uL3J1bGUvUlVMRS1YWFgtMDAxLm1kKVxuIiIiLAogICAgIkJSSUVGLm1kIjogIiIiIyBbQlJJRUYtWFhYLTAwMV0gVGl0bGVcblxuPiAqKklEKio6IEJSSUVGLVhYWC0wMDFcbj4gKipEb21haW4qKjogWFhYXG4+ICoqU3RhdHVzKio6IEFjdGl2ZVxuPiAqKkRhdGUqKjogWVlZWS1NTS1ERFxuXG4jIyAxLiBVc2VyIFJlcXVlc3Rcbi0gKHJhdyB0ZXh0KVxuXG4jIyAyLiBJbnRlbnQgU3VtbWFyeVxuLSBHb2FsOlxuLSBQcm9ibGVtOlxuXG4jIyAzLiBBZmZlY3RlZCBBcnRpZmFjdHNcbi0gQ3JlYXRlOiBcbi0gTW9kaWZ5OiBcbi0gUmVhZDogXG5cbiMjIDQuIFByb3Bvc2VkIENoYW5nZXNcbjEuIFxuMi4gXG5cbiMjIDUuIFZlcmlmaWNhdGlvbiBDcml0ZXJpYVxuLSBbIF0gXG4iIiIsCiAgICAiUlVOLm1kIjogIiIiIyBbUlVOLVJFUS1YWFgtMDAxLXN0ZXAtMDFdIFRpdGxlXG5cbj4gKipJRCoqOiBSVU4tUkVRLVhYWC0wMDEtc3RlcC0wMVxuPiAqKlJFUSoqOiBSRVEtWFhYLTAwMVxuPiAqKlN0YXR1cyoqOiBQbGFubmVkXG4+ICoqU3RhcnRlZCoqOiBZWVlZLU1NLUREXG4+ICoqR2l0Kio6IC1cbj4gKipDb21wbGV0ZWQqKjogLVxuXG4jIyBUYXJnZXQgUkVRXG4tIFJFUS1YWFgtMDAxXG5cbiMjIFBsYW5cbi0gWyBdIFxuXG4jIyBWZXJpZmljYXRpb25cbi0gWyBdIFRlc3Rcbi0gWyBdIFNwZWNcbi0gWyBdIEJvdW5kYXJ5XG5cbiMjIE91dHB1dFxuLSAoZmlsZXMgY3JlYXRlZC9tb2RpZmllZClcbiIiIiwKICAgICJWSUVXLm1kIjogIiIiIyBbVklFVy1SRVEtWFhYLTAwMV0gVGl0bGVcblxuPiAqKlJlZnMqKjogUkVRLVhYWC0wMDFcbj4gKipMYXN0IFVwZGF0ZWQqKjogWVlZWS1NTS1ERFxuXG4jIyBTdW1tYXJ5XG4tIChodW1hbi1yZWFkYWJsZSBzdW1tYXJ5KVxuXG4jIyBSZWZlcmVuY2VzIChTU09UKVxuLSBbUkVRLVhYWC0wMDFdKC4uL3JlcS9SRVEtWFhYLTAwMS5tZClcbiIiIiwKICAgICJBRFIubWQiOiAiIiIjIFtBRFItWFhYLTAwMV0gVGl0bGVcblxuPiAqKklEKio6IEFEUi1YWFgtMDAxXG4+ICoqRG9tYWluKio6IFhYWFxuPiAqKlN0YXR1cyoqOiBEcmFmdFxuPiAqKkRhdGUqKjogWVlZWS1NTS1ERFxuPiAqKlN1cGVyc2VkZXMqKjogLVxuPiAqKlN1cGVyc2VkZWQtQnkqKjogLVxuXG4tLS1cblxuIyMgQ29udGV4dFxuLSAod2h5IHRoaXMgZGVjaXNpb24gaXMgbmVlZGVkKVxuXG4jIyBEZWNpc2lvblxuLSAodGhlIGRlY2lzaW9uKVxuXG4jIyBDb25zZXF1ZW5jZXNcbi0gKHRyYWRlLW9mZnMgYW5kIGZvbGxvdy11cHMpXG5cbiMjIFJlZmVyZW5jZXNcbi0gKFJFUS9SVUxFIGxpbmtzKVxuIiIiLAp9CgpERUZBVUxUX1BST01QVFMgPSB7CiAgICAib25ib2FyZGluZy5tZCI6ICIiIiMgQXRsYXMgQXVkaXQgUHJvbXB0Cgo+ICoqTm90ZSoqOiDquLDsobQgYE9uYm9hcmRpbmcgUHJvbXB0YOqwgCAqKmBBdWRpdCBQcm9tcHRgKirroZwg7J6s7KCV7J2Y65CY7JeI7Iq164uI64ukLgo+IOydtCDtlITroaztlITtirjripQg642UIOydtOyDgSDtjIzsnbzsnYQg7J6Q64+Z7Jy866GcIOyDneyEse2VmOyngCDslYrsnLzrqbAsIO2YhOyerCDtlITroZzsoJ3tirjsmYAg66y47IScIOqwhOydmCAqKuygle2VqeyEsShDb25zaXN0ZW5jeSnsnYQg6rCQ7IKsKEF1ZGl0KSoq7ZWY64qUIOyXre2VoOydhCDsiJjtlontlanri4jri6QuCgotLS0KCiMjIFByb21wdAoKYGBgCuuLueyLoOydgCDsnbQg7ZSE66Gc7KCd7Yq47J2YICoq66y47IScIOygle2VqeyEsSDqsJDsgqzqtIAoQXVkaXRvcikqKuyeheuLiOuLpC4K7J2066+4IOyhtOyerO2VmOuKlCBBdGxhcyDrrLjshJzrk6QoLmF0bGFzLyDtj7TrjZQg64K0IEdPQUxTLCBDT05WRU5USU9OUywgQk9BUkQsIEZST05UKeydtCDtmITsnqwg7ZSE66Gc7KCd7Yq47J2YIOyLpOygnCDsg4Htg5wo7L2U65OcLCDstZzqt7wg7J6R7JeFLCDquLDsiKAg7Iqk7YOdIOuTsSnsmYAg7J287LmY7ZWY64qU7KeAIOygkOqygO2VmOuKlCDqsoPsnbQg7KO8IOyehOustOyeheuLiOuLpC4KCiMjIyBbU3RyaWN0IFJ1bGVzXSDtlbXsi6wg6rec7LmZCjEuICoqUkVBRC1PTkxZKio6IOygiOuMgCwg7Ja065akIOqyveyasOyXkOuPhCDquLDsobQg7YyM7J287J2EIOyngeygkSDsiJjsoJXtlZjqsbDrgpgg64K07Jqp7J2EIOyekOuPmSDsl4XrjbDsnbTtirjtlZjsp4Ag66eI7IS47JqULgoyLiAqKuygnOyViCDrqqjrk5wgKFN1Z2dlc3Rpb24gT25seSkqKjog67aI7J287LmY64KYIOuIhOudveydtCDrsJzqsqzrkJjrqbQgIuyWtOuWu+qyjCDsiJjsoJXtlZjrqbQg7KKL7J2E7KeAIuulvCDsoJzslYgg7ZiV7Iud7Jy866Gc66eMIOy2nOugpe2VmOyEuOyalC4KMy4gKirruYTtjJDsoIEg7Iuc6rCBKio6IOuLqOyInO2eiCDrgrTsmqnsnYQg7JqU7JW97ZWY7KeAIOunkOqzoCwgIuygleunkCDsnbQg64K07Jqp7J20IO2YhOyerCDsnKDtmqjtlZzqsIA/IuulvCDrgYrsnoTsl4bsnbQg7J2Y7Ius7ZWY66mwIOqygOymne2VmOyEuOyalC4KCiMjIyBbQ2hlY2tsaXN0XSDqsoDsgqwg6rSA7KCQCgpMTE3snYAg64uk7J2MIOq4sOykgOyXkCDrlLDrnbwg6rCBIOusuOyEnOulvCDsl4TqsqntlZjqsowg7Y+J6rCA7ZW07JW8IO2VqeuLiOuLpDoKCiMjIyMgMS4gR09BTFMubWQgKOuqqe2RnCDsoJXtlanshLEpCi0gKipBY3RpdmUgVGFza+yZgCDsnbzsuZgg7Jes67aAKio6IO2YhOyerCDsp4Ttlokg7KSR7J24IOyekeyXheuTpOydtCBHT0FMU+yXkCDsoJXsnZjrkJwg7ZW17IusIOuqqe2RnOulvCDrspfslrTrgpjsp4Ag7JWK7JWY64qU6rCAPwotICoqU2NvcGUgQ3JlZXAg6rCQ7KeAKio6IOy1nOq3vCDrhbzsnZjrkJjqsbDrgpgg7LaU6rCA65CcIOq4sOuKpeydtCBJbi1TY29wZSDrspTsnIQg64K07JeQIOyeiOuKlOqwgD8g7JWE64uI66m0IOuylOychOulvCDsobDsmqntnogg64ST7Z6I6rOgIOyeiOuKlOqwgD8KCiMjIyMgMi4gQ09OVkVOVElPTlMubWQgKOq3nOy5mSDtmITsi6TshLEpCi0gKirsnITrsJgg6rCA64ql7ISxIOygkOqygCoqOiDsi6TsoJwg7L2U65Oc64KYIOy1nOq3vCDsu6TrsIsg64K07Jqp7J20IOusuOyEnOydmCDqt5zsuZkoQWx3YXlzLCBOZXZlcinsnYQg7JyE67CY7ZWY6rOgIOyeiOyngCDslYrsnYDqsIA/Ci0gKirqtazssrTshLEg6rKA7KadKio6IOq3nOy5meydtCDrhIjrrLQg7LaU7IOB7KCB7J207Ja07IScKOyYiDogIuq5qOuBl+2VnCDsvZTrk5wg7J6R7ISxIikg7Iuk7KCcIOyngOy5qOydtCDrkJjsp4Ag66q77ZWY64qUIOu2gOu2hOydgCDsl4bripTqsIA/CgojIyMjIDMuIEJPQVJELm1kICjtmITtmakg64+Z6riw7ZmUKQotICoqQWN0aXZlIOyDge2DnCDqsoDspp0qKjogQWN0aXZl7JeQIOyeiOuKlCDsnpHsl4XsnbQg7ZiE7J6sIOyLpOygnOuhnCDsp4Ttlokg7KSR7J246rCAPyAoR09BTFMg67KU7JyE66W8IOuyl+yWtOuCnCDsnpHsl4XsnbQgQWN0aXZl7JeQIOyeiOuKlOqwgD8pCi0gKipRdWV1ZSDrsKnsuZgg7KCQ6rKAKio6IFF1ZXVl7JeQIOyeiOuKlCDtla3rqqnrk6TsnbQg64SI66y0IOyYpOuemCDrsKnsuZjrkJjslrQsIO2YhOyerOydmCBHT0FMU+yZgCDrp57sp4Ag7JWK6rKMIOuQmOyXiOuKlOqwgD8KCiMjIyMgNC4gRlJPTlQubWQgKO2ZmOqyvSDstZzsi6DtmZQpCi0gKirquLDsiKAg7Iqk7YOdIO2YhOyLpO2ZlCoqOiDrrLjshJzsl5Ag7KCB7Z6MIOq4sOyIoCDsiqTtg53snbQg7Iuk7KCcIO2UhOuhnOygne2KuCDsvZTrk5zsmYAg7J287LmY7ZWY64qU6rCAPwotICoq7JWU66y17KCBIOyghOygnCoqOiDtjIAg64K07JeQ7IScIOyVlOusteyggeycvOuhnCDtlansnZjrkJwg7KSR7JqU7ZWcIOuzgOqyvSDsgqztla3snbQg66y47ISc7JeQ7IScIOuIhOudveuQmOyngCDslYrslZjripTqsIA/CgotLS0KCiMjIyBbQXVkaXQgUmVwb3J0XSDstpzroKUg7JaR7IudCgrqsIEg7YyM7J2867OE66GcIOyVhOuemCDsg4Htg5wg7JWE7J207L2Y7J2EIOyCrOyaqe2VmOyXrCDsp4Tri6gg6rKw6rO866W8IOy2nOugpe2VmOyEuOyalC4KCi0gW1BBU1NdICoq7J287LmYIChQYXNzKSoqCi0gW1dBUk5dICoq7J2Y7IusIChXYXJuaW5nKSoqOiDtmZXsnbjsnbQg7ZWE7JqU7ZWY6rGw64KYIOuqqO2YuO2VnCDrtoDrtoQuCi0gW0ZBSUxdICoq67aI7J287LmYL+uIhOudvSAoRmFpbCkqKjog66qF7ZmV7ZWcIOyYpOulmCwg7KaJ7IucIOyImOyglSDtlYTsmpQuCgoqKlvsnpHshLEg7JiI7IucXSoqCgojIyMgMS4gR09BTFMubWQKLSBbUEFTU10g7ZW17IusIOuqqe2RnCDsl6zsoITtnogg7Jyg7Zqo7ZWoLgotIFtXQVJOXSAqKuydmOyLrCoqOiAn7Iuk7Iuc6rCEIOyxhO2MhScg6riw64ql7J20IOy1nOq3vCDsnpHsl4UoVGFzay0xMDIp7JeQ7IScIOq1rO2YhCDspJHsnbjrjbAsIEdPQUxT7J2YIFNjb3Bl7JeQ64qUIOuqheyLnOuQmOyngCDslYrslZjsnYwuIOyXheuNsOydtO2KuCDtlYTsmpQuCgojIyMgMi4gQ09OVkVOVElPTlMubWQKLSBbRkFJTF0gKirrtojsnbzsuZgqKjog66y47ISc7JeQ64qUICdUeXBlIEhpbnQg7ZWE7IiYJ+udvOqzoCDrkJjslrQg7J6I7Jy864KYLCDstZzqt7wgYHV0aWxzLnB5YCDrk7Hsl5DshJwg66eO7J2AIO2VqOyImOqwgCDtg4DsnbTtlZEg7JeG7J20IOyekeyEseuQqC4KICAgIC0gKirsoJzslYgqKjog6rec7LmZ7J2EIOqwle2ZlO2VmOqxsOuCmCwg7JiI7Jm4IOyDge2ZqeydhCDrrLjshJzsl5Ag66qF7Iuc7ZWgIOqygy4KCijsnbTtlZggQk9BUkQsIEZST05UIOuPmeydvCDtj6zrp7cpClxuClxuLS0tClxuClxuIyMjIPCfmoAgW1JlY29tbWVuZGVkIEFjdGlvbnNdIOydtO2bhCDsp4Ttlokg6rCA7J2065OcClxuClxu6rCQ7IKsIOqysOqzvOulvCDrsJTtg5XsnLzroZwg7IKs7Jqp7J6Q6rCAIOy3qO2VtOyVvCDtlaAg6rWs7LK07KCB7J24IO2WieuPmeydhCDsoJzslYjtlZjshLjsmpQuClxuClxuMS4gKirsirnsnbgg7ZWE7JqUIChOZWVkcyBBcHByb3ZhbCkqKjog4pqg77iPL+KdjCDtla3rqqkg7KSRLCDsgqzsmqnsnpDsnZgg7ZmV7J247J20IO2VhOyalO2VnCDsoJXssYXsoIEg6rKw7KCVIOyCrO2VrS4KXG4yLiAqKuyImOyglSDsoJzslYggKEVkaXRzKSoqOiDsponsi5wg66y47ISc66W8IOyImOygle2VtOyVvCDtlZjripQg7IKs7ZWtICjqtazssrTsoIHsnbgg66y46rWsIOygnOyViCDtj6ztlagpLgpcbjMuICoq7IOI66Gc7Jq0IO2DnOyKpO2BrCAoTmV3IFRhc2tzKSoqOiDrrLjshJwg7KCV7ZWp7ISx7J2EIOychO2VtCDsg4jroZwg65Ox66Gd7ZW07JW8IO2VoCDsnpHsl4UgKOyYiDogIuuhnOq3uCDsi5zsiqTthZwg66as7Yyp7Yag66eBIOyKpO2OmSDrrLjshJwg7J6R7ISxIikuClxuClxuKipb7J6R7ISxIOyYiOyLnF0qKgpcbiMjIyDwn5qAIOydtO2bhCDsp4Ttlokg6rCA7J2065OcClxuMS4gKipDT05WRU5USU9OUy5tZCDsl4XrjbDsnbTtirgqKjogYFR5cGUgSGludGAg6rec7LmZ7J2EIGBTdHJpY3Rg7JeQ7IScIGBPcHRpb25hbGDroZwg7JmE7ZmU7ZWY64qUIOusuOq1rOuhnCDsiJjsoJXtlaAg6rKD7J2EIOygnOyViO2VqeuLiOuLpC4KXG4yLiAqKkdPQUxTLm1kIOqygO2GoCoqOiAn7Iuk7Iuc6rCEIOyxhO2MhScg6riw64ql7J20IEluLVNjb3Bl7J247KeAIFBN6rO8IO2YkeydmCDtm4QgU2NvcGUg7IS57IWYIOyXheuNsOydtO2KuCDtlYTsmpQuClxuYGBgClxuCgotLS0KCiMjIEhvdyB0byBleGVjdXRlCuydtCDtlITroaztlITtirjripQg7KCV6riw7KCB7Jy866GcKOuYkOuKlCDtlITroZzsoJ3tirgg67Cp7Zal7ISx7J20IO2dlOuTpOumtCDrlYwpIExMTeyXkOqyjCDsoJzsi5ztlZjsl6wg66y47IScIOu2gOyxhOulvCDsoJDqsoDtlZjripQg7Jqp64+E66GcIOyCrOyaqe2VqeuLiOuLpC4KIiIiLAp9CgoKZGVmIGdldF92ZXJzaW9uKCkgLT4gc3RyOgogICAgIiIiUmVhZCB2ZXJzaW9uIGZyb20gVkVSU0lPTiBmaWxlIChTU09UKS4iIiIKICAgIGlmIFZFUlNJT05fUEFUSC5leGlzdHMoKToKICAgICAgICByZXR1cm4gVkVSU0lPTl9QQVRILnJlYWRfdGV4dChlbmNvZGluZz0idXRmLTgiKS5zdHJpcCgpCiAgICByZXR1cm4gInVua25vd24iCgoKZGVmIG5vd19kYXRlKCkgLT4gc3RyOgogICAgcmV0dXJuIGRhdGV0aW1lLm5vdygpLnN0cmZ0aW1lKCIlWS0lbS0lZCIpCgoKZGVmIG5vd19pc28oKSAtPiBzdHI6CiAgICByZXR1cm4gZGF0ZXRpbWUubm93KCkuaXNvZm9ybWF0KHRpbWVzcGVjPSJzZWNvbmRzIikKCgpkZWYgZW5zdXJlX2RpcihwYXRoOiBQYXRoKSAtPiBOb25lOgogICAgcGF0aC5ta2RpcihwYXJlbnRzPVRydWUsIGV4aXN0X29rPVRydWUpCgoKZGVmIHJlYWRfdGV4dChwYXRoOiBQYXRoKSAtPiBzdHI6CiAgICByZXR1cm4gcGF0aC5yZWFkX3RleHQoZW5jb2Rpbmc9InV0Zi04IikKCgpkZWYgd3JpdGVfdGV4dChwYXRoOiBQYXRoLCBjb250ZW50OiBzdHIpIC0+IE5vbmU6CiAgICBwYXRoLndyaXRlX3RleHQoY29udGVudCwgZW5jb2Rpbmc9InV0Zi04IikKCgpkZWYgbG9hZF9kZWZhdWx0X3RvcF9kb2NzKCkgLT4gZGljdFtQYXRoLCBzdHJdOgogICAgZG9jcyA9IGRpY3QoREVGQVVMVF9UT1BfRE9DUykKICAgIGlmIFNSQ19ERUZBVUxUX1RPUF9ET0NTX0RJUi5pc19kaXIoKToKICAgICAgICBmb3IgcGF0aCBpbiBzb3J0ZWQoU1JDX0RFRkFVTFRfVE9QX0RPQ1NfRElSLmdsb2IoIioubWQiKSk6CiAgICAgICAgICAgIHRhcmdldCA9IEFUTEFTX1JPT1QgLyBwYXRoLm5hbWUKICAgICAgICAgICAgaWYgdGFyZ2V0IGluIGRvY3M6CiAgICAgICAgICAgICAgICBkb2NzW3RhcmdldF0gPSByZWFkX3RleHQocGF0aCkKICAgIHJldHVybiBkb2NzCgoKZGVmIGxvYWRfZGVmYXVsdF90ZW1wbGF0ZXMoKSAtPiBkaWN0W3N0ciwgc3RyXToKICAgIHRlbXBsYXRlcyA9IGRpY3QoREVGQVVMVF9URU1QTEFURVMpCiAgICBpZiBTUkNfREVGQVVMVF9URU1QTEFURVNfRElSLmlzX2RpcigpOgogICAgICAgIGZvciBuYW1lIGluIERFRkFVTFRfVEVNUExBVEVTOgogICAgICAgICAgICBzcmNfcGF0aCA9IFNSQ19ERUZBVUxUX1RFTVBMQVRFU19ESVIgLyBuYW1lCiAgICAgICAgICAgIGlmIHNyY19wYXRoLmV4aXN0cygpOgogICAgICAgICAgICAgICAgdGVtcGxhdGVzW25hbWVdID0gcmVhZF90ZXh0KHNyY19wYXRoKQogICAgcmV0dXJuIHRlbXBsYXRlcwoKCmRlZiBsb2FkX2RlZmF1bHRfcHJvbXB0cygpIC0+IGRpY3Rbc3RyLCBzdHJdOgogICAgcHJvbXB0cyA9IGRpY3QoREVGQVVMVF9QUk9NUFRTKQogICAgaWYgU1JDX0RFRkFVTFRfUFJPTVBUU19ESVIuaXNfZGlyKCk6CiAgICAgICAgZm9yIG5hbWUgaW4gREVGQVVMVF9QUk9NUFRTOgogICAgICAgICAgICBzcmNfcGF0aCA9IFNSQ19ERUZBVUxUX1BST01QVFNfRElSIC8gbmFtZQogICAgICAgICAgICBpZiBzcmNfcGF0aC5leGlzdHMoKToKICAgICAgICAgICAgICAgIHByb21wdHNbbmFtZV0gPSByZWFkX3RleHQoc3JjX3BhdGgpCiAgICByZXR1cm4gcHJvbXB0cwoKCmRlZiBsb2FkX2RlZmF1bHRfc3lzdGVtX2ZpbGVzKCkgLT4gZGljdFtzdHIsIHN0cl06CiAgICAiIiJMb2FkIFZFUlNJT04gYW5kIFZFUlNJT05JTkcubWQgZnJvbSBzcmMvLnN5c3RlbV9kZWZhdWx0cy8uIiIiCiAgICBmaWxlczogZGljdFtzdHIsIHN0cl0gPSB7fQogICAgZm9yIG5hbWUgaW4gWyJWRVJTSU9OIiwgIlZFUlNJT05JTkcubWQiLCAiQ0hBTkdFTE9HLm1kIl06CiAgICAgICAgc3JjX3BhdGggPSBTUkNfREVGQVVMVFNfUk9PVCAvIG5hbWUKICAgICAgICBpZiBzcmNfcGF0aC5leGlzdHMoKToKICAgICAgICAgICAgZmlsZXNbbmFtZV0gPSByZWFkX3RleHQoc3JjX3BhdGgpCiAgICByZXR1cm4gZmlsZXMKCgpkZWYgbG9hZF9kZWZhdWx0X3NyY19maWxlcygpIC0+IGRpY3Rbc3RyLCBzdHJdOgogICAgIiIiTG9hZCBzb3VyY2UgZmlsZXMgLSBlaXRoZXIgZnJvbSBkZWZhdWx0cyBkaXIgb3IgZW1iZWRkZWQgaW4gYXRsYXMucHkuIiIiCiAgICBpbXBvcnQgYmFzZTY0CiAgICBmaWxlczogZGljdFtzdHIsIHN0cl0gPSB7fQogICAgCiAgICAjIFRyeSBsb2FkaW5nIGZyb20gc3JjLy5zeXN0ZW1fZGVmYXVsdHMvc3JjLyBmaXJzdCAoZGV2ZWxvcG1lbnQgbW9kZSkKICAgIHNyY19kaXIgPSBTUkNfREVGQVVMVFNfUk9PVCAvICJzcmMiCiAgICBpZiBzcmNfZGlyLmlzX2RpcigpOgogICAgICAgIGZvciBwYXRoIGluIHNyY19kaXIuZ2xvYigiKi5weSIpOgogICAgICAgICAgICBmaWxlc1twYXRoLm5hbWVdID0gcmVhZF90ZXh0KHBhdGgpCiAgICAKICAgICMgSWYgbm8gZmlsZXMgZm91bmQsIHRyeSBlbWJlZGRlZCBzb3VyY2UgKGRpc3RyaWJ1dGlvbiBtb2RlKQogICAgaWYgbm90IGZpbGVzIGFuZCBFTUJFRERFRF9TUkNfQjY0ICE9ICJfX0VNQkVEREVEX1NSQ19QTEFDRUhPTERFUl9fIjoKICAgICAgICB0cnk6CiAgICAgICAgICAgIGRlY29kZWQgPSBiYXNlNjQuYjY0ZGVjb2RlKEVNQkVEREVEX1NSQ19CNjQpLmRlY29kZSgidXRmLTgiKQogICAgICAgICAgICBmaWxlc1siYXRsYXNfY2xpLnB5Il0gPSBkZWNvZGVkCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgcGFzcwogICAgCiAgICByZXR1cm4gZmlsZXMKCgpkZWYgbG9hZF90ZW1wbGF0ZShuYW1lOiBzdHIpIC0+IHN0cjoKICAgIHRlbXBsYXRlX3BhdGggPSBURU1QTEFURVNfRElSIC8gbmFtZQogICAgaWYgbm90IHRlbXBsYXRlX3BhdGguZXhpc3RzKCk6CiAgICAgICAgcmFpc2UgRmlsZU5vdEZvdW5kRXJyb3IoZiJNaXNzaW5nIHRlbXBsYXRlOiB7dGVtcGxhdGVfcGF0aH0iKQogICAgcmV0dXJuIHJlYWRfdGV4dCh0ZW1wbGF0ZV9wYXRoKQoKCmRlZiBpdGVyX21kX2ZpbGVzKGRpcnM6IEl0ZXJhYmxlW1BhdGhdKSAtPiBsaXN0W1BhdGhdOgogICAgZmlsZXM6IGxpc3RbUGF0aF0gPSBbXQogICAgZm9yIGJhc2UgaW4gZGlyczoKICAgICAgICBpZiBub3QgYmFzZS5pc19kaXIoKToKICAgICAgICAgICAgY29udGludWUKICAgICAgICBmb3IgcGF0aCBpbiBiYXNlLnJnbG9iKCIqLm1kIik6CiAgICAgICAgICAgIGZpbGVzLmFwcGVuZChwYXRoKQogICAgcmV0dXJuIGZpbGVzCgoKZGVmIGV4dHJhY3RfbWV0YSh0ZXh0OiBzdHIpIC0+IGRpY3Rbc3RyLCBzdHJdOgogICAgbWV0YTogZGljdFtzdHIsIHN0cl0gPSB7fQogICAgaGVhZCA9ICJcbiIuam9pbih0ZXh0LnNwbGl0bGluZXMoKVs6NjBdKQogICAgZm9yIGxpbmUgaW4gaGVhZC5zcGxpdGxpbmVzKCk6CiAgICAgICAgbWF0Y2ggPSBNRVRBX1JFLm1hdGNoKGxpbmUuc3RyaXAoKSkKICAgICAgICBpZiBtYXRjaDoKICAgICAgICAgICAgbWV0YVttYXRjaC5ncm91cCgxKS5zdHJpcCgpXSA9IG1hdGNoLmdyb3VwKDIpLnN0cmlwKCkKICAgIHJldHVybiBtZXRhCgoKZGVmIGV4dHJhY3RfaGVhZGVyX2lkKHRleHQ6IHN0cikgLT4gT3B0aW9uYWxbc3RyXToKICAgIG1hdGNoID0gSEVBREVSX0lEX1JFLnNlYXJjaCh0ZXh0KQogICAgcmV0dXJuIG1hdGNoLmdyb3VwKDEpLnN0cmlwKCkgaWYgbWF0Y2ggZWxzZSBOb25lCgoKZGVmIHBhcnNlX211c3RfcmVhZCh2YWx1ZTogc3RyKSAtPiBsaXN0W3N0cl06CiAgICByYXcgPSB2YWx1ZS5zdHJpcCgpCiAgICBpZiByYXcubG93ZXIoKSA9PSAibm9uZSI6CiAgICAgICAgcmV0dXJuIFtdCiAgICB0b2tlbnMgPSBbdC5zdHJpcCgpIGZvciB0IGluIHJhdy5zcGxpdCgiLCIpIGlmIHQuc3RyaXAoKV0KICAgIGlkczogbGlzdFtzdHJdID0gW10KICAgIGZvciB0b2tlbiBpbiB0b2tlbnM6CiAgICAgICAgaWYgdG9rZW4uc3RhcnRzd2l0aCgiWyIpIGFuZCAiXSIgaW4gdG9rZW4gYW5kICIoIiBpbiB0b2tlbjoKICAgICAgICAgICAgdG9rZW4gPSB0b2tlblsxIDogdG9rZW4uaW5kZXgoIl0iKV0uc3RyaXAoKQogICAgICAgIGlmIHRva2VuOgogICAgICAgICAgICBpZHMuYXBwZW5kKHRva2VuKQogICAgcmV0dXJuIGlkcwoKCmRlZiBuZXh0X2lkKHByZWZpeDogc3RyLCBkb21haW46IHN0ciwgZGlyX3BhdGg6IFBhdGgsIHBhdHRlcm46IHJlLlBhdHRlcm4pIC0+IHN0cjoKICAgIG1heF9uID0gMAogICAgaWYgZGlyX3BhdGguZXhpc3RzKCk6CiAgICAgICAgZm9yIHBhdGggaW4gZGlyX3BhdGguZ2xvYihmIntwcmVmaXh9LXtkb21haW59LSoubWQiKToKICAgICAgICAgICAgbWF0Y2ggPSBwYXR0ZXJuLm1hdGNoKHBhdGguc3RlbSkKICAgICAgICAgICAgaWYgbWF0Y2g6CiAgICAgICAgICAgICAgICBudW0gPSBpbnQobWF0Y2guZ3JvdXAoMikpCiAgICAgICAgICAgICAgICBpZiBudW0gPiBtYXhfbjoKICAgICAgICAgICAgICAgICAgICBtYXhfbiA9IG51bQogICAgcmV0dXJuIGYie3ByZWZpeH0te2RvbWFpbn0te21heF9uICsgMTowM2R9IgoKCmRlZiBuZXh0X3J1bl9zdGVwKHJlcV9pZDogc3RyKSAtPiBpbnQ6CiAgICBtYXRjaCA9IFJFUV9JRF9QQVRURVJOLm1hdGNoKHJlcV9pZCkKICAgIGlmIG5vdCBtYXRjaDoKICAgICAgICByZXR1cm4gMQogICAgZG9tYWluID0gbWF0Y2guZ3JvdXAoMSkKICAgIG51bWJlciA9IG1hdGNoLmdyb3VwKDIpCiAgICBtYXhfc3RlcCA9IDAKICAgIGlmIFJVTl9ESVIuZXhpc3RzKCk6CiAgICAgICAgZm9yIHBhdGggaW4gUlVOX0RJUi5nbG9iKGYiUlVOLVJFUS17ZG9tYWlufS17bnVtYmVyfS1zdGVwLSoubWQiKToKICAgICAgICAgICAgcnVuX21hdGNoID0gUlVOX0lEX1BBVFRFUk4ubWF0Y2gocGF0aC5zdGVtKQogICAgICAgICAgICBpZiBydW5fbWF0Y2ggYW5kIHJ1bl9tYXRjaC5ncm91cCgxKSA9PSAiUkVRIjoKICAgICAgICAgICAgICAgIHN0ZXAgPSBpbnQocnVuX21hdGNoLmdyb3VwKDQpKQogICAgICAgICAgICAgICAgaWYgc3RlcCA+IG1heF9zdGVwOgogICAgICAgICAgICAgICAgICAgIG1heF9zdGVwID0gc3RlcAogICAgcmV0dXJuIG1heF9zdGVwICsgMQoKCmRlZiB1cGRhdGVfbWV0YV9saW5lKHRleHQ6IHN0ciwga2V5OiBzdHIsIHZhbHVlOiBzdHIpIC0+IHN0cjoKICAgIGxpbmVzID0gdGV4dC5zcGxpdGxpbmVzKCkKICAgIHVwZGF0ZWQgPSBGYWxzZQogICAgZm9yIGksIGxpbmUgaW4gZW51bWVyYXRlKGxpbmVzKToKICAgICAgICBpZiBsaW5lLnN0YXJ0c3dpdGgoIj4gKioiKSBhbmQgbGluZS5zcGxpdCgiKioiLCAyKVsxXS5zdHJpcCgpID09IGtleToKICAgICAgICAgICAgbGluZXNbaV0gPSBmIj4gKip7a2V5fSoqOiB7dmFsdWV9IgogICAgICAgICAgICB1cGRhdGVkID0gVHJ1ZQogICAgICAgICAgICBicmVhawogICAgaWYgbm90IHVwZGF0ZWQ6CiAgICAgICAgaW5zZXJ0X2F0ID0gMSBpZiBsaW5lcyBlbHNlIDAKICAgICAgICBsaW5lcy5pbnNlcnQoaW5zZXJ0X2F0LCBmIj4gKip7a2V5fSoqOiB7dmFsdWV9IikKICAgIHJldHVybiAiXG4iLmpvaW4obGluZXMpICsgIlxuIgoKCmRlZiBub3JtYWxpemVfc3RhdHVzKHZhbHVlOiBzdHIpIC0+IHN0cjoKICAgIHJldHVybiB2YWx1ZS5zdHJpcCgpLmxvd2VyKCkKCgpkZWYgcGFyc2VfY29tcGxldGVkX2RhdGUodmFsdWU6IE9wdGlvbmFsW3N0cl0pIC0+IE9wdGlvbmFsW2RhdGV0aW1lXToKICAgIGlmIG5vdCB2YWx1ZToKICAgICAgICByZXR1cm4gTm9uZQogICAgcmF3ID0gdmFsdWUuc3RyaXAoKQogICAgaWYgcmF3ID09ICItIjoKICAgICAgICByZXR1cm4gTm9uZQogICAgdHJ5OgogICAgICAgIHJldHVybiBkYXRldGltZS5zdHJwdGltZShyYXcsICIlWS0lbS0lZCIpCiAgICBleGNlcHQgVmFsdWVFcnJvcjoKICAgICAgICByZXR1cm4gTm9uZQoKCmRlZiBwYXJzZV9hZmZlY3RlZF9hcnRpZmFjdHModGV4dDogc3RyKSAtPiBkaWN0W3N0ciwgbGlzdFtzdHJdXToKICAgIGFydGlmYWN0cyA9IHsiQ3JlYXRlIjogW10sICJNb2RpZnkiOiBbXSwgIlJlYWQiOiBbXX0KICAgIGZvciBsaW5lIGluIHRleHQuc3BsaXRsaW5lcygpOgogICAgICAgIGxpbmUgPSBsaW5lLnN0cmlwKCkKICAgICAgICBmb3Iga2V5IGluIGFydGlmYWN0cy5rZXlzKCk6CiAgICAgICAgICAgIHByZWZpeCA9IGYiLSB7a2V5fToiCiAgICAgICAgICAgIGlmIGxpbmUuc3RhcnRzd2l0aChwcmVmaXgpOgogICAgICAgICAgICAgICAgcmVtYWluZGVyID0gbGluZVtsZW4ocHJlZml4KSA6XS5zdHJpcCgpCiAgICAgICAgICAgICAgICBpZiByZW1haW5kZXI6CiAgICAgICAgICAgICAgICAgICAgcGFydHMgPSBbcC5zdHJpcCgpIGZvciBwIGluIHJlbWFpbmRlci5zcGxpdCgiLCIpIGlmIHAuc3RyaXAoKV0KICAgICAgICAgICAgICAgICAgICBhcnRpZmFjdHNba2V5XS5leHRlbmQocGFydHMpCiAgICByZXR1cm4gYXJ0aWZhY3RzCgoKZGVmIHVwZGF0ZV9icmllZl9zdGF0dXMoYnJpZWZfaWQ6IHN0ciwgc3RhdHVzOiBzdHIpIC0+IGJvb2w6CiAgICBpZiBub3QgQlJJRUZfSURfUEFUVEVSTi5tYXRjaChicmllZl9pZCk6CiAgICAgICAgcHJpbnQoZiJbV0FSTl0gSW52YWxpZCBCUklFRiBJRCBpbiBSVU4gbWV0YToge2JyaWVmX2lkfSIpCiAgICAgICAgcmV0dXJuIEZhbHNlCiAgICBicmllZl9wYXRoID0gQlJJRUZfRElSIC8gZiJ7YnJpZWZfaWR9Lm1kIgogICAgaWYgbm90IGJyaWVmX3BhdGguZXhpc3RzKCk6CiAgICAgICAgcHJpbnQoZiJbV0FSTl0gQlJJRUYgbm90IGZvdW5kIGZvciBSVU46IHticmllZl9wYXRofSIpCiAgICAgICAgcmV0dXJuIEZhbHNlCiAgICBicmllZl90ZXh0ID0gcmVhZF90ZXh0KGJyaWVmX3BhdGgpCiAgICBicmllZl90ZXh0ID0gdXBkYXRlX21ldGFfbGluZShicmllZl90ZXh0LCAiU3RhdHVzIiwgc3RhdHVzKQogICAgd3JpdGVfdGV4dChicmllZl9wYXRoLCBicmllZl90ZXh0KQogICAgcHJpbnQoZiJbT0tdIFVwZGF0ZWQge2JyaWVmX3BhdGh9IikKICAgIHJldHVybiBUcnVlCgoKZGVmIGV4dHJhY3RfaWRzX2Zyb21fdGV4dCh0ZXh0OiBzdHIpIC0+IGxpc3Rbc3RyXToKICAgIHJldHVybiByZS5maW5kYWxsKHIiKD86UkVRfFJVTEV8QURSfENRfEJSSUVGfFJVTiktW0EtWl0rLVxkezN9KD86LXN0ZXAtXGR7Mn0pPyIsIHRleHQpCgoKZGVmIGRlcml2ZV90aXRsZSh0ZXh0OiBzdHIsIGZhbGxiYWNrOiBzdHIgPSAiVXNlciBSZXF1ZXN0IikgLT4gc3RyOgogICAgdGl0bGVfc3JjID0gIiAiLmpvaW4odGV4dC5zdHJpcCgpLnNwbGl0bGluZXMoKSkuc3RyaXAoKQogICAgaWYgbm90IHRpdGxlX3NyYzoKICAgICAgICByZXR1cm4gZmFsbGJhY2sKICAgIHJldHVybiB0aXRsZV9zcmNbOjYwXSArICgiLi4uIiBpZiBsZW4odGl0bGVfc3JjKSA+IDYwIGVsc2UgIiIpCgoKZGVmIGlzX3JlbGF0aXZlX3RvKHBhdGg6IFBhdGgsIGJhc2U6IFBhdGgpIC0+IGJvb2w6CiAgICB0cnk6CiAgICAgICAgcGF0aC5yZWxhdGl2ZV90byhiYXNlKQogICAgICAgIHJldHVybiBUcnVlCiAgICBleGNlcHQgVmFsdWVFcnJvcjoKICAgICAgICByZXR1cm4gRmFsc2UKCgpkZWYgcmVxX2lkX2Zyb21fcnVuX2lkKHJ1bl9pZDogc3RyKSAtPiBPcHRpb25hbFtzdHJdOgogICAgbWF0Y2ggPSBSVU5fSURfUEFUVEVSTi5tYXRjaChydW5faWQpCiAgICBpZiBub3QgbWF0Y2g6CiAgICAgICAgcmV0dXJuIE5vbmUKICAgIGtpbmQsIGRvbWFpbiwgbnVtYmVyLCBfc3RlcCA9IG1hdGNoLmdyb3VwcygpCiAgICBpZiBraW5kICE9ICJSRVEiOgogICAgICAgIHJldHVybiBOb25lCiAgICByZXR1cm4gZiJSRVEte2RvbWFpbn0te251bWJlcn0iCgoKZGVmIGRldGVjdF9naXRfaGFzaCgpIC0+IE9wdGlvbmFsW3N0cl06CiAgICB0cnk6CiAgICAgICAgcmVzdWx0ID0gc3VicHJvY2Vzcy5ydW4oCiAgICAgICAgICAgIFsiZ2l0IiwgInJldi1wYXJzZSIsICJIRUFEIl0sCiAgICAgICAgICAgIGNhcHR1cmVfb3V0cHV0PVRydWUsCiAgICAgICAgICAgIHRleHQ9VHJ1ZSwKICAgICAgICAgICAgY2hlY2s9VHJ1ZSwKICAgICAgICApCiAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgIHJldHVybiBOb25lCiAgICB2YWx1ZSA9IHJlc3VsdC5zdGRvdXQuc3RyaXAoKQogICAgcmV0dXJuIHZhbHVlIGlmIHZhbHVlIGVsc2UgTm9uZQoKCmRlZiB3cml0ZV9sYXN0X3J1bihzdGF0ZTogZGljdCkgLT4gTm9uZToKICAgIGVuc3VyZV9kaXIoU1RBVEVfRElSKQogICAgd3JpdGVfdGV4dChMQVNUX1JVTl9QQVRILCBqc29uLmR1bXBzKHN0YXRlLCBpbmRlbnQ9MikgKyAiXG4iKQoKCiMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KIyBTeW5jIHV0aWxpdGllcwojID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CgpkZWYgcGFyc2VfY2hlY2tib3hlcyh0ZXh0OiBzdHIpIC0+IGxpc3RbdHVwbGVbaW50LCBib29sLCBzdHJdXToKICAgICIiIlBhcnNlIGNoZWNrYm94ZXMgZnJvbSB0ZXh0LiBSZXR1cm5zIGxpc3Qgb2YgKGxpbmVfbnVtLCBpc19jaGVja2VkLCBjb250ZW50KS4iIiIKICAgIHJlc3VsdHMgPSBbXQogICAgZm9yIGksIGxpbmUgaW4gZW51bWVyYXRlKHRleHQuc3BsaXRsaW5lcygpKToKICAgICAgICBpZiBDSEVDS0JPWF9DSEVDS0VELm1hdGNoKGxpbmUpOgogICAgICAgICAgICBtYXRjaCA9IENIRUNLQk9YX0NIRUNLRUQubWF0Y2gobGluZSkKICAgICAgICAgICAgcmVzdWx0cy5hcHBlbmQoKGksIFRydWUsIG1hdGNoLmdyb3VwKDIpLnN0cmlwKCkpKQogICAgICAgIGVsaWYgQ0hFQ0tCT1hfVU5DSEVDS0VELm1hdGNoKGxpbmUpOgogICAgICAgICAgICBtYXRjaCA9IENIRUNLQk9YX1VOQ0hFQ0tFRC5tYXRjaChsaW5lKQogICAgICAgICAgICByZXN1bHRzLmFwcGVuZCgoaSwgRmFsc2UsIG1hdGNoLmdyb3VwKDIpLnN0cmlwKCkpKQogICAgcmV0dXJuIHJlc3VsdHMKCgpkZWYgcGFyc2VfdHJhY2VhYmlsaXR5KHRleHQ6IHN0cikgLT4gZGljdFtzdHIsIHR1cGxlW3N0ciwgc3RyXV06CiAgICAiIiJQYXJzZSB0cmFjZWFiaWxpdHkgbGlua3MuIFJldHVybnMge2xpbmtfdHlwZTogKGlkLCBwYXRoKX0uIiIiCiAgICByZXN1bHRzID0ge30KICAgIGZvciBtYXRjaCBpbiBUUkFDRUFCSUxJVFlfTElOS19SRS5maW5kaXRlcih0ZXh0KToKICAgICAgICBsaW5rX2lkID0gbWF0Y2guZ3JvdXAoMSkuc3RyaXAoKQogICAgICAgIGxpbmtfcGF0aCA9IG1hdGNoLmdyb3VwKDIpLnN0cmlwKCkKICAgICAgICAjIERldGVybWluZSBsaW5rIHR5cGUgZnJvbSBjb250ZXh0CiAgICAgICAgZnVsbF9tYXRjaCA9IG1hdGNoLmdyb3VwKDApCiAgICAgICAgaWYgIkltcGxlbWVudHMiIGluIGZ1bGxfbWF0Y2g6CiAgICAgICAgICAgIHJlc3VsdHNbIkltcGxlbWVudHMiXSA9IChsaW5rX2lkLCBsaW5rX3BhdGgpCiAgICAgICAgZWxpZiAiQW5zd2VycyIgaW4gZnVsbF9tYXRjaDoKICAgICAgICAgICAgcmVzdWx0c1siQW5zd2VycyJdID0gKGxpbmtfaWQsIGxpbmtfcGF0aCkKICAgICAgICBlbGlmICJTb2x2ZWQgYnkiIGluIGZ1bGxfbWF0Y2g6CiAgICAgICAgICAgIHJlc3VsdHNbIlNvbHZlZCBieSJdID0gKGxpbmtfaWQsIGxpbmtfcGF0aCkKICAgICAgICBlbGlmICJJbXBsZW1lbnRlZCBieSIgaW4gZnVsbF9tYXRjaDoKICAgICAgICAgICAgcmVzdWx0c1siSW1wbGVtZW50ZWQgYnkiXSA9IChsaW5rX2lkLCBsaW5rX3BhdGgpCiAgICByZXR1cm4gcmVzdWx0cwoKCmRlZiByZXNvbHZlX2xpbmtlZF9kb2NzKHJ1bl9wYXRoOiBQYXRoKSAtPiBkaWN0W3N0ciwgUGF0aF06CiAgICAiIiJSZXNvbHZlIFJVTiAtPiBCUklFRiAtPiBSRVEgY2hhaW4uIFJldHVybnMge2RvY190eXBlOiBwYXRofS4iIiIKICAgIGRvY3MgPSB7fQogICAgdGV4dCA9IHJlYWRfdGV4dChydW5fcGF0aCkKICAgIG1ldGEgPSBleHRyYWN0X21ldGEodGV4dCkKCiAgICAjIFJVTiAtPiBSRVEgKGRpcmVjdCkKICAgIHJlcV9pZCA9IG1ldGEuZ2V0KCJSRVEiKSBvciByZXFfaWRfZnJvbV9ydW5faWQocnVuX3BhdGguc3RlbSkKICAgIGlmIHJlcV9pZCBhbmQgUkVRX0lEX1BBVFRFUk4ubWF0Y2gocmVxX2lkKToKICAgICAgICByZXFfcGF0aCA9IFJFUV9ESVIgLyBmIntyZXFfaWR9Lm1kIgogICAgICAgIGlmIHJlcV9wYXRoLmV4aXN0cygpOgogICAgICAgICAgICBkb2NzWyJSRVEiXSA9IHJlcV9wYXRoCiAgICAKICAgICMgUlVOIC0+IEJSSUVGCiAgICBicmllZl9pZCA9IG1ldGEuZ2V0KCJCcmllZiIpCiAgICBpZiBicmllZl9pZCBhbmQgQlJJRUZfSURfUEFUVEVSTi5tYXRjaChicmllZl9pZCk6CiAgICAgICAgYnJpZWZfcGF0aCA9IEJSSUVGX0RJUiAvIGYie2JyaWVmX2lkfS5tZCIKICAgICAgICBpZiBicmllZl9wYXRoLmV4aXN0cygpOgogICAgICAgICAgICBkb2NzWyJCUklFRiJdID0gYnJpZWZfcGF0aAogICAgICAgICAgICAKICAgICAgICAgICAgIyBCUklFRiAtPiBSRVEgKHZpYSBJbXBsZW1lbnRzIGxpbmspCiAgICAgICAgICAgIGJyaWVmX3RleHQgPSByZWFkX3RleHQoYnJpZWZfcGF0aCkKICAgICAgICAgICAgdHJhY2UgPSBwYXJzZV90cmFjZWFiaWxpdHkoYnJpZWZfdGV4dCkKICAgICAgICAgICAgaWYgIkltcGxlbWVudHMiIGluIHRyYWNlOgogICAgICAgICAgICAgICAgcmVxX2lkLCByZXFfcmVsX3BhdGggPSB0cmFjZVsiSW1wbGVtZW50cyJdCiAgICAgICAgICAgICAgICByZXFfcGF0aCA9IChicmllZl9wYXRoLnBhcmVudCAvIHJlcV9yZWxfcGF0aCkucmVzb2x2ZSgpCiAgICAgICAgICAgICAgICBpZiByZXFfcGF0aC5leGlzdHMoKToKICAgICAgICAgICAgICAgICAgICBkb2NzWyJSRVEiXSA9IHJlcV9wYXRoCiAgICAKICAgIHJldHVybiBkb2NzCgoKZGVmIGNvbXB1dGVfc3RhdHVzX2Zyb21fY2hlY2tib3hlcyh0ZXh0OiBzdHIpIC0+IE9wdGlvbmFsW3N0cl06CiAgICAiIiJDb21wdXRlIHN0YXR1cyBiYXNlZCBvbiBjaGVja2JveCBjb21wbGV0aW9uIGluIFN0ZXBzL1ZlcmlmaWNhdGlvbiBzZWN0aW9ucy4iIiIKICAgIGNoZWNrYm94ZXMgPSBwYXJzZV9jaGVja2JveGVzKHRleHQpCiAgICBpZiBub3QgY2hlY2tib3hlczoKICAgICAgICByZXR1cm4gTm9uZQogICAgCiAgICB0b3RhbCA9IGxlbihjaGVja2JveGVzKQogICAgY2hlY2tlZCA9IHN1bSgxIGZvciBfLCBpc19jaGVja2VkLCBfIGluIGNoZWNrYm94ZXMgaWYgaXNfY2hlY2tlZCkKICAgIAogICAgaWYgY2hlY2tlZCA9PSAwOgogICAgICAgIHJldHVybiAiUGxhbm5lZCIKICAgIGVsaWYgY2hlY2tlZCA9PSB0b3RhbDoKICAgICAgICByZXR1cm4gIkNvbXBsZXRlZCIKICAgIGVsc2U6CiAgICAgICAgcmV0dXJuICJJblByb2dyZXNzIgoKCmRlZiBnZW5lcmF0ZV9zeW5jX2RpZmYocnVuX3BhdGg6IFBhdGgpIC0+IGRpY3Q6CiAgICAiIiJHZW5lcmF0ZSBkaWZmIGZvciBzeW5jIG9wZXJhdGlvbi4gUmV0dXJucyBjaGFuZ2VzIHRvIGFwcGx5LiIiIgogICAgZGlmZiA9IHsKICAgICAgICAicnVuIjogeyJwYXRoIjogcnVuX3BhdGgsICJjaGFuZ2VzIjogW119LAogICAgICAgICJicmllZiI6IE5vbmUsCiAgICAgICAgInJlcSI6IE5vbmUsCiAgICB9CiAgICAKICAgIHJ1bl90ZXh0ID0gcmVhZF90ZXh0KHJ1bl9wYXRoKQogICAgcnVuX21ldGEgPSBleHRyYWN0X21ldGEocnVuX3RleHQpCiAgICBydW5fY2hlY2tib3hlcyA9IHBhcnNlX2NoZWNrYm94ZXMocnVuX3RleHQpCiAgICAKICAgICMgQ29tcHV0ZSBSVU4gc3RhdHVzIGZyb20gY2hlY2tib3hlcwogICAgY29tcHV0ZWRfc3RhdHVzID0gY29tcHV0ZV9zdGF0dXNfZnJvbV9jaGVja2JveGVzKHJ1bl90ZXh0KQogICAgY3VycmVudF9zdGF0dXMgPSBydW5fbWV0YS5nZXQoIlN0YXR1cyIsICIiKQogICAgCiAgICBpZiBjb21wdXRlZF9zdGF0dXMgYW5kIG5vcm1hbGl6ZV9zdGF0dXMoY29tcHV0ZWRfc3RhdHVzKSAhPSBub3JtYWxpemVfc3RhdHVzKGN1cnJlbnRfc3RhdHVzKToKICAgICAgICBkaWZmWyJydW4iXVsiY2hhbmdlcyJdLmFwcGVuZCh7CiAgICAgICAgICAgICJ0eXBlIjogInN0YXR1cyIsCiAgICAgICAgICAgICJmcm9tIjogY3VycmVudF9zdGF0dXMsCiAgICAgICAgICAgICJ0byI6IGNvbXB1dGVkX3N0YXR1cywKICAgICAgICB9KQogICAgCiAgICAjIFJlc29sdmUgbGlua2VkIGRvY3VtZW50cwogICAgbGlua2VkID0gcmVzb2x2ZV9saW5rZWRfZG9jcyhydW5fcGF0aCkKICAgIAogICAgIyBCUklFRiBzeW5jCiAgICBpZiAiQlJJRUYiIGluIGxpbmtlZDoKICAgICAgICBicmllZl9wYXRoID0gbGlua2VkWyJCUklFRiJdCiAgICAgICAgYnJpZWZfdGV4dCA9IHJlYWRfdGV4dChicmllZl9wYXRoKQogICAgICAgIGJyaWVmX21ldGEgPSBleHRyYWN0X21ldGEoYnJpZWZfdGV4dCkKICAgICAgICBicmllZl9zdGF0dXMgPSBicmllZl9tZXRhLmdldCgiU3RhdHVzIiwgIiIpCiAgICAgICAgCiAgICAgICAgZGlmZlsiYnJpZWYiXSA9IHsKICAgICAgICAgICAgInBhdGgiOiBicmllZl9wYXRoLAogICAgICAgICAgICAiY2hhbmdlcyI6IFtdLAogICAgICAgIH0KICAgICAgICAKICAgICAgICAjIFN5bmMgc3RhdHVzCiAgICAgICAgaWYgY29tcHV0ZWRfc3RhdHVzIGFuZCBub3JtYWxpemVfc3RhdHVzKGJyaWVmX3N0YXR1cykgIT0gbm9ybWFsaXplX3N0YXR1cyhjb21wdXRlZF9zdGF0dXMpOgogICAgICAgICAgICBkaWZmWyJicmllZiJdWyJjaGFuZ2VzIl0uYXBwZW5kKHsKICAgICAgICAgICAgICAgICJ0eXBlIjogInN0YXR1cyIsCiAgICAgICAgICAgICAgICAiZnJvbSI6IGJyaWVmX3N0YXR1cywKICAgICAgICAgICAgICAgICJ0byI6IGNvbXB1dGVkX3N0YXR1cywKICAgICAgICAgICAgfSkKICAgIAogICAgIyBSRVEgcGF0Y2ggKGRvbid0IGF1dG8tbW9kaWZ5LCBnZW5lcmF0ZSBwYXRjaCkKICAgIGlmICJSRVEiIGluIGxpbmtlZDoKICAgICAgICByZXFfcGF0aCA9IGxpbmtlZFsiUkVRIl0KICAgICAgICByZXFfdGV4dCA9IHJlYWRfdGV4dChyZXFfcGF0aCkKICAgICAgICByZXFfbWV0YSA9IGV4dHJhY3RfbWV0YShyZXFfdGV4dCkKICAgICAgICByZXFfY2hlY2tib3hlcyA9IHBhcnNlX2NoZWNrYm94ZXMocmVxX3RleHQpCiAgICAgICAgCiAgICAgICAgZGlmZlsicmVxIl0gPSB7CiAgICAgICAgICAgICJwYXRoIjogcmVxX3BhdGgsCiAgICAgICAgICAgICJjaGFuZ2VzIjogW10sCiAgICAgICAgICAgICJjaGVja2JveGVzIjogcmVxX2NoZWNrYm94ZXMsCiAgICAgICAgfQogICAgICAgIAogICAgICAgICMgQ2hlY2sgaWYgUkVRIGFjY2VwdGFuY2UgY3JpdGVyaWEgc2hvdWxkIGJlIHVwZGF0ZWQgYmFzZWQgb24gUlVOIGNvbXBsZXRpb24KICAgICAgICBpZiBjb21wdXRlZF9zdGF0dXMgPT0gIkNvbXBsZXRlZCIgYW5kIHJlcV9jaGVja2JveGVzOgogICAgICAgICAgICAjIFN1Z2dlc3QgbWFya2luZyByZWxhdGVkIGNoZWNrYm94ZXMKICAgICAgICAgICAgZGlmZlsicmVxIl1bImNoYW5nZXMiXS5hcHBlbmQoewogICAgICAgICAgICAgICAgInR5cGUiOiAiY2hlY2tib3hfc3VnZ2VzdGlvbiIsCiAgICAgICAgICAgICAgICAibWVzc2FnZSI6IGYiUlVOIGNvbXBsZXRlZC4gQ29uc2lkZXIgdXBkYXRpbmcgYWNjZXB0YW5jZSBjcml0ZXJpYSBpbiB7cmVxX3BhdGgubmFtZX0iLAogICAgICAgICAgICB9KQogICAgCiAgICByZXR1cm4gZGlmZgoKCmRlZiBwcmludF9zeW5jX2RpZmYoZGlmZjogZGljdCkgLT4gTm9uZToKICAgICIiIlByaW50IHN5bmMgZGlmZiBpbiBodW1hbi1yZWFkYWJsZSBmb3JtYXQuIiIiCiAgICBydW5faW5mbyA9IGRpZmZbInJ1biJdCiAgICBwcmludChmIlxuW1NZTkNdIHtydW5faW5mb1sncGF0aCddLnN0ZW19IikKICAgIAogICAgaWYgcnVuX2luZm9bImNoYW5nZXMiXToKICAgICAgICBmb3IgY2hhbmdlIGluIHJ1bl9pbmZvWyJjaGFuZ2VzIl06CiAgICAgICAgICAgIGlmIGNoYW5nZVsidHlwZSJdID09ICJzdGF0dXMiOgogICAgICAgICAgICAgICAgcHJpbnQoZiIgIOKGkiBSVU46IFN0YXR1cyB7Y2hhbmdlWydmcm9tJ119IOKGkiB7Y2hhbmdlWyd0byddfSIpCiAgICBlbHNlOgogICAgICAgIHByaW50KCIgIOKGkiBSVU46IChubyBjaGFuZ2VzKSIpCiAgICAKICAgIGlmIGRpZmZbImJyaWVmIl06CiAgICAgICAgYnJpZWZfaW5mbyA9IGRpZmZbImJyaWVmIl0KICAgICAgICBpZiBicmllZl9pbmZvWyJjaGFuZ2VzIl06CiAgICAgICAgICAgIGZvciBjaGFuZ2UgaW4gYnJpZWZfaW5mb1siY2hhbmdlcyJdOgogICAgICAgICAgICAgICAgaWYgY2hhbmdlWyJ0eXBlIl0gPT0gInN0YXR1cyI6CiAgICAgICAgICAgICAgICAgICAgcHJpbnQoZiIgIOKGkiBCUklFRiAoe2JyaWVmX2luZm9bJ3BhdGgnXS5zdGVtfSk6IFN0YXR1cyB7Y2hhbmdlWydmcm9tJ119IOKGkiB7Y2hhbmdlWyd0byddfSIpCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcHJpbnQoZiIgIOKGkiBCUklFRiAoe2JyaWVmX2luZm9bJ3BhdGgnXS5zdGVtfSk6IChubyBjaGFuZ2VzKSIpCiAgICAKICAgIGlmIGRpZmZbInJlcSJdOgogICAgICAgIHJlcV9pbmZvID0gZGlmZlsicmVxIl0KICAgICAgICBpZiByZXFfaW5mb1siY2hhbmdlcyJdOgogICAgICAgICAgICBmb3IgY2hhbmdlIGluIHJlcV9pbmZvWyJjaGFuZ2VzIl06CiAgICAgICAgICAgICAgICBpZiBjaGFuZ2VbInR5cGUiXSA9PSAiY2hlY2tib3hfc3VnZ2VzdGlvbiI6CiAgICAgICAgICAgICAgICAgICAgcHJpbnQoZiIgIOKGkiBSRVEgKHtyZXFfaW5mb1sncGF0aCddLnN0ZW19KTogW1BhdGNoIHJlcXVpcmVkXSB7Y2hhbmdlWydtZXNzYWdlJ119IikKICAgICAgICBlbHNlOgogICAgICAgICAgICBwcmludChmIiAg4oaSIFJFUSAoe3JlcV9pbmZvWydwYXRoJ10uc3RlbX0pOiAobm8gY2hhbmdlcykiKQoKCmRlZiBhcHBseV9icmllZl9jaGFuZ2VzKGRpZmY6IGRpY3QpIC0+IGJvb2w6CiAgICAiIiJBcHBseSBjaGFuZ2VzIHRvIEJSSUVGIGRvY3VtZW50LiIiIgogICAgaWYgbm90IGRpZmZbImJyaWVmIl0gb3Igbm90IGRpZmZbImJyaWVmIl1bImNoYW5nZXMiXToKICAgICAgICByZXR1cm4gRmFsc2UKICAgIAogICAgYnJpZWZfcGF0aCA9IGRpZmZbImJyaWVmIl1bInBhdGgiXQogICAgYnJpZWZfdGV4dCA9IHJlYWRfdGV4dChicmllZl9wYXRoKQogICAgCiAgICBmb3IgY2hhbmdlIGluIGRpZmZbImJyaWVmIl1bImNoYW5nZXMiXToKICAgICAgICBpZiBjaGFuZ2VbInR5cGUiXSA9PSAic3RhdHVzIjoKICAgICAgICAgICAgYnJpZWZfdGV4dCA9IHVwZGF0ZV9tZXRhX2xpbmUoYnJpZWZfdGV4dCwgIlN0YXR1cyIsIGNoYW5nZVsidG8iXSkKICAgIAogICAgd3JpdGVfdGV4dChicmllZl9wYXRoLCBicmllZl90ZXh0KQogICAgcHJpbnQoZiJbT0tdIFVwZGF0ZWQge2JyaWVmX3BhdGh9IikKICAgIHJldHVybiBUcnVlCgoKZGVmIHdyaXRlX3JlcV9wYXRjaChkaWZmOiBkaWN0KSAtPiBPcHRpb25hbFtQYXRoXToKICAgICIiIldyaXRlIFJFUSBwYXRjaCBmaWxlLiIiIgogICAgaWYgbm90IGRpZmZbInJlcSJdIG9yIG5vdCBkaWZmWyJyZXEiXVsiY2hhbmdlcyJdOgogICAgICAgIHJldHVybiBOb25lCiAgICAKICAgIGVuc3VyZV9kaXIoUEFUQ0hfRElSKQogICAgcmVxX3BhdGggPSBkaWZmWyJyZXEiXVsicGF0aCJdCiAgICBwYXRjaF9wYXRoID0gUEFUQ0hfRElSIC8gZiJ7cmVxX3BhdGguc3RlbX0ucGF0Y2gubWQiCiAgICAKICAgIGNvbnRlbnQgPSBmIiIiIyBQYXRjaCBmb3Ige3JlcV9wYXRoLnN0ZW19Cgo+ICoqR2VuZXJhdGVkKio6IHtub3dfZGF0ZSgpfQo+ICoqU291cmNlIFJVTioqOiB7ZGlmZlsncnVuJ11bJ3BhdGgnXS5zdGVtfQoKIyMgU3VnZ2VzdGVkIENoYW5nZXMKCiIiIgogICAgZm9yIGNoYW5nZSBpbiBkaWZmWyJyZXEiXVsiY2hhbmdlcyJdOgogICAgICAgIGlmIGNoYW5nZVsidHlwZSJdID09ICJjaGVja2JveF9zdWdnZXN0aW9uIjoKICAgICAgICAgICAgY29udGVudCArPSBmIi0ge2NoYW5nZVsnbWVzc2FnZSddfVxuIgogICAgCiAgICBjb250ZW50ICs9IGYiIiIKIyMgSG93IHRvIEFwcGx5CgpgYGBiYXNoCmF0bGFzIHN5bmMge2RpZmZbJ3J1biddWydwYXRoJ10uc3RlbX0gLS1hcHBseS1yZXEKYGBgCgpPciBtYW51YWxseSBlZGl0OiB7cmVxX3BhdGh9CiIiIgogICAgCiAgICB3cml0ZV90ZXh0KHBhdGNoX3BhdGgsIGNvbnRlbnQpCiAgICBwcmludChmIltPS10gQ3JlYXRlZCBwYXRjaDoge3BhdGNoX3BhdGh9IikKICAgIHJldHVybiBwYXRjaF9wYXRoCgoKZGVmIGFwcGx5X3JlcV9jaGFuZ2VzKGRpZmY6IGRpY3QpIC0+IGJvb2w6CiAgICAiIiJBcHBseSBjaGFuZ2VzIHRvIFJFUSBkb2N1bWVudCAod2l0aCB3YXJuaW5nKS4iIiIKICAgIGlmIG5vdCBkaWZmWyJyZXEiXSBvciBub3QgZGlmZlsicmVxIl1bImNoYW5nZXMiXToKICAgICAgICByZXR1cm4gRmFsc2UKICAgIAogICAgcHJpbnQoIltXQVJOXSBNb2RpZnlpbmcgUkVRIGRvY3VtZW50IChhdXRob3JpdHkgZG9jdW1lbnQpIikKICAgIHJlcV9wYXRoID0gZGlmZlsicmVxIl1bInBhdGgiXQogICAgcmVxX3RleHQgPSByZWFkX3RleHQocmVxX3BhdGgpCiAgICAKICAgICMgRm9yIG5vdywganVzdCB1cGRhdGUgc3RhdHVzIGlmIFJVTiBpcyBjb21wbGV0ZWQKICAgIHJ1bl9jaGFuZ2VzID0gZGlmZlsicnVuIl1bImNoYW5nZXMiXQogICAgZm9yIGNoYW5nZSBpbiBydW5fY2hhbmdlczoKICAgICAgICBpZiBjaGFuZ2VbInR5cGUiXSA9PSAic3RhdHVzIiBhbmQgY2hhbmdlWyJ0byJdID09ICJDb21wbGV0ZWQiOgogICAgICAgICAgICByZXFfdGV4dCA9IHVwZGF0ZV9tZXRhX2xpbmUocmVxX3RleHQsICJTdGF0dXMiLCAiSW1wbGVtZW50ZWQiKQogICAgCiAgICB3cml0ZV90ZXh0KHJlcV9wYXRoLCByZXFfdGV4dCkKICAgIHByaW50KGYiW09LXSBVcGRhdGVkIHtyZXFfcGF0aH0iKQogICAgcmV0dXJuIFRydWUKCgpkZWYgaW5pdF9jb21tYW5kKF9hcmdzOiBhcmdwYXJzZS5OYW1lc3BhY2UpIC0+IGludDoKICAgIG92ZXJ3cml0ZSA9IGdldGF0dHIoX2FyZ3MsICJvdmVyd3JpdGUiLCBGYWxzZSkKICAgIGVuc3VyZV9kaXIoQVRMQVNfUk9PVCkKICAgIGZvciBkIGluIFsKICAgICAgICBSRVFfRElSLAogICAgICAgIFJVTEVfRElSLAogICAgICAgIEFEUl9ESVIsCiAgICAgICAgQ1FfRElSLAogICAgICAgIFZJRVdTX0RJUiwKICAgICAgICBJTkJPWF9ESVIsCiAgICAgICAgRFJBRlRTX0RJUiwKICAgICAgICBCUklFRl9ESVIsCiAgICAgICAgUlVOX0RJUiwKICAgICAgICBBUkNISVZFX0RJUiwKICAgICAgICBURU1QTEFURVNfRElSLAogICAgICAgIFNUQVRFX0RJUiwKICAgICAgICBTWVNURU1fUk9PVCAvICJwcm9tcHRzIiwKICAgICAgICBTWVNURU1fUk9PVCAvICJzcmMiLAogICAgXToKICAgICAgICBlbnN1cmVfZGlyKGQpCgogICAgZm9yIHBhdGgsIGNvbnRlbnQgaW4gbG9hZF9kZWZhdWx0X3RvcF9kb2NzKCkuaXRlbXMoKToKICAgICAgICBpZiBvdmVyd3JpdGUgb3Igbm90IHBhdGguZXhpc3RzKCk6CiAgICAgICAgICAgIHdyaXRlX3RleHQocGF0aCwgY29udGVudCkKCiAgICBmb3IgbmFtZSwgY29udGVudCBpbiBsb2FkX2RlZmF1bHRfdGVtcGxhdGVzKCkuaXRlbXMoKToKICAgICAgICB0ZW1wbGF0ZV9wYXRoID0gVEVNUExBVEVTX0RJUiAvIG5hbWUKICAgICAgICBpZiBvdmVyd3JpdGUgb3Igbm90IHRlbXBsYXRlX3BhdGguZXhpc3RzKCk6CiAgICAgICAgICAgIHdyaXRlX3RleHQodGVtcGxhdGVfcGF0aCwgY29udGVudCkKCiAgICBwcm9tcHRzX2RpciA9IFNZU1RFTV9ST09UIC8gInByb21wdHMiCiAgICBmb3IgbmFtZSwgY29udGVudCBpbiBsb2FkX2RlZmF1bHRfcHJvbXB0cygpLml0ZW1zKCk6CiAgICAgICAgcHJvbXB0X3BhdGggPSBwcm9tcHRzX2RpciAvIG5hbWUKICAgICAgICBpZiBvdmVyd3JpdGUgb3Igbm90IHByb21wdF9wYXRoLmV4aXN0cygpOgogICAgICAgICAgICB3cml0ZV90ZXh0KHByb21wdF9wYXRoLCBjb250ZW50KQogICAgICAgICAgICBwcmludChmIltPS10gQ3JlYXRlZCB7cHJvbXB0X3BhdGh9IikKCiAgICBmb3IgbmFtZSwgY29udGVudCBpbiBsb2FkX2RlZmF1bHRfc3lzdGVtX2ZpbGVzKCkuaXRlbXMoKToKICAgICAgICBzeXN0ZW1fcGF0aCA9IFNZU1RFTV9ST09UIC8gbmFtZQogICAgICAgIGlmIG92ZXJ3cml0ZSBvciBub3Qgc3lzdGVtX3BhdGguZXhpc3RzKCk6CiAgICAgICAgICAgIHdyaXRlX3RleHQoc3lzdGVtX3BhdGgsIGNvbnRlbnQpCiAgICAgICAgICAgIHByaW50KGYiW09LXSBDcmVhdGVkIHtzeXN0ZW1fcGF0aH0iKQoKICAgIHNyY19kaXIgPSBTWVNURU1fUk9PVCAvICJzcmMiCiAgICBmb3IgbmFtZSwgY29udGVudCBpbiBsb2FkX2RlZmF1bHRfc3JjX2ZpbGVzKCkuaXRlbXMoKToKICAgICAgICBzcmNfcGF0aCA9IHNyY19kaXIgLyBuYW1lCiAgICAgICAgaWYgb3ZlcndyaXRlIG9yIG5vdCBzcmNfcGF0aC5leGlzdHMoKToKICAgICAgICAgICAgd3JpdGVfdGV4dChzcmNfcGF0aCwgY29udGVudCkKICAgICAgICAgICAgcHJpbnQoZiJbT0tdIENyZWF0ZWQge3NyY19wYXRofSIpCgogICAgaWYgbm90IExBU1RfUlVOX1BBVEguZXhpc3RzKCk6CiAgICAgICAgd3JpdGVfbGFzdF9ydW4oeyJzdGFnZSI6ICJpZGxlIiwgInVwZGF0ZWRfYXQiOiBub3dfaXNvKCl9KQoKICAgIHByaW50KCJbT0tdIEF0bGFzIHN0cnVjdHVyZSBpbml0aWFsaXplZC4iKQogICAgcHJpbnQoIltJTkZPXSBSdW4gdGhlIHByb21wdCBpbiAuYXRsYXMvLnN5c3RlbS9wcm9tcHRzL29uYm9hcmRpbmcubWQgdG8gY29tcGxldGUgc2V0dXAuIikKICAgIHJldHVybiAwCgoKZGVmIGNyZWF0ZV9icmllZl9kb2ModGV4dDogc3RyLCBkb21haW46IHN0cikgLT4gUGF0aDoKICAgIGJyaWVmX2lkID0gbmV4dF9pZCgiQlJJRUYiLCBkb21haW4sIEJSSUVGX0RJUiwgQlJJRUZfSURfUEFUVEVSTikKICAgIHRpdGxlID0gZGVyaXZlX3RpdGxlKHRleHQpCiAgICBjb250ZW50ID0gZiIiIiMgW3ticmllZl9pZH1dIHt0aXRsZX0KCj4gKipJRCoqOiB7YnJpZWZfaWR9Cj4gKipEb21haW4qKjoge2RvbWFpbn0KPiAqKlN0YXR1cyoqOiBBY3RpdmUKPiAqKkRhdGUqKjoge25vd19kYXRlKCl9CgojIyAxLiBVc2VyIFJlcXVlc3QKe3RleHQuc3RyaXAoKX0KCiMjIDIuIEludGVudCBTdW1tYXJ5Ci0gR29hbDogCi0gUHJvYmxlbTogCgojIyAzLiBBZmZlY3RlZCBBcnRpZmFjdHMKLSBDcmVhdGU6IAotIE1vZGlmeTogCi0gUmVhZDogCgojIyA0LiBQcm9wb3NlZCBDaGFuZ2VzCjEuIAoyLiAKCiMjIDUuIFZlcmlmaWNhdGlvbiBDcml0ZXJpYQotIFsgXSAKIiIiCiAgICBwYXRoID0gQlJJRUZfRElSIC8gZiJ7YnJpZWZfaWR9Lm1kIgogICAgZW5zdXJlX2RpcihCUklFRl9ESVIpCiAgICB3cml0ZV90ZXh0KHBhdGgsIGNvbnRlbnQpCiAgICByZXR1cm4gcGF0aAoKCmRlZiBjYXB0dXJlX2NvbW1hbmQoYXJnczogYXJncGFyc2UuTmFtZXNwYWNlKSAtPiBpbnQ6CiAgICBkb21haW4gPSBhcmdzLmRvbWFpbi51cHBlcigpCiAgICB0ZXh0ID0gYXJncy50ZXh0LnN0cmlwKCkKICAgIGlmIG5vdCB0ZXh0OgogICAgICAgIHByaW50KCJbRVJSXSBFbXB0eSBpbnB1dC4iKQogICAgICAgIHJldHVybiAxCgogICAgdGl0bGUgPSBkZXJpdmVfdGl0bGUodGV4dCkKICAgIHJlcV9pZHMgPSBbcmlkIGZvciByaWQgaW4gZXh0cmFjdF9pZHNfZnJvbV90ZXh0KHRleHQpIGlmIHJpZC5zdGFydHN3aXRoKCJSRVEtIildCiAgICBpZiBub3QgcmVxX2lkczoKICAgICAgICByZXFfaWRzID0gW25leHRfaWQoIlJFUSIsIGRvbWFpbiwgUkVRX0RJUiwgUkVRX0lEX1BBVFRFUk4pXQoKICAgIGNyZWF0ZWQgPSBbXQogICAgZm9yIHJlcV9pZCBpbiByZXFfaWRzOgogICAgICAgIGlmIG5vdCBSRVFfSURfUEFUVEVSTi5tYXRjaChyZXFfaWQpOgogICAgICAgICAgICBwcmludChmIltXQVJOXSBTa2lwcGluZyBpbnZhbGlkIFJFUSBJRDoge3JlcV9pZH0iKQogICAgICAgICAgICBjb250aW51ZQogICAgICAgIGNyZWF0ZV9yZXFfc3R1YihyZXFfaWQsIHRpdGxlPXRpdGxlKQogICAgICAgIHJlcV9wYXRoID0gUkVRX0RJUiAvIGYie3JlcV9pZH0ubWQiCiAgICAgICAgaWYgcmVxX3BhdGguZXhpc3RzKCk6CiAgICAgICAgICAgIGFwcGVuZF9jYXB0dXJlX25vdGUocmVxX3BhdGgsIHRleHQpCiAgICAgICAgdmlld19wYXRoID0gZW5zdXJlX3ZpZXdfZG9jKHJlcV9pZCwgdGl0bGUpCiAgICAgICAgY3JlYXRlZC5hcHBlbmQoKHJlcV9wYXRoLCB2aWV3X3BhdGgpKQoKICAgIGlmIGdldGF0dHIoYXJncywgInRvIiwgTm9uZSkgPT0gImJyaWVmIjoKICAgICAgICBicmllZl9wYXRoID0gY3JlYXRlX2JyaWVmX2RvYyh0ZXh0LCBkb21haW4pCiAgICAgICAgcHJpbnQoZiJbT0tdIENyZWF0ZWQge2JyaWVmX3BhdGh9IikKCiAgICBmb3IgcmVxX3BhdGgsIHZpZXdfcGF0aCBpbiBjcmVhdGVkOgogICAgICAgIHByaW50KGYiW09LXSBVcGRhdGVkIHtyZXFfcGF0aH0iKQogICAgICAgIHByaW50KGYiW09LXSBVcGRhdGVkIHt2aWV3X3BhdGh9IikKICAgIHJldHVybiAwCgoKZGVmIGNyZWF0ZV9yZXFfc3R1YihyZXFfaWQ6IHN0ciwgdGl0bGU6IE9wdGlvbmFsW3N0cl0gPSBOb25lKSAtPiBOb25lOgogICAgcGF0aCA9IFJFUV9ESVIgLyBmIntyZXFfaWR9Lm1kIgogICAgaWYgcGF0aC5leGlzdHMoKToKICAgICAgICByZXR1cm4KICAgIG1hdGNoID0gUkVRX0lEX1BBVFRFUk4ubWF0Y2gocmVxX2lkKQogICAgaWYgbm90IG1hdGNoOgogICAgICAgIHJldHVybgogICAgZG9tYWluID0gbWF0Y2guZ3JvdXAoMSkKICAgIHRlbXBsYXRlID0gbG9hZF90ZW1wbGF0ZSgiUkVRLm1kIikKICAgIHRpdGxlID0gdGl0bGUgb3IgIlRpdGxlIgogICAgY29udGVudCA9IHRlbXBsYXRlLnJlcGxhY2UoIlJFUS1YWFgtMDAxIiwgcmVxX2lkKQogICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgiIyBbUkVRLVhYWC0wMDFdIFRpdGxlIiwgZiIjIFt7cmVxX2lkfV0ge3RpdGxlfSIpCiAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKCJEb21haW4qKjogWFhYIiwgZiJEb21haW4qKjoge2RvbWFpbn0iKQogICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgiTGFzdCBVcGRhdGVkKio6IFlZWVktTU0tREQiLCBmIkxhc3QgVXBkYXRlZCoqOiB7bm93X2RhdGUoKX0iKQogICAgd3JpdGVfdGV4dChwYXRoLCBjb250ZW50KQoKCmRlZiBhcHBlbmRfY2FwdHVyZV9ub3RlKHBhdGg6IFBhdGgsIHRleHQ6IHN0cikgLT4gTm9uZToKICAgIG5vdGUgPSB0ZXh0LnN0cmlwKCkKICAgIGlmIG5vdCBub3RlOgogICAgICAgIHJldHVybgogICAgY29udGVudCA9IHJlYWRfdGV4dChwYXRoKQogICAgc3RhbXAgPSBub3dfZGF0ZSgpCiAgICBibG9jayA9IGYiXG4jIyBDYXB0dXJlICh7c3RhbXB9KVxue25vdGV9XG4iCiAgICBpZiBmIiMjIENhcHR1cmUgKHtzdGFtcH0pIiBpbiBjb250ZW50OgogICAgICAgIHJldHVybgogICAgd3JpdGVfdGV4dChwYXRoLCBjb250ZW50LnJzdHJpcCgpICsgYmxvY2spCgoKZGVmIGVuc3VyZV92aWV3X2RvYyhyZXFfaWQ6IHN0ciwgdGl0bGU6IHN0cikgLT4gUGF0aDoKICAgIHBhdGggPSBWSUVXU19ESVIgLyBmIntyZXFfaWR9Lm1kIgogICAgaWYgbm90IHBhdGguZXhpc3RzKCk6CiAgICAgICAgdGVtcGxhdGUgPSBsb2FkX3RlbXBsYXRlKCJWSUVXLm1kIikKICAgICAgICBjb250ZW50ID0gdGVtcGxhdGUucmVwbGFjZSgiUkVRLVhYWC0wMDEiLCByZXFfaWQpCiAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgiIyBbVklFVy1SRVEtWFhYLTAwMV0gVGl0bGUiLCBmIiMgW1ZJRVcte3JlcV9pZH1dIHt0aXRsZX0iKQogICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoIkxhc3QgVXBkYXRlZCoqOiBZWVlZLU1NLUREIiwgZiJMYXN0IFVwZGF0ZWQqKjoge25vd19kYXRlKCl9IikKICAgICAgICB3cml0ZV90ZXh0KHBhdGgsIGNvbnRlbnQpCiAgICAgICAgcmV0dXJuIHBhdGgKCiAgICBjb250ZW50ID0gcmVhZF90ZXh0KHBhdGgpCiAgICByZXFfbGluayA9IGYiLi4vcmVxL3tyZXFfaWR9Lm1kIgogICAgaWYgcmVxX2xpbmsgbm90IGluIGNvbnRlbnQ6CiAgICAgICAgaWYgIiMjIFJlZmVyZW5jZXMgKFNTT1QpIiBub3QgaW4gY29udGVudDoKICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQucnN0cmlwKCkgKyAiXG5cbiMjIFJlZmVyZW5jZXMgKFNTT1QpXG4iCiAgICAgICAgY29udGVudCA9IGNvbnRlbnQucnN0cmlwKCkgKyBmIlxuLSBbe3JlcV9pZH1dKHtyZXFfbGlua30pXG4iCiAgICAgICAgd3JpdGVfdGV4dChwYXRoLCBjb250ZW50KQogICAgcmV0dXJuIHBhdGgKCgpkZWYgcnVuX2NvbW1hbmQoYXJnczogYXJncGFyc2UuTmFtZXNwYWNlKSAtPiBpbnQ6CiAgICByZXFfaWQgPSBhcmdzLnJlcV9pZAogICAgaWYgcmVxX2lkLmVuZHN3aXRoKCIubWQiKToKICAgICAgICByZXFfaWQgPSBQYXRoKHJlcV9pZCkuc3RlbQoKICAgIG1hdGNoID0gUkVRX0lEX1BBVFRFUk4ubWF0Y2gocmVxX2lkKQogICAgaWYgbm90IG1hdGNoOgogICAgICAgIHByaW50KGYiW0VSUl0gSW52YWxpZCBSRVEgSUQ6IHtyZXFfaWR9IikKICAgICAgICByZXR1cm4gMQoKICAgIHJlcV9wYXRoID0gUkVRX0RJUiAvIGYie3JlcV9pZH0ubWQiCiAgICBpZiBub3QgcmVxX3BhdGguZXhpc3RzKCk6CiAgICAgICAgcHJpbnQoZiJbRVJSXSBSRVEgbm90IGZvdW5kOiB7cmVxX3BhdGh9IikKICAgICAgICByZXR1cm4gMQoKICAgIGRvbWFpbiA9IG1hdGNoLmdyb3VwKDEpCiAgICBudW1iZXIgPSBtYXRjaC5ncm91cCgyKQogICAgc3RlcCA9IGdldGF0dHIoYXJncywgInN0ZXAiLCBOb25lKSBvciBuZXh0X3J1bl9zdGVwKHJlcV9pZCkKICAgIHJ1bl9pZCA9IGYiUlVOLVJFUS17ZG9tYWlufS17bnVtYmVyfS1zdGVwLXtpbnQoc3RlcCk6MDJkfSIKICAgIHJ1bl9wYXRoID0gUlVOX0RJUiAvIGYie3J1bl9pZH0ubWQiCiAgICBpZiBydW5fcGF0aC5leGlzdHMoKToKICAgICAgICBwcmludChmIltFUlJdIFJVTiBhbHJlYWR5IGV4aXN0czoge3J1bl9wYXRofSIpCiAgICAgICAgcmV0dXJuIDEKCiAgICBjb250ZW50ID0gZiIiIiMgW3tydW5faWR9XSBQbGFuCgo+ICoqSUQqKjoge3J1bl9pZH0KPiAqKlJFUSoqOiB7cmVxX2lkfQo+ICoqU3RhdHVzKio6IFBsYW5uZWQKPiAqKlN0YXJ0ZWQqKjoge25vd19kYXRlKCl9Cj4gKipHaXQqKjogLQo+ICoqQ29tcGxldGVkKio6IC0KCiMjIFRhcmdldCBSRVEKLSB7cmVxX2lkfQoKIyMgUGxhbgotIFsgXSAKCiMjIFZlcmlmaWNhdGlvbgotIFsgXSBUZXN0Ci0gWyBdIFNwZWMKLSBbIF0gQm91bmRhcnkKCiMjIE91dHB1dAotIChmaWxlcyBjcmVhdGVkL21vZGlmaWVkKQoiIiIKICAgIHdyaXRlX3RleHQocnVuX3BhdGgsIGNvbnRlbnQpCgogICAgd3JpdGVfbGFzdF9ydW4oCiAgICAgICAgewogICAgICAgICAgICAicnVuX2lkIjogcnVuX2lkLAogICAgICAgICAgICAicmVxX2lkIjogcmVxX2lkLAogICAgICAgICAgICAic3RhZ2UiOiAiZXhlY3V0aW5nIiwKICAgICAgICAgICAgInVwZGF0ZWRfYXQiOiBub3dfaXNvKCksCiAgICAgICAgfQogICAgKQoKICAgIHByaW50KGYiW09LXSBDcmVhdGVkIHtydW5fcGF0aH0iKQogICAgcmV0dXJuIDAKCgpkZWYgcGxhbl9jb21tYW5kKGFyZ3M6IGFyZ3BhcnNlLk5hbWVzcGFjZSkgLT4gaW50OgogICAgcHJpbnQoIltXQVJOXSAncGxhbicgaXMgZGVwcmVjYXRlZC4gVXNlICdydW4nIGluc3RlYWQuIikKICAgIGFyZ3MucmVxX2lkID0gYXJncy5icmllZl9pZAogICAgcmV0dXJuIHJ1bl9jb21tYW5kKGFyZ3MpCgoKZGVmIGZpbmlzaF9jb21tYW5kKGFyZ3M6IGFyZ3BhcnNlLk5hbWVzcGFjZSkgLT4gaW50OgogICAgcnVuX2lkID0gYXJncy5ydW5faWQKICAgIGlmIHJ1bl9pZC5lbmRzd2l0aCgiLm1kIik6CiAgICAgICAgcnVuX2lkID0gUGF0aChydW5faWQpLnN0ZW0KCiAgICBpZiBub3QgUlVOX0lEX1BBVFRFUk4ubWF0Y2gocnVuX2lkKToKICAgICAgICBwcmludChmIltFUlJdIEludmFsaWQgUlVOIElEOiB7cnVuX2lkfSIpCiAgICAgICAgcmV0dXJuIDEKCiAgICBydW5fcGF0aCA9IFJVTl9ESVIgLyBmIntydW5faWR9Lm1kIgogICAgaWYgbm90IHJ1bl9wYXRoLmV4aXN0cygpOgogICAgICAgIHByaW50KGYiW0VSUl0gUlVOIG5vdCBmb3VuZDoge3J1bl9wYXRofSIpCiAgICAgICAgcmV0dXJuIDEKCiAgICBnaXRfaGFzaCA9IGFyZ3MuZ2l0CiAgICBpZiBub3QgZ2l0X2hhc2g6CiAgICAgICAgZ2l0X2hhc2ggPSBkZXRlY3RfZ2l0X2hhc2goKQogICAgaWYgbm90IGdpdF9oYXNoOgogICAgICAgIHByaW50KCJbRVJSXSBNaXNzaW5nIGdpdCBoYXNoLiBQcm92aWRlIC0tZ2l0IG9yIGVuc3VyZSBnaXQgaXMgYXZhaWxhYmxlLiIpCiAgICAgICAgcmV0dXJuIDEKCiAgICB0ZXh0ID0gcmVhZF90ZXh0KHJ1bl9wYXRoKQogICAgbWV0YSA9IGV4dHJhY3RfbWV0YSh0ZXh0KQogICAgYnJpZWZfaWQgPSBtZXRhLmdldCgiQnJpZWYiKQogICAgcmVxX2lkID0gbWV0YS5nZXQoIlJFUSIpIG9yIHJlcV9pZF9mcm9tX3J1bl9pZChydW5faWQpCiAgICBzdGF0dXMgPSAiQ29tcGxldGVkIiBpZiBhcmdzLnN1Y2Nlc3MgZWxzZSAiRmFpbGVkIgogICAgdGV4dCA9IHVwZGF0ZV9tZXRhX2xpbmUodGV4dCwgIlN0YXR1cyIsIHN0YXR1cykKICAgIHRleHQgPSB1cGRhdGVfbWV0YV9saW5lKHRleHQsICJHaXQiLCBnaXRfaGFzaCkKICAgIHRleHQgPSB1cGRhdGVfbWV0YV9saW5lKHRleHQsICJDb21wbGV0ZWQiLCBub3dfZGF0ZSgpKQogICAgd3JpdGVfdGV4dChydW5fcGF0aCwgdGV4dCkKCiAgICBpZiBicmllZl9pZDoKICAgICAgICB1cGRhdGVfYnJpZWZfc3RhdHVzKGJyaWVmX2lkLCBzdGF0dXMpCgogICAgaWYgcmVxX2lkOgogICAgICAgIHJlcV9wYXRoID0gUkVRX0RJUiAvIGYie3JlcV9pZH0ubWQiCiAgICAgICAgaWYgcmVxX3BhdGguZXhpc3RzKCk6CiAgICAgICAgICAgIHJlcV90ZXh0ID0gcmVhZF90ZXh0KHJlcV9wYXRoKQogICAgICAgICAgICByZXFfdGV4dCA9IHVwZGF0ZV9tZXRhX2xpbmUocmVxX3RleHQsICJJbXBsZW1lbnRlZC1HaXQiLCBnaXRfaGFzaCkKICAgICAgICAgICAgcmVxX3RleHQgPSB1cGRhdGVfbWV0YV9saW5lKHJlcV90ZXh0LCAiTGlua2VkLVJVTiIsIHJ1bl9pZCkKICAgICAgICAgICAgcmVxX3RleHQgPSB1cGRhdGVfbWV0YV9saW5lKHJlcV90ZXh0LCAiTGFzdCBVcGRhdGVkIiwgbm93X2RhdGUoKSkKICAgICAgICAgICAgd3JpdGVfdGV4dChyZXFfcGF0aCwgcmVxX3RleHQpCiAgICAgICAgICAgIHByaW50KGYiW09LXSBVcGRhdGVkIHtyZXFfcGF0aH0iKQoKICAgIGxhc3RfcnVuX3N0YXRlID0gewogICAgICAgICJydW5faWQiOiBydW5faWQsCiAgICAgICAgInN0YWdlIjogImZpbmlzaGVkIiwKICAgICAgICAiZ2l0X2hhc2giOiBnaXRfaGFzaCwKICAgICAgICAiY29tcGxldGVkX2F0Ijogbm93X2lzbygpLAogICAgfQogICAgaWYgYnJpZWZfaWQ6CiAgICAgICAgbGFzdF9ydW5fc3RhdGVbImJyaWVmX2lkIl0gPSBicmllZl9pZAogICAgaWYgcmVxX2lkOgogICAgICAgIGxhc3RfcnVuX3N0YXRlWyJyZXFfaWQiXSA9IHJlcV9pZAogICAgd3JpdGVfbGFzdF9ydW4obGFzdF9ydW5fc3RhdGUpCgogICAgcHJpbnQoZiJbT0tdIFVwZGF0ZWQge3J1bl9wYXRofSIpCiAgICByZXR1cm4gMAoKCmRlZiBzeW5jX2NvbW1hbmQoYXJnczogYXJncGFyc2UuTmFtZXNwYWNlKSAtPiBpbnQ6CiAgICAiIiJTeW5jIFJVTiBzdGF0dXMgdG8gQlJJRUYvUkVRIGRvY3VtZW50cy4iIiIKICAgIHJ1bl9pZCA9IGFyZ3MucnVuX2lkCiAgICBpZiBydW5faWQuZW5kc3dpdGgoIi5tZCIpOgogICAgICAgIHJ1bl9pZCA9IFBhdGgocnVuX2lkKS5zdGVtCgogICAgaWYgbm90IFJVTl9JRF9QQVRURVJOLm1hdGNoKHJ1bl9pZCk6CiAgICAgICAgcHJpbnQoZiJbRVJSXSBJbnZhbGlkIFJVTiBJRDoge3J1bl9pZH0iKQogICAgICAgIHJldHVybiAxCgogICAgcnVuX3BhdGggPSBSVU5fRElSIC8gZiJ7cnVuX2lkfS5tZCIKICAgIGlmIG5vdCBydW5fcGF0aC5leGlzdHMoKToKICAgICAgICBwcmludChmIltFUlJdIFJVTiBub3QgZm91bmQ6IHtydW5fcGF0aH0iKQogICAgICAgIHJldHVybiAxCgogICAgIyBHZW5lcmF0ZSBkaWZmCiAgICBkaWZmID0gZ2VuZXJhdGVfc3luY19kaWZmKHJ1bl9wYXRoKQogICAgCiAgICAjIEFsd2F5cyBwcmludCBkaWZmIChkcnktcnVuIGluZm8pCiAgICBwcmludF9zeW5jX2RpZmYoZGlmZikKICAgIAogICAgIyBDaGVjayBpZiBhbnkgYXBwbHkgZmxhZ3MgYXJlIHNldAogICAgYXBwbHlfYnJpZWYgPSBnZXRhdHRyKGFyZ3MsICJhcHBseV9icmllZiIsIEZhbHNlKQogICAgYXBwbHlfcmVxID0gZ2V0YXR0cihhcmdzLCAiYXBwbHlfcmVxIiwgRmFsc2UpCiAgICB3cml0ZV9wYXRjaCA9IGdldGF0dHIoYXJncywgIndyaXRlX3JlcV9wYXRjaCIsIEZhbHNlKQogICAgCiAgICBpZiBub3QgKGFwcGx5X2JyaWVmIG9yIGFwcGx5X3JlcSBvciB3cml0ZV9wYXRjaCk6CiAgICAgICAgcHJpbnQoIlxuW0lORk9dIERyeS1ydW4gbW9kZS4gVXNlIC0tYXBwbHktYnJpZWYsIC0td3JpdGUtcmVxLXBhdGNoLCBvciAtLWFwcGx5LXJlcSB0byBtYWtlIGNoYW5nZXMuIikKICAgICAgICByZXR1cm4gMAogICAgCiAgICAjIEFwcGx5IFJVTiBjaGFuZ2VzIChhbHdheXMgd2hlbiBhbnkgYXBwbHkgZmxhZyBpcyBzZXQpCiAgICBpZiBkaWZmWyJydW4iXVsiY2hhbmdlcyJdOgogICAgICAgIHJ1bl90ZXh0ID0gcmVhZF90ZXh0KHJ1bl9wYXRoKQogICAgICAgIGZvciBjaGFuZ2UgaW4gZGlmZlsicnVuIl1bImNoYW5nZXMiXToKICAgICAgICAgICAgaWYgY2hhbmdlWyJ0eXBlIl0gPT0gInN0YXR1cyI6CiAgICAgICAgICAgICAgICBydW5fdGV4dCA9IHVwZGF0ZV9tZXRhX2xpbmUocnVuX3RleHQsICJTdGF0dXMiLCBjaGFuZ2VbInRvIl0pCiAgICAgICAgd3JpdGVfdGV4dChydW5fcGF0aCwgcnVuX3RleHQpCiAgICAgICAgcHJpbnQoZiJbT0tdIFVwZGF0ZWQge3J1bl9wYXRofSIpCiAgICAKICAgICMgQXBwbHkgQlJJRUYgY2hhbmdlcwogICAgaWYgYXBwbHlfYnJpZWY6CiAgICAgICAgYXBwbHlfYnJpZWZfY2hhbmdlcyhkaWZmKQogICAgCiAgICAjIFdyaXRlIFJFUSBwYXRjaAogICAgaWYgd3JpdGVfcGF0Y2g6CiAgICAgICAgd3JpdGVfcmVxX3BhdGNoKGRpZmYpCiAgICAKICAgICMgQXBwbHkgUkVRIGNoYW5nZXMgKHdpdGggd2FybmluZykKICAgIGlmIGFwcGx5X3JlcToKICAgICAgICBhcHBseV9yZXFfY2hhbmdlcyhkaWZmKQogICAgCiAgICByZXR1cm4gMAoKCmRlZiBpdGVyX2xpbmtzKHRleHQ6IHN0cikgLT4gbGlzdFtzdHJdOgogICAgbGlua3MgPSBbXQogICAgaW5fY29kZSA9IEZhbHNlCiAgICBmb3IgbGluZSBpbiB0ZXh0LnNwbGl0bGluZXMoKToKICAgICAgICBzdHJpcHBlZCA9IGxpbmUuc3RyaXAoKQogICAgICAgIGlmIHN0cmlwcGVkLnN0YXJ0c3dpdGgoImBgYCIpOgogICAgICAgICAgICBpbl9jb2RlID0gbm90IGluX2NvZGUKICAgICAgICAgICAgY29udGludWUKICAgICAgICBpZiBpbl9jb2RlOgogICAgICAgICAgICBjb250aW51ZQogICAgICAgIGZvciBtYXRjaCBpbiBMSU5LX1JFLmZpbmRpdGVyKGxpbmUpOgogICAgICAgICAgICBsaW5rcy5hcHBlbmQobWF0Y2guZ3JvdXAoMSkuc3RyaXAoKSkKICAgIHJldHVybiBsaW5rcwoKCmRlZiBkb2N0b3JfY29tbWFuZChhcmdzOiBhcmdwYXJzZS5OYW1lc3BhY2UpIC0+IGludDoKICAgIGlzc3VlcyA9IDAKICAgIGJyaWVmX3N0YXR1c2VzOiBkaWN0W3N0ciwgc3RyXSA9IHt9CiAgICBydW5fYnJpZWZfc3RhdHVzZXM6IGxpc3RbdHVwbGVbc3RyLCBzdHIsIHN0ciwgT3B0aW9uYWxbZGF0ZXRpbWVdXV0gPSBbXQoKICAgIHJlcXVpcmVkX2RpcnMgPSBbCiAgICAgICAgUkVRX0RJUiwKICAgICAgICBSVUxFX0RJUiwKICAgICAgICBBRFJfRElSLAogICAgICAgIENRX0RJUiwKICAgICAgICBWSUVXU19ESVIsCiAgICAgICAgSU5CT1hfRElSLAogICAgICAgIERSQUZUU19ESVIsCiAgICAgICAgQlJJRUZfRElSLAogICAgICAgIFJVTl9ESVIsCiAgICAgICAgQVJDSElWRV9ESVIsCiAgICAgICAgU1lTVEVNX1JPT1QsCiAgICAgICAgVEVNUExBVEVTX0RJUiwKICAgICAgICBTVEFURV9ESVIsCiAgICBdCiAgICBmb3IgcGF0aCBpbiByZXF1aXJlZF9kaXJzOgogICAgICAgIGlmIG5vdCBwYXRoLmV4aXN0cygpOgogICAgICAgICAgICBwcmludChmIltFUlJdIE1pc3NpbmcgZGlyZWN0b3J5OiB7cGF0aH0iKQogICAgICAgICAgICBpc3N1ZXMgKz0gMQoKICAgIGZvciBwYXRoIGluIFJFUVVJUkVEX1RPUF9ET0NTOgogICAgICAgIGlmIG5vdCBwYXRoLmV4aXN0cygpOgogICAgICAgICAgICBwcmludChmIltFUlJdIE1pc3NpbmcgdG9wIGRvYzoge3BhdGh9IikKICAgICAgICAgICAgaXNzdWVzICs9IDEKCiAgICBmb3IgcGF0aCBpbiBPUFRJT05BTF9UT1BfRE9DUzoKICAgICAgICBpZiBub3QgcGF0aC5leGlzdHMoKToKICAgICAgICAgICAgcHJpbnQoZiJbV0FSTl0gTWlzc2luZyBvcHRpb25hbCBkb2M6IHtwYXRofSIpCgogICAgc2Nhbl9kaXJzID0gW1JFUV9ESVIsIFJVTEVfRElSLCBBRFJfRElSLCBDUV9ESVIsIEJSSUVGX0RJUiwgUlVOX0RJUl0KICAgIGFsbF9kb2NzID0gaXRlcl9tZF9maWxlcyhzY2FuX2RpcnMpCiAgICBhbGxfaWRzOiBzZXRbc3RyXSA9IHNldCgpCgogICAgZm9yIHBhdGggaW4gYWxsX2RvY3M6CiAgICAgICAgdGV4dCA9IHJlYWRfdGV4dChwYXRoKQogICAgICAgIG1ldGEgPSBleHRyYWN0X21ldGEodGV4dCkKICAgICAgICBtZXRhX2lkID0gbWV0YS5nZXQoIklEIikKICAgICAgICBoZWFkZXJfaWQgPSBleHRyYWN0X2hlYWRlcl9pZCh0ZXh0KQogICAgICAgIGZpbGVfaWQgPSBwYXRoLnN0ZW0KICAgICAgICBmb3IgY2FuZGlkYXRlIGluIFttZXRhX2lkLCBoZWFkZXJfaWQsIGZpbGVfaWRdOgogICAgICAgICAgICBpZiBjYW5kaWRhdGU6CiAgICAgICAgICAgICAgICBhbGxfaWRzLmFkZChjYW5kaWRhdGUpCgogICAgZm9yIHBhdGggaW4gYWxsX2RvY3M6CiAgICAgICAgdGV4dCA9IHJlYWRfdGV4dChwYXRoKQogICAgICAgIG1ldGEgPSBleHRyYWN0X21ldGEodGV4dCkKICAgICAgICBtZXRhX2lkID0gbWV0YS5nZXQoIklEIikKICAgICAgICBoZWFkZXJfaWQgPSBleHRyYWN0X2hlYWRlcl9pZCh0ZXh0KQogICAgICAgIGZpbGVfaWQgPSBwYXRoLnN0ZW0KCiAgICAgICAgZm9sZGVyID0gcGF0aC5wYXJlbnQubmFtZQogICAgICAgIGV4cGVjdGVkX3ByZWZpeCA9IHsKICAgICAgICAgICAgInJlcSI6ICJSRVEiLAogICAgICAgICAgICAicnVsZSI6ICJSVUxFIiwKICAgICAgICAgICAgImFkciI6ICJBRFIiLAogICAgICAgICAgICAiY3EiOiAiQ1EiLAogICAgICAgICAgICAiYnJpZWYiOiAiQlJJRUYiLAogICAgICAgICAgICAicnVucyI6ICJSVU4iLAogICAgICAgIH0uZ2V0KGZvbGRlcikKCiAgICAgICAgaWYgZXhwZWN0ZWRfcHJlZml4IGlzIE5vbmU6CiAgICAgICAgICAgIGNvbnRpbnVlCgogICAgICAgIGlmIGV4cGVjdGVkX3ByZWZpeCA9PSAiQlJJRUYiOgogICAgICAgICAgICBzdGF0dXMgPSBtZXRhLmdldCgiU3RhdHVzIikKICAgICAgICAgICAgaWYgbm90IHN0YXR1czoKICAgICAgICAgICAgICAgIHByaW50KGYiW0VSUl0gTWlzc2luZyBTdGF0dXM6IHtwYXRofSIpCiAgICAgICAgICAgICAgICBpc3N1ZXMgKz0gMQogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgYnJpZWZfc3RhdHVzZXNbZmlsZV9pZF0gPSBzdGF0dXMKCiAgICAgICAgaWYgZXhwZWN0ZWRfcHJlZml4ID09ICJSVU4iOgogICAgICAgICAgICBicmllZl9pZCA9IG1ldGEuZ2V0KCJCcmllZiIpCiAgICAgICAgICAgIHJ1bl9zdGF0dXMgPSBtZXRhLmdldCgiU3RhdHVzIikKICAgICAgICAgICAgY29tcGxldGVkID0gbWV0YS5nZXQoIkNvbXBsZXRlZCIpCiAgICAgICAgICAgIGlmIGJyaWVmX2lkIGFuZCBydW5fc3RhdHVzOgogICAgICAgICAgICAgICAgcnVuX2JyaWVmX3N0YXR1c2VzLmFwcGVuZCgKICAgICAgICAgICAgICAgICAgICAoZmlsZV9pZCwgYnJpZWZfaWQsIHJ1bl9zdGF0dXMsIHBhcnNlX2NvbXBsZXRlZF9kYXRlKGNvbXBsZXRlZCkpCiAgICAgICAgICAgICAgICApCiAgICAgICAgICAgIGlmIGZpbGVfaWQuc3RhcnRzd2l0aCgiUlVOLUJSSUVGLSIpIGFuZCBub3QgYnJpZWZfaWQ6CiAgICAgICAgICAgICAgICBwcmludChmIltXQVJOXSBNaXNzaW5nIEJyaWVmIHJlZmVyZW5jZToge3BhdGh9IikKICAgICAgICAgICAgICAgIGlzc3VlcyArPSAxCgogICAgICAgIGlmIG5vdCBtZXRhX2lkOgogICAgICAgICAgICBwcmludChmIltFUlJdIE1pc3NpbmcgbWV0YSBJRDoge3BhdGh9IikKICAgICAgICAgICAgaXNzdWVzICs9IDEKICAgICAgICBpZiBub3QgaGVhZGVyX2lkOgogICAgICAgICAgICBwcmludChmIltFUlJdIE1pc3NpbmcgaGVhZGVyIElEOiB7cGF0aH0iKQogICAgICAgICAgICBpc3N1ZXMgKz0gMQoKICAgICAgICBwYXR0ZXJuID0gewogICAgICAgICAgICAiUkVRIjogUkVRX0lEX1BBVFRFUk4sCiAgICAgICAgICAgICJSVUxFIjogUlVMRV9JRF9QQVRURVJOLAogICAgICAgICAgICAiQURSIjogQURSX0lEX1BBVFRFUk4sCiAgICAgICAgICAgICJDUSI6IENRX0lEX1BBVFRFUk4sCiAgICAgICAgICAgICJCUklFRiI6IEJSSUVGX0lEX1BBVFRFUk4sCiAgICAgICAgICAgICJSVU4iOiBSVU5fSURfUEFUVEVSTiwKICAgICAgICB9W2V4cGVjdGVkX3ByZWZpeF0KCiAgICAgICAgaWYgbm90IHBhdHRlcm4ubWF0Y2goZmlsZV9pZCk6CiAgICAgICAgICAgIHByaW50KGYiW0VSUl0gSW52YWxpZCBmaWxlbmFtZSBmb3Ige2V4cGVjdGVkX3ByZWZpeH06IHtwYXRofSIpCiAgICAgICAgICAgIGlzc3VlcyArPSAxCgogICAgICAgIGlmIG1ldGFfaWQgYW5kIG1ldGFfaWQgIT0gZmlsZV9pZDoKICAgICAgICAgICAgcHJpbnQoZiJbRVJSXSBNZXRhIElEIG1pc21hdGNoOiB7cGF0aH0iKQogICAgICAgICAgICBpc3N1ZXMgKz0gMQogICAgICAgIGlmIGhlYWRlcl9pZCBhbmQgaGVhZGVyX2lkICE9IGZpbGVfaWQ6CiAgICAgICAgICAgIHByaW50KGYiW0VSUl0gSGVhZGVyIElEIG1pc21hdGNoOiB7cGF0aH0iKQogICAgICAgICAgICBpc3N1ZXMgKz0gMQoKICAgICAgICBpZiBleHBlY3RlZF9wcmVmaXggaW4geyJSRVEiLCAiUlVMRSJ9OgogICAgICAgICAgICBtdXN0X3JlYWQgPSBtZXRhLmdldCgiTXVzdC1SZWFkIikKICAgICAgICAgICAgaWYgbXVzdF9yZWFkIGlzIE5vbmU6CiAgICAgICAgICAgICAgICBwcmludChmIltFUlJdIE1pc3NpbmcgTXVzdC1SZWFkOiB7cGF0aH0iKQogICAgICAgICAgICAgICAgaXNzdWVzICs9IDEKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIGlkcyA9IHBhcnNlX211c3RfcmVhZChtdXN0X3JlYWQpCiAgICAgICAgICAgICAgICBpZiBub3QgaWRzIGFuZCBtdXN0X3JlYWQuc3RyaXAoKS5sb3dlcigpICE9ICJub25lIjoKICAgICAgICAgICAgICAgICAgICBwcmludChmIltFUlJdIEVtcHR5IE11c3QtUmVhZDoge3BhdGh9IikKICAgICAgICAgICAgICAgICAgICBpc3N1ZXMgKz0gMQogICAgICAgICAgICAgICAgZm9yIHJlZl9pZCBpbiBpZHM6CiAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gcmVmX2lkLnNwbGl0KCItIiwgMSlbMF0KICAgICAgICAgICAgICAgICAgICBpZiBwcmVmaXggbm90IGluIEFMTE9XRURfTVVTVF9SRUFEX1BSRUZJWEVTOgogICAgICAgICAgICAgICAgICAgICAgICBwcmludChmIltFUlJdIE11c3QtUmVhZCBkaXNhbGxvd2VkIElEOiB7cGF0aH0gLT4ge3JlZl9pZH0iKQogICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXMgKz0gMQogICAgICAgICAgICAgICAgICAgIGlmIHJlZl9pZCBub3QgaW4gYWxsX2lkczoKICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQoZiJbRVJSXSBNdXN0LVJlYWQgbWlzc2luZyB0YXJnZXQ6IHtwYXRofSAtPiB7cmVmX2lkfSIpCiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlcyArPSAxCgogICAgICAgIGlmIGV4cGVjdGVkX3ByZWZpeCA9PSAiUkVRIjoKICAgICAgICAgICAgc3RhdHVzID0gbWV0YS5nZXQoIlN0YXR1cyIsICIiKQogICAgICAgICAgICBpbXBsZW1lbnRlZF9naXQgPSBtZXRhLmdldCgiSW1wbGVtZW50ZWQtR2l0IiwgIiIpLnN0cmlwKCkKICAgICAgICAgICAgaWYgbm9ybWFsaXplX3N0YXR1cyhzdGF0dXMpID09ICJpbXBsZW1lbnRlZCIgYW5kIChub3QgaW1wbGVtZW50ZWRfZ2l0IG9yIGltcGxlbWVudGVkX2dpdCA9PSAiLSIpOgogICAgICAgICAgICAgICAgcHJpbnQoZiJbV0FSTl0gSW1wbGVtZW50ZWQgUkVRIG1pc3NpbmcgZ2l0IGhhc2g6IHtwYXRofSIpCiAgICAgICAgICAgICAgICBpc3N1ZXMgKz0gMQoKICAgICAgICBpZiBhcmdzLmxpbmtzOgogICAgICAgICAgICBmb3IgdGFyZ2V0IGluIGl0ZXJfbGlua3ModGV4dCk6CiAgICAgICAgICAgICAgICBpZiBub3QgdGFyZ2V0IG9yIHRhcmdldC5zdGFydHN3aXRoKCIjIik6CiAgICAgICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgICAgIGlmIHJlLm1hdGNoKHIiXlthLXpBLVpdW2EtekEtWjAtOSsuLV0qOiIsIHRhcmdldCk6CiAgICAgICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgICAgIHJlc29sdmVkID0gKHBhdGgucGFyZW50IC8gdGFyZ2V0KS5yZXNvbHZlKCkKICAgICAgICAgICAgICAgIGlmIG5vdCByZXNvbHZlZC5leGlzdHMoKToKICAgICAgICAgICAgICAgICAgICBwcmludChmIltFUlJdIEJyb2tlbiBsaW5rOiB7cGF0aH0gLT4ge3RhcmdldH0iKQogICAgICAgICAgICAgICAgICAgIGlzc3VlcyArPSAxCgogICAgIyBWaWV3IC0+IFJFUSBsaW5rIHZhbGlkYXRpb24KICAgIHZpZXdfcmVmczogc2V0W3N0cl0gPSBzZXQoKQogICAgZm9yIHBhdGggaW4gaXRlcl9tZF9maWxlcyhbVklFV1NfRElSXSk6CiAgICAgICAgdGV4dCA9IHJlYWRfdGV4dChwYXRoKQogICAgICAgIG1ldGEgPSBleHRyYWN0X21ldGEodGV4dCkKICAgICAgICByZWZzX3ZhbHVlID0gbWV0YS5nZXQoIlJlZnMiKQogICAgICAgIGlmIHJlZnNfdmFsdWU6CiAgICAgICAgICAgIGZvciByZWZfaWQgaW4gcGFyc2VfbXVzdF9yZWFkKHJlZnNfdmFsdWUpOgogICAgICAgICAgICAgICAgaWYgcmVmX2lkLnN0YXJ0c3dpdGgoIlJFUS0iKToKICAgICAgICAgICAgICAgICAgICB2aWV3X3JlZnMuYWRkKHJlZl9pZCkKICAgICAgICAgICAgICAgICAgICByZWZfcGF0aCA9IFJFUV9ESVIgLyBmIntyZWZfaWR9Lm1kIgogICAgICAgICAgICAgICAgICAgIGlmIG5vdCByZWZfcGF0aC5leGlzdHMoKToKICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQoZiJbV0FSTl0gVmlldyByZWZzIG1pc3NpbmcgUkVROiB7cGF0aH0gLT4ge3JlZl9pZH0iKQogICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXMgKz0gMQogICAgICAgIGZvciB0YXJnZXQgaW4gaXRlcl9saW5rcyh0ZXh0KToKICAgICAgICAgICAgaWYgbm90IHRhcmdldCBvciB0YXJnZXQuc3RhcnRzd2l0aCgiIyIpOgogICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgaWYgcmUubWF0Y2gociJeW2EtekEtWl1bYS16QS1aMC05Ky4tXSo6IiwgdGFyZ2V0KToKICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgIHJlc29sdmVkID0gKHBhdGgucGFyZW50IC8gdGFyZ2V0KS5yZXNvbHZlKCkKICAgICAgICAgICAgaWYgaXNfcmVsYXRpdmVfdG8ocmVzb2x2ZWQsIFJFUV9ESVIpOgogICAgICAgICAgICAgICAgaWYgbm90IHJlc29sdmVkLmV4aXN0cygpOgogICAgICAgICAgICAgICAgICAgIHByaW50KGYiW1dBUk5dIEJyb2tlbiBSRVEgbGluayBpbiB2aWV3OiB7cGF0aH0gLT4ge3RhcmdldH0iKQogICAgICAgICAgICAgICAgICAgIGlzc3VlcyArPSAxCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIHZpZXdfcmVmcy5hZGQocmVzb2x2ZWQuc3RlbSkKCiAgICAjIFJFUSB3aXRob3V0IGFueSB2aWV3IHJlZmVyZW5jZQogICAgcmVxX2lkcyA9IFtwYXRoLnN0ZW0gZm9yIHBhdGggaW4gYWxsX2RvY3MgaWYgcGF0aC5wYXJlbnQubmFtZSA9PSAicmVxIl0KICAgIGZvciByZXFfaWQgaW4gcmVxX2lkczoKICAgICAgICBpZiByZXFfaWQgbm90IGluIHZpZXdfcmVmczoKICAgICAgICAgICAgcHJpbnQoZiJbV0FSTl0gTWlzc2luZyB2aWV3IHJlZmVyZW5jZSBmb3IgUkVROiB7cmVxX2lkfSIpCiAgICAgICAgICAgIGlzc3VlcyArPSAxCgogICAgbGF0ZXN0X3J1bl9ieV9icmllZjogZGljdFtzdHIsIHR1cGxlW3N0ciwgc3RyLCBPcHRpb25hbFtkYXRldGltZV1dXSA9IHt9CiAgICBmb3IgcnVuX2lkLCBicmllZl9pZCwgcnVuX3N0YXR1cywgY29tcGxldGVkX2F0IGluIHJ1bl9icmllZl9zdGF0dXNlczoKICAgICAgICBub3JtYWxpemVkID0gbm9ybWFsaXplX3N0YXR1cyhydW5fc3RhdHVzKQogICAgICAgIGlmIG5vcm1hbGl6ZWQgbm90IGluIHsiY29tcGxldGVkIiwgImZhaWxlZCJ9OgogICAgICAgICAgICBjb250aW51ZQogICAgICAgIGV4aXN0aW5nID0gbGF0ZXN0X3J1bl9ieV9icmllZi5nZXQoYnJpZWZfaWQpCiAgICAgICAgaWYgZXhpc3RpbmcgaXMgTm9uZToKICAgICAgICAgICAgbGF0ZXN0X3J1bl9ieV9icmllZlticmllZl9pZF0gPSAocnVuX2lkLCBydW5fc3RhdHVzLCBjb21wbGV0ZWRfYXQpCiAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgZXhpc3RpbmdfcnVuX2lkLCBfLCBleGlzdGluZ19jb21wbGV0ZWQgPSBleGlzdGluZwogICAgICAgIGlmIGNvbXBsZXRlZF9hdCBhbmQgKGV4aXN0aW5nX2NvbXBsZXRlZCBpcyBOb25lIG9yIGNvbXBsZXRlZF9hdCA+IGV4aXN0aW5nX2NvbXBsZXRlZCk6CiAgICAgICAgICAgIGxhdGVzdF9ydW5fYnlfYnJpZWZbYnJpZWZfaWRdID0gKHJ1bl9pZCwgcnVuX3N0YXR1cywgY29tcGxldGVkX2F0KQogICAgICAgIGVsaWYgY29tcGxldGVkX2F0IGlzIE5vbmUgYW5kIGV4aXN0aW5nX2NvbXBsZXRlZCBpcyBOb25lIGFuZCBydW5faWQgPiBleGlzdGluZ19ydW5faWQ6CiAgICAgICAgICAgIGxhdGVzdF9ydW5fYnlfYnJpZWZbYnJpZWZfaWRdID0gKHJ1bl9pZCwgcnVuX3N0YXR1cywgY29tcGxldGVkX2F0KQoKICAgIGZvciBicmllZl9pZCwgKHJ1bl9pZCwgcnVuX3N0YXR1cywgXykgaW4gbGF0ZXN0X3J1bl9ieV9icmllZi5pdGVtcygpOgogICAgICAgIGJyaWVmX3N0YXR1cyA9IGJyaWVmX3N0YXR1c2VzLmdldChicmllZl9pZCkKICAgICAgICBpZiBub3QgYnJpZWZfc3RhdHVzOgogICAgICAgICAgICBwcmludChmIltXQVJOXSBCUklFRiBtaXNzaW5nIGZvciBSVU46IHtydW5faWR9IC0+IHticmllZl9pZH0iKQogICAgICAgICAgICBpc3N1ZXMgKz0gMQogICAgICAgICAgICBjb250aW51ZQogICAgICAgIGlmIG5vcm1hbGl6ZV9zdGF0dXMoYnJpZWZfc3RhdHVzKSAhPSBub3JtYWxpemVfc3RhdHVzKHJ1bl9zdGF0dXMpOgogICAgICAgICAgICBwcmludCgKICAgICAgICAgICAgICAgIGYiW1dBUk5dIEJSSUVGIHN0YXR1cyBtaXNtYXRjaDoge2JyaWVmX2lkfSBpcyB7YnJpZWZfc3RhdHVzfSwgbGF0ZXN0IFJVTiB7cnVuX2lkfSBpcyB7cnVuX3N0YXR1c30iCiAgICAgICAgICAgICkKICAgICAgICAgICAgaXNzdWVzICs9IDEKCiAgICBpZiBMQVNUX1JVTl9QQVRILmV4aXN0cygpOgogICAgICAgIHRyeToKICAgICAgICAgICAgc3RhdGUgPSBqc29uLmxvYWRzKHJlYWRfdGV4dChMQVNUX1JVTl9QQVRIKSkKICAgICAgICBleGNlcHQganNvbi5KU09ORGVjb2RlRXJyb3I6CiAgICAgICAgICAgIHN0YXRlID0ge30KICAgICAgICAgICAgcHJpbnQoZiJbRVJSXSBJbnZhbGlkIEpTT046IHtMQVNUX1JVTl9QQVRIfSIpCiAgICAgICAgICAgIGlzc3VlcyArPSAxCiAgICAgICAgc3RhZ2UgPSBzdGF0ZS5nZXQoInN0YWdlIikKICAgICAgICB1cGRhdGVkX2F0ID0gc3RhdGUuZ2V0KCJ1cGRhdGVkX2F0Iikgb3Igc3RhdGUuZ2V0KCJjb21wbGV0ZWRfYXQiKQogICAgICAgIGlmIHN0YWdlID09ICJleGVjdXRpbmciIGFuZCB1cGRhdGVkX2F0OgogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICB0cyA9IGRhdGV0aW1lLmZyb21pc29mb3JtYXQodXBkYXRlZF9hdCkKICAgICAgICAgICAgICAgIGlmIGRhdGV0aW1lLm5vdygpIC0gdHMgPiB0aW1lZGVsdGEoaG91cnM9YXJncy5tYXhfYWdlX2hvdXJzKToKICAgICAgICAgICAgICAgICAgICBwcmludCgKICAgICAgICAgICAgICAgICAgICAgICAgZiJbV0FSTl0gUlVOIG1heSBiZSB1bmZpbmlzaGVkICg+e2FyZ3MubWF4X2FnZV9ob3Vyc31oKToge3N0YXRlLmdldCgncnVuX2lkJyl9IgogICAgICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgICAgICBpc3N1ZXMgKz0gMQogICAgICAgICAgICBleGNlcHQgVmFsdWVFcnJvcjoKICAgICAgICAgICAgICAgIHByaW50KCJbRVJSXSBJbnZhbGlkIHRpbWVzdGFtcCBpbiBsYXN0X3J1bi5qc29uIikKICAgICAgICAgICAgICAgIGlzc3VlcyArPSAxCgogICAgcHJpbnQoZiJbRE9ORV0gRG9jdG9yIGNvbXBsZXRlZCB3aXRoIHtpc3N1ZXN9IGlzc3VlKHMpLiIpCiAgICByZXR1cm4gMCBpZiBpc3N1ZXMgPT0gMCBlbHNlIDEKCgogICAgcHJpbnQoZiJbRE9ORV0gRG9jdG9yIGNvbXBsZXRlZCB3aXRoIHtpc3N1ZXN9IGlzc3VlKHMpLiIpCiAgICByZXR1cm4gMCBpZiBpc3N1ZXMgPT0gMCBlbHNlIDEKCgpkZWYgcGFyc2VfdmVyc2lvbih2OiBzdHIpIC0+IHR1cGxlW2ludCwgLi4uXToKICAgIHRyeToKICAgICAgICByZXR1cm4gdHVwbGUobWFwKGludCwgdi5zdHJpcCgpLnNwbGl0KCIuIikpKQogICAgZXhjZXB0IFZhbHVlRXJyb3I6CiAgICAgICAgcmV0dXJuICgwLCAwLCAwKQoKCmRlZiBjaGVja192ZXJzaW9uX3VwZGF0ZSgpIC0+IE5vbmU6CiAgICAiIiJDaGVjayBpZiBBdGxhcyBoYXMgYmVlbiB1cGRhdGVkIGFuZCBwcmludCBjaGFuZ2Vsb2cuIiIiCiAgICBpZiBub3QgVkVSU0lPTl9QQVRILmV4aXN0cygpOgogICAgICAgIHJldHVybgoKICAgIGluc3RhbGxlZF92ZXJfc3RyID0gVkVSU0lPTl9QQVRILnJlYWRfdGV4dChlbmNvZGluZz0idXRmLTgiKS5zdHJpcCgpCiAgICBpZiBub3QgaW5zdGFsbGVkX3Zlcl9zdHI6CiAgICAgICAgcmV0dXJuCgogICAgaW5zdGFsbGVkX3ZlciA9IHBhcnNlX3ZlcnNpb24oaW5zdGFsbGVkX3Zlcl9zdHIpCiAgICBjdXJyZW50X3ZlciA9IHBhcnNlX3ZlcnNpb24oQVRMQVNfVkVSU0lPTikKCiAgICBpZiBjdXJyZW50X3ZlciA+IGluc3RhbGxlZF92ZXI6CiAgICAgICAgcHJpbnQoZiJcbltJTkZPXSBVcGdyYWRpbmcgQXRsYXM6IHtpbnN0YWxsZWRfdmVyX3N0cn0gLT4ge0FUTEFTX1ZFUlNJT059IikKICAgICAgICBwcmludCgiPSIgKiA2MCkKICAgICAgICAKICAgICAgICAjIENvbGxlY3QgdmVyc2lvbnMgdG8gcHJpbnQKICAgICAgICB2ZXJzaW9uc190b19wcmludCA9IFtdCiAgICAgICAgZm9yIHZlcl9zdHIgaW4gQ0hBTkdFTE9HOgogICAgICAgICAgICB2ZXIgPSBwYXJzZV92ZXJzaW9uKHZlcl9zdHIpCiAgICAgICAgICAgIGlmIHZlciA+IGluc3RhbGxlZF92ZXIgYW5kIHZlciA8PSBjdXJyZW50X3ZlcjoKICAgICAgICAgICAgICAgIHZlcnNpb25zX3RvX3ByaW50LmFwcGVuZCgodmVyLCB2ZXJfc3RyKSkKICAgICAgICAKICAgICAgICAjIFNvcnQgYnkgdmVyc2lvbiBkZXNjZW5kaW5nCiAgICAgICAgdmVyc2lvbnNfdG9fcHJpbnQuc29ydChrZXk9bGFtYmRhIHg6IHhbMF0sIHJldmVyc2U9VHJ1ZSkKICAgICAgICAKICAgICAgICBmb3IgXywgdmVyX3N0ciBpbiB2ZXJzaW9uc190b19wcmludDoKICAgICAgICAgICAgcHJpbnQoZiJbe3Zlcl9zdHJ9XSIpCiAgICAgICAgICAgIGZvciBjaGFuZ2UgaW4gQ0hBTkdFTE9HW3Zlcl9zdHJdOgogICAgICAgICAgICAgICAgcHJpbnQoZiItIHtjaGFuZ2V9IikKICAgICAgICAgICAgcHJpbnQoKQogICAgICAgICAgICAKICAgICAgICBwcmludCgiPSIgKiA2MCkKICAgICAgICAKICAgICAgICAjIFVwZGF0ZSBWRVJTSU9OIGZpbGUKICAgICAgICBpZiBWRVJTSU9OX1BBVEguZXhpc3RzKCk6CiAgICAgICAgICAgIHdyaXRlX3RleHQoVkVSU0lPTl9QQVRILCBBVExBU19WRVJTSU9OKQogICAgICAgICAgICBwcmludChmIltPS10gVXBkYXRlZCBWRVJTSU9OIGZpbGUgdG8ge0FUTEFTX1ZFUlNJT059XG4iKQoKCmRlZiBidWlsZF9wYXJzZXIoKSAtPiBhcmdwYXJzZS5Bcmd1bWVudFBhcnNlcjoKICAgIHBhcnNlciA9IGFyZ3BhcnNlLkFyZ3VtZW50UGFyc2VyKHByb2c9ImF0bGFzIikKICAgIHBhcnNlci5hZGRfYXJndW1lbnQoCiAgICAgICAgIi0tdmVyc2lvbiIsICItdiIsCiAgICAgICAgYWN0aW9uPSJ2ZXJzaW9uIiwKICAgICAgICB2ZXJzaW9uPWYiQXRsYXMge2dldF92ZXJzaW9uKCl9IgogICAgKQogICAgc3ViID0gcGFyc2VyLmFkZF9zdWJwYXJzZXJzKGRlc3Q9ImNvbW1hbmQiLCByZXF1aXJlZD1GYWxzZSkKCiAgICBpbml0ID0gc3ViLmFkZF9wYXJzZXIoImluaXQiKQogICAgaW5pdC5hZGRfYXJndW1lbnQoIi0tb3ZlcndyaXRlIiwgYWN0aW9uPSJzdG9yZV90cnVlIikKCiAgICBjYXB0dXJlID0gc3ViLmFkZF9wYXJzZXIoImNhcHR1cmUiKQogICAgY2FwdHVyZS5hZGRfYXJndW1lbnQoInRleHQiKQogICAgY2FwdHVyZS5hZGRfYXJndW1lbnQoIi0tZG9tYWluIiwgZGVmYXVsdD0iR0VOIikKICAgIGNhcHR1cmUuYWRkX2FyZ3VtZW50KCItLXRvIiwgY2hvaWNlcz1bImJyaWVmIl0pCgogICAgaW50YWtlID0gc3ViLmFkZF9wYXJzZXIoImludGFrZSIpCiAgICBpbnRha2UuYWRkX2FyZ3VtZW50KCJ0ZXh0IikKICAgIGludGFrZS5hZGRfYXJndW1lbnQoIi0tZG9tYWluIiwgZGVmYXVsdD0iR0VOIikKICAgIGludGFrZS5hZGRfYXJndW1lbnQoIi0tdG8iLCBjaG9pY2VzPVsiYnJpZWYiXSkKCiAgICBydW4gPSBzdWIuYWRkX3BhcnNlcigicnVuIikKICAgIHJ1bi5hZGRfYXJndW1lbnQoInJlcV9pZCIpCiAgICBydW4uYWRkX2FyZ3VtZW50KCItLXN0ZXAiLCB0eXBlPWludCkKCiAgICBwbGFuID0gc3ViLmFkZF9wYXJzZXIoInBsYW4iKQogICAgcGxhbi5hZGRfYXJndW1lbnQoImJyaWVmX2lkIikKICAgIHBsYW4uYWRkX2FyZ3VtZW50KCItLXN0ZXAiLCB0eXBlPWludCkKCiAgICBmaW5pc2ggPSBzdWIuYWRkX3BhcnNlcigiZmluaXNoIikKICAgIGZpbmlzaC5hZGRfYXJndW1lbnQoInJ1bl9pZCIpCiAgICBmaW5pc2guYWRkX2FyZ3VtZW50KCItLWdpdCIpCiAgICBmaW5pc2guYWRkX2FyZ3VtZW50KCItLXN1Y2Nlc3MiLCB0eXBlPWxhbWJkYSB2OiB2Lmxvd2VyKCkgPT0gInRydWUiLCByZXF1aXJlZD1UcnVlKQoKICAgIGRvY3RvciA9IHN1Yi5hZGRfcGFyc2VyKCJkb2N0b3IiKQogICAgZG9jdG9yLmFkZF9hcmd1bWVudCgiLS1saW5rcyIsIGFjdGlvbj0ic3RvcmVfdHJ1ZSIpCiAgICBkb2N0b3IuYWRkX2FyZ3VtZW50KCItLW1heC1hZ2UtaG91cnMiLCB0eXBlPWludCwgZGVmYXVsdD0yNCkKCiAgICBzeW5jID0gc3ViLmFkZF9wYXJzZXIoInN5bmMiLCBoZWxwPSJTeW5jIFJVTiBzdGF0dXMgdG8gQlJJRUYvUkVRIGRvY3VtZW50cyIpCiAgICBzeW5jLmFkZF9hcmd1bWVudCgicnVuX2lkIiwgaGVscD0iUlVOIGRvY3VtZW50IElEIikKICAgIHN5bmMuYWRkX2FyZ3VtZW50KCItLWFwcGx5LWJyaWVmIiwgYWN0aW9uPSJzdG9yZV90cnVlIiwgaGVscD0iQXBwbHkgY2hhbmdlcyB0byBCUklFRiBkb2N1bWVudCIpCiAgICBzeW5jLmFkZF9hcmd1bWVudCgiLS13cml0ZS1yZXEtcGF0Y2giLCBhY3Rpb249InN0b3JlX3RydWUiLCBoZWxwPSJXcml0ZSBSRVEgcGF0Y2ggZmlsZSIpCiAgICBzeW5jLmFkZF9hcmd1bWVudCgiLS1hcHBseS1yZXEiLCBhY3Rpb249InN0b3JlX3RydWUiLCBoZWxwPSJBcHBseSBjaGFuZ2VzIHRvIFJFUSBkb2N1bWVudCAoY2F1dGlvbikiKQoKICAgIHJldHVybiBwYXJzZXIKCgpkZWYgbWFpbihhcmd2OiBPcHRpb25hbFtsaXN0W3N0cl1dID0gTm9uZSkgLT4gaW50OgogICAgcGFyc2VyID0gYnVpbGRfcGFyc2VyKCkKICAgIGFyZ3MgPSBwYXJzZXIucGFyc2VfYXJncyhhcmd2KQoKICAgIGlmIG5vdCBhcmdzLmNvbW1hbmQ6CiAgICAgICAgcGFyc2VyLnByaW50X2hlbHAoKQogICAgICAgIHJldHVybiAwCgogICAgaWYgYXJncy5jb21tYW5kICE9ICJpbml0IiBhbmQgbm90IEFUTEFTX1JPT1QuZXhpc3RzKCk6CiAgICAgICAgcHJpbnQoIltJTkZPXSAuYXRsYXMgbm90IGZvdW5kLiBJbml0aWFsaXppbmcuLi4iKQogICAgICAgIGluaXRfY29tbWFuZChhcmdzKQoKICAgIGlmIGFyZ3MuY29tbWFuZCAhPSAiaW5pdCI6CiAgICAgICAgY2hlY2tfdmVyc2lvbl91cGRhdGUoKQoKICAgIGlmIGFyZ3MuY29tbWFuZCA9PSAiaW5pdCI6CiAgICAgICAgcmV0dXJuIGluaXRfY29tbWFuZChhcmdzKQogICAgaWYgYXJncy5jb21tYW5kID09ICJjYXB0dXJlIjoKICAgICAgICByZXR1cm4gY2FwdHVyZV9jb21tYW5kKGFyZ3MpCiAgICBpZiBhcmdzLmNvbW1hbmQgPT0gImludGFrZSI6CiAgICAgICAgcHJpbnQoIltXQVJOXSAnaW50YWtlJyBpcyBkZXByZWNhdGVkLiBVc2UgJ2NhcHR1cmUnIGluc3RlYWQuIikKICAgICAgICByZXR1cm4gY2FwdHVyZV9jb21tYW5kKGFyZ3MpCiAgICBpZiBhcmdzLmNvbW1hbmQgPT0gInJ1biI6CiAgICAgICAgcmV0dXJuIHJ1bl9jb21tYW5kKGFyZ3MpCiAgICBpZiBhcmdzLmNvbW1hbmQgPT0gInBsYW4iOgogICAgICAgIHJldHVybiBwbGFuX2NvbW1hbmQoYXJncykKICAgIGlmIGFyZ3MuY29tbWFuZCA9PSAiZmluaXNoIjoKICAgICAgICByZXR1cm4gZmluaXNoX2NvbW1hbmQoYXJncykKICAgIGlmIGFyZ3MuY29tbWFuZCA9PSAiZG9jdG9yIjoKICAgICAgICByZXR1cm4gZG9jdG9yX2NvbW1hbmQoYXJncykKICAgIGlmIGFyZ3MuY29tbWFuZCA9PSAic3luYyI6CiAgICAgICAgcmV0dXJuIHN5bmNfY29tbWFuZChhcmdzKQoKICAgIHBhcnNlci5wcmludF9oZWxwKCkKICAgIHJldHVybiAxCgoKaWYgX19uYW1lX18gPT0gIl9fbWFpbl9fIjoKICAgIHJhaXNlIFN5c3RlbUV4aXQobWFpbigpKQo="
    
    # Checkbox patterns
    CHECKBOX_UNCHECKED = re.compile(r"^(\s*)-\s*\[\s*\](.*)$")
    CHECKBOX_CHECKED = re.compile(r"^(\s*)-\s*\[x\](.*)$", re.IGNORECASE)
    TRACEABILITY_LINK_RE = re.compile(r"\*\*(?:Implements|Answers|Solved by|Implemented by)\*\*:\s*\[([^\]]+)\]\(([^)]+)\)")
    
    DEFAULT_TOP_DOCS = {
        ATLAS_ROOT / "FRONT.md": """# Atlas\n\nThis repo uses Atlas vNext.\nUse: `python atlas.py init`\n\nQuick flow:\n1) `python atlas.py capture \"...\" --domain GEN`\n2) `python atlas.py run REQ-GEN-001`\n3) `python atlas.py finish RUN-REQ-GEN-001-step-01 --git <hash|no-commit> --success true`\n\nLinks: BOARD.md, CONVENTIONS.md, GOALS.md\n""",
        ATLAS_ROOT / "BOARD.md": """# BOARD\n\n>    **   ** .\n>   ,      .\n\n## Queue\n- (empty)\n\n## Active\n- (empty)\n\n## Done\n- (empty)\n\n> Last Reviewed: YYYY-MM-DD\n""",
        ATLAS_ROOT / "CONVENTIONS.md": """# CONVENTIONS\n\n## Boundaries\n\n### Always\n- Keep REQ/RULE/ADR/CQ as authority; do not auto-edit without intent.\n- Record verification steps in RUN.\n\n### Ask First\n- Add or remove dependencies.\n- Change storage layout under `.atlas/`.\n\n### Never\n- Hardcode secrets.\n- Modify existing REQ/RULE/ADR/CQ silently.\n\n## Roles (one-line)\n- REQ: what the system must do (SSOT).\n- RULE: constraints that must always hold (SSOT).\n- ADR: architectural decisions (SSOT).\n- CQ: questions the system must answer.\n- VIEW: human-readable context.\n- DRAFT: optional intake scratchpad.\n- RUN: execution plan and evidence.\n\n## Verification\n- `python atlas.py doctor`\n- (project tests as defined)\n""",
        ATLAS_ROOT / "GOALS.md": """# GOALS\n\n- Purpose: (fill in)\n- In scope: (fill in)\n- Out of scope: (fill in)\n""",
    }
    
    DEFAULT_TEMPLATES = {
        "REQ.md": """# [REQ-XXX-001] Title\n\n> **ID**: REQ-XXX-001\n> **Domain**: XXX\n> **Status**: Draft\n> **Last Updated**: YYYY-MM-DD\n> **Implemented-Git**: -\n> **Linked-RUN**: -\n> **Must-Read**: RULE-XXX-001\n\n---\n\n## Decision\n- (what must be true)\n\n## Input\n- (inputs)\n\n## Output\n- (outputs)\n\n## Acceptance Criteria\n- [ ] (criteria)\n""",
        "RULE.md": """# [RULE-XXX-001] Title\n\n> **ID**: RULE-XXX-001\n> **Domain**: XXX\n> **Priority**: Medium\n> **Last Updated**: YYYY-MM-DD\n> **Must-Read**: RULE-XXX-001\n\n---\n\n## Rule Statement\n- (always true / forbidden)\n\n## Scope\n- (where it applies)\n\n## Violation\n- (what counts as a violation)\n\n## Examples\n\n### Correct\n- (example)\n\n### Incorrect\n- (example)\n""",
        "CQ.md": """# [CQ-XXX-001] Title\n\n> **ID**: CQ-XXX-001\n> **Domain**: XXX\n> **Status**: Draft\n> **Last Updated**: YYYY-MM-DD\n\n---\n\n## Question\n- (what must the system answer?)\n\n## Expected Answer (Criteria)\n1. ...\n2. ...\n\n## Traceability\n- **Solves by**: [REQ-XXX-001](../req/REQ-XXX-001.md)\n- **Constrained by**: [RULE-XXX-001](../rule/RULE-XXX-001.md)\n""",
        "BRIEF.md": """# [BRIEF-XXX-001] Title\n\n> **ID**: BRIEF-XXX-001\n> **Domain**: XXX\n> **Status**: Active\n> **Date**: YYYY-MM-DD\n\n## 1. User Request\n- (raw text)\n\n## 2. Intent Summary\n- Goal:\n- Problem:\n\n## 3. Affected Artifacts\n- Create: \n- Modify: \n- Read: \n\n## 4. Proposed Changes\n1. \n2. \n\n## 5. Verification Criteria\n- [ ] \n""",
        "RUN.md": """# [RUN-REQ-XXX-001-step-01] Title\n\n> **ID**: RUN-REQ-XXX-001-step-01\n> **REQ**: REQ-XXX-001\n> **Status**: Planned\n> **Started**: YYYY-MM-DD\n> **Git**: -\n> **Completed**: -\n\n## Target REQ\n- REQ-XXX-001\n\n## Plan\n- [ ] \n\n## Verification\n- [ ] Test\n- [ ] Spec\n- [ ] Boundary\n\n## Output\n- (files created/modified)\n""",
        "VIEW.md": """# [VIEW-REQ-XXX-001] Title\n\n> **Refs**: REQ-XXX-001\n> **Last Updated**: YYYY-MM-DD\n\n## Summary\n- (human-readable summary)\n\n## References (SSOT)\n- [REQ-XXX-001](../req/REQ-XXX-001.md)\n""",
        "ADR.md": """# [ADR-XXX-001] Title\n\n> **ID**: ADR-XXX-001\n> **Domain**: XXX\n> **Status**: Draft\n> **Date**: YYYY-MM-DD\n> **Supersedes**: -\n> **Superseded-By**: -\n\n---\n\n## Context\n- (why this decision is needed)\n\n## Decision\n- (the decision)\n\n## Consequences\n- (trade-offs and follow-ups)\n\n## References\n- (REQ/RULE links)\n""",
    }
    
    DEFAULT_PROMPTS = {
        "onboarding.md": """# Atlas Audit Prompt
    
    > **Note**:  `Onboarding Prompt` **`Audit Prompt`** .
    >        ,     **(Consistency) (Audit)**  .
    
    ---
    
    ## Prompt
    
    ```
       **  (Auditor)**.
      Atlas (.atlas/   GOALS, CONVENTIONS, BOARD, FRONT)    (,  ,   )     .
    
    ### [Strict Rules]  
    1. **READ-ONLY**: ,          .
    2. **  (Suggestion Only)**:    "  "   .
    3. ** **:    , "    ?"   .
    
    ### [Checklist]  
    
    LLM        :
    
    #### 1. GOALS.md ( )
    - **Active Task  **:     GOALS     ?
    - **Scope Creep **:     In-Scope   ?     ?
    
    #### 2. CONVENTIONS.md ( )
    - **  **:       (Always, Never)   ?
    - ** **:   (: "  ")      ?
    
    #### 3. BOARD.md ( )
    - **Active  **: Active      ? (GOALS    Active ?)
    - **Queue  **: Queue     ,  GOALS   ?
    
    #### 4. FRONT.md ( )
    - **  **:        ?
    - ** **:          ?
    
    ---
    
    ### [Audit Report]  
    
            .
    
    - [PASS] ** (Pass)**
    - [WARN] ** (Warning)**:    .
    - [FAIL] **/ (Fail)**:  ,   .
    
    **[ ]**
    
    ### 1. GOALS.md
    - [PASS]    .
    - [WARN] ****: ' '   (Task-102)  , GOALS Scope  .  .
    
    ### 2. CONVENTIONS.md
    - [FAIL] ****:  'Type Hint '  ,  `utils.py`      .
        - ****:  ,     .
    
    ( BOARD, FRONT  )
    \n
    \n---
    \n
    \n###  [Recommended Actions]   
    \n
    \n        .
    \n
    \n1. **  (Needs Approval)**: /  ,      .
    \n2. **  (Edits)**:      (   ).
    \n3. **  (New Tasks)**:        (: "     ").
    \n
    \n**[ ]**
    \n###    
    \n1. **CONVENTIONS.md **: `Type Hint`  `Strict` `Optional`     .
    \n2. **GOALS.md **: ' '  In-Scope PM   Scope   .
    \n```
    \n
    
    ---
    
    ## How to execute
      (    ) LLM      .
    """,
    }
    
    
    def get_version() -> str:
        """Read version from VERSION file (SSOT)."""
        if VERSION_PATH.exists():
            return VERSION_PATH.read_text(encoding="utf-8").strip()
        return "unknown"
    
    
    def now_date() -> str:
        return datetime.now().strftime("%Y-%m-%d")
    
    
    def now_iso() -> str:
        return datetime.now().isoformat(timespec="seconds")
    
    
    def ensure_dir(path: Path) -> None:
        path.mkdir(parents=True, exist_ok=True)
    
    
    def read_text(path: Path) -> str:
        return path.read_text(encoding="utf-8")
    
    
    def write_text(path: Path, content: str) -> None:
        path.write_text(content, encoding="utf-8")
    
    
    def load_default_top_docs() -> dict[Path, str]:
        docs = dict(DEFAULT_TOP_DOCS)
        if SRC_DEFAULT_TOP_DOCS_DIR.is_dir():
            for path in sorted(SRC_DEFAULT_TOP_DOCS_DIR.glob("*.md")):
                target = ATLAS_ROOT / path.name
                if target in docs:
                    docs[target] = read_text(path)
        return docs
    
    
    def load_default_templates() -> dict[str, str]:
        templates = dict(DEFAULT_TEMPLATES)
        if SRC_DEFAULT_TEMPLATES_DIR.is_dir():
            for name in DEFAULT_TEMPLATES:
                src_path = SRC_DEFAULT_TEMPLATES_DIR / name
                if src_path.exists():
                    templates[name] = read_text(src_path)
        return templates
    
    
    def load_default_prompts() -> dict[str, str]:
        prompts = dict(DEFAULT_PROMPTS)
        if SRC_DEFAULT_PROMPTS_DIR.is_dir():
            for name in DEFAULT_PROMPTS:
                src_path = SRC_DEFAULT_PROMPTS_DIR / name
                if src_path.exists():
                    prompts[name] = read_text(src_path)
        return prompts
    
    
    def load_default_system_files() -> dict[str, str]:
        """Load VERSION and VERSIONING.md from src/.system_defaults/."""
        files: dict[str, str] = {}
        for name in ["VERSION", "VERSIONING.md", "CHANGELOG.md"]:
            src_path = SRC_DEFAULTS_ROOT / name
            if src_path.exists():
                files[name] = read_text(src_path)
        return files
    
    
    def load_default_src_files() -> dict[str, str]:
        """Load source files - either from defaults dir or embedded in atlas.py."""
        import base64
        files: dict[str, str] = {}
        
        # Try loading from src/.system_defaults/src/ first (development mode)
        src_dir = SRC_DEFAULTS_ROOT / "src"
        if src_dir.is_dir():
            for path in src_dir.glob("*.py"):
                files[path.name] = read_text(path)
        
        # If no files found, try embedded source (distribution mode)
        if not files and EMBEDDED_SRC_B64 != "__EMBEDDED_SRC_PLACEHOLDER__":
            try:
                decoded = base64.b64decode(EMBEDDED_SRC_B64).decode("utf-8")
                files["atlas_cli.py"] = decoded
            except Exception:
                pass
        
        return files
    
    
    def load_template(name: str) -> str:
        template_path = TEMPLATES_DIR / name
        if not template_path.exists():
            raise FileNotFoundError(f"Missing template: {template_path}")
        return read_text(template_path)
    
    
    def iter_md_files(dirs: Iterable[Path]) -> list[Path]:
        files: list[Path] = []
        for base in dirs:
            if not base.is_dir():
                continue
            for path in base.rglob("*.md"):
                files.append(path)
        return files
    
    
    def extract_meta(text: str) -> dict[str, str]:
        meta: dict[str, str] = {}
        head = "\n".join(text.splitlines()[:60])
        for line in head.splitlines():
            match = META_RE.match(line.strip())
            if match:
                meta[match.group(1).strip()] = match.group(2).strip()
        return meta
    
    
    def extract_header_id(text: str) -> Optional[str]:
        match = HEADER_ID_RE.search(text)
        return match.group(1).strip() if match else None
    
    
    def parse_must_read(value: str) -> list[str]:
        raw = value.strip()
        if raw.lower() == "none":
            return []
        tokens = [t.strip() for t in raw.split(",") if t.strip()]
        ids: list[str] = []
        for token in tokens:
            if token.startswith("[") and "]" in token and "(" in token:
                token = token[1 : token.index("]")].strip()
            if token:
                ids.append(token)
        return ids
    
    
    def next_id(prefix: str, domain: str, dir_path: Path, pattern: re.Pattern) -> str:
        max_n = 0
        if dir_path.exists():
            for path in dir_path.glob(f"{prefix}-{domain}-*.md"):
                match = pattern.match(path.stem)
                if match:
                    num = int(match.group(2))
                    if num > max_n:
                        max_n = num
        return f"{prefix}-{domain}-{max_n + 1:03d}"
    
    
    def next_run_step(req_id: str) -> int:
        match = REQ_ID_PATTERN.match(req_id)
        if not match:
            return 1
        domain = match.group(1)
        number = match.group(2)
        max_step = 0
        if RUN_DIR.exists():
            for path in RUN_DIR.glob(f"RUN-REQ-{domain}-{number}-step-*.md"):
                run_match = RUN_ID_PATTERN.match(path.stem)
                if run_match and run_match.group(1) == "REQ":
                    step = int(run_match.group(4))
                    if step > max_step:
                        max_step = step
        return max_step + 1
    
    
    def update_meta_line(text: str, key: str, value: str) -> str:
        lines = text.splitlines()
        updated = False
        for i, line in enumerate(lines):
            if line.startswith("> **") and line.split("**", 2)[1].strip() == key:
                lines[i] = f"> **{key}**: {value}"
                updated = True
                break
        if not updated:
            insert_at = 1 if lines else 0
            lines.insert(insert_at, f"> **{key}**: {value}")
        return "\n".join(lines) + "\n"
    
    
    def normalize_status(value: str) -> str:
        return value.strip().lower()
    
    
    def parse_completed_date(value: Optional[str]) -> Optional[datetime]:
        if not value:
            return None
        raw = value.strip()
        if raw == "-":
            return None
        try:
            return datetime.strptime(raw, "%Y-%m-%d")
        except ValueError:
            return None
    
    
    def parse_affected_artifacts(text: str) -> dict[str, list[str]]:
        artifacts = {"Create": [], "Modify": [], "Read": []}
        for line in text.splitlines():
            line = line.strip()
            for key in artifacts.keys():
                prefix = f"- {key}:"
                if line.startswith(prefix):
                    remainder = line[len(prefix) :].strip()
                    if remainder:
                        parts = [p.strip() for p in remainder.split(",") if p.strip()]
                        artifacts[key].extend(parts)
        return artifacts
    
    
    def update_brief_status(brief_id: str, status: str) -> bool:
        if not BRIEF_ID_PATTERN.match(brief_id):
            print(f"[WARN] Invalid BRIEF ID in RUN meta: {brief_id}")
            return False
        brief_path = BRIEF_DIR / f"{brief_id}.md"
        if not brief_path.exists():
            print(f"[WARN] BRIEF not found for RUN: {brief_path}")
            return False
        brief_text = read_text(brief_path)
        brief_text = update_meta_line(brief_text, "Status", status)
        write_text(brief_path, brief_text)
        print(f"[OK] Updated {brief_path}")
        return True
    
    
    def extract_ids_from_text(text: str) -> list[str]:
        return re.findall(r"(?:REQ|RULE|ADR|CQ|BRIEF|RUN)-[A-Z]+-\d{3}(?:-step-\d{2})?", text)
    
    
    def derive_title(text: str, fallback: str = "User Request") -> str:
        title_src = " ".join(text.strip().splitlines()).strip()
        if not title_src:
            return fallback
        return title_src[:60] + ("..." if len(title_src) > 60 else "")
    
    
    def is_relative_to(path: Path, base: Path) -> bool:
        try:
            path.relative_to(base)
            return True
        except ValueError:
            return False
    
    
    def req_id_from_run_id(run_id: str) -> Optional[str]:
        match = RUN_ID_PATTERN.match(run_id)
        if not match:
            return None
        kind, domain, number, _step = match.groups()
        if kind != "REQ":
            return None
        return f"REQ-{domain}-{number}"
    
    
    def detect_git_hash() -> Optional[str]:
        try:
            result = subprocess.run(
                ["git", "rev-parse", "HEAD"],
                capture_output=True,
                text=True,
                check=True,
            )
        except Exception:
            return None
        value = result.stdout.strip()
        return value if value else None
    
    
    def write_last_run(state: dict) -> None:
        ensure_dir(STATE_DIR)
        write_text(LAST_RUN_PATH, json.dumps(state, indent=2) + "\n")
    
    
    # =============================================================================
    # Sync utilities
    # =============================================================================
    
    def parse_checkboxes(text: str) -> list[tuple[int, bool, str]]:
        """Parse checkboxes from text. Returns list of (line_num, is_checked, content)."""
        results = []
        for i, line in enumerate(text.splitlines()):
            if CHECKBOX_CHECKED.match(line):
                match = CHECKBOX_CHECKED.match(line)
                results.append((i, True, match.group(2).strip()))
            elif CHECKBOX_UNCHECKED.match(line):
                match = CHECKBOX_UNCHECKED.match(line)
                results.append((i, False, match.group(2).strip()))
        return results
    
    
    def parse_traceability(text: str) -> dict[str, tuple[str, str]]:
        """Parse traceability links. Returns {link_type: (id, path)}."""
        results = {}
        for match in TRACEABILITY_LINK_RE.finditer(text):
            link_id = match.group(1).strip()
            link_path = match.group(2).strip()
            # Determine link type from context
            full_match = match.group(0)
            if "Implements" in full_match:
                results["Implements"] = (link_id, link_path)
            elif "Answers" in full_match:
                results["Answers"] = (link_id, link_path)
            elif "Solved by" in full_match:
                results["Solved by"] = (link_id, link_path)
            elif "Implemented by" in full_match:
                results["Implemented by"] = (link_id, link_path)
        return results
    
    
    def resolve_linked_docs(run_path: Path) -> dict[str, Path]:
        """Resolve RUN -> BRIEF -> REQ chain. Returns {doc_type: path}."""
        docs = {}
        text = read_text(run_path)
        meta = extract_meta(text)
    
        # RUN -> REQ (direct)
        req_id = meta.get("REQ") or req_id_from_run_id(run_path.stem)
        if req_id and REQ_ID_PATTERN.match(req_id):
            req_path = REQ_DIR / f"{req_id}.md"
            if req_path.exists():
                docs["REQ"] = req_path
        
        # RUN -> BRIEF
        brief_id = meta.get("Brief")
        if brief_id and BRIEF_ID_PATTERN.match(brief_id):
            brief_path = BRIEF_DIR / f"{brief_id}.md"
            if brief_path.exists():
                docs["BRIEF"] = brief_path
                
                # BRIEF -> REQ (via Implements link)
                brief_text = read_text(brief_path)
                trace = parse_traceability(brief_text)
                if "Implements" in trace:
                    req_id, req_rel_path = trace["Implements"]
                    req_path = (brief_path.parent / req_rel_path).resolve()
                    if req_path.exists():
                        docs["REQ"] = req_path
        
        return docs
    
    
    def compute_status_from_checkboxes(text: str) -> Optional[str]:
        """Compute status based on checkbox completion in Steps/Verification sections."""
        checkboxes = parse_checkboxes(text)
        if not checkboxes:
            return None
        
        total = len(checkboxes)
        checked = sum(1 for _, is_checked, _ in checkboxes if is_checked)
        
        if checked == 0:
            return "Planned"
        elif checked == total:
            return "Completed"
        else:
            return "InProgress"
    
    
    def generate_sync_diff(run_path: Path) -> dict:
        """Generate diff for sync operation. Returns changes to apply."""
        diff = {
            "run": {"path": run_path, "changes": []},
            "brief": None,
            "req": None,
        }
        
        run_text = read_text(run_path)
        run_meta = extract_meta(run_text)
        run_checkboxes = parse_checkboxes(run_text)
        
        # Compute RUN status from checkboxes
        computed_status = compute_status_from_checkboxes(run_text)
        current_status = run_meta.get("Status", "")
        
        if computed_status and normalize_status(computed_status) != normalize_status(current_status):
            diff["run"]["changes"].append({
                "type": "status",
                "from": current_status,
                "to": computed_status,
            })
        
        # Resolve linked documents
        linked = resolve_linked_docs(run_path)
        
        # BRIEF sync
        if "BRIEF" in linked:
            brief_path = linked["BRIEF"]
            brief_text = read_text(brief_path)
            brief_meta = extract_meta(brief_text)
            brief_status = brief_meta.get("Status", "")
            
            diff["brief"] = {
                "path": brief_path,
                "changes": [],
            }
            
            # Sync status
            if computed_status and normalize_status(brief_status) != normalize_status(computed_status):
                diff["brief"]["changes"].append({
                    "type": "status",
                    "from": brief_status,
                    "to": computed_status,
                })
        
        # REQ patch (don't auto-modify, generate patch)
        if "REQ" in linked:
            req_path = linked["REQ"]
            req_text = read_text(req_path)
            req_meta = extract_meta(req_text)
            req_checkboxes = parse_checkboxes(req_text)
            
            diff["req"] = {
                "path": req_path,
                "changes": [],
                "checkboxes": req_checkboxes,
            }
            
            # Check if REQ acceptance criteria should be updated based on RUN completion
            if computed_status == "Completed" and req_checkboxes:
                # Suggest marking related checkboxes
                diff["req"]["changes"].append({
                    "type": "checkbox_suggestion",
                    "message": f"RUN completed. Consider updating acceptance criteria in {req_path.name}",
                })
        
        return diff
    
    
    def print_sync_diff(diff: dict) -> None:
        """Print sync diff in human-readable format."""
        run_info = diff["run"]
        print(f"\n[SYNC] {run_info['path'].stem}")
        
        if run_info["changes"]:
            for change in run_info["changes"]:
                if change["type"] == "status":
                    print(f"   RUN: Status {change['from']}  {change['to']}")
        else:
            print("   RUN: (no changes)")
        
        if diff["brief"]:
            brief_info = diff["brief"]
            if brief_info["changes"]:
                for change in brief_info["changes"]:
                    if change["type"] == "status":
                        print(f"   BRIEF ({brief_info['path'].stem}): Status {change['from']}  {change['to']}")
            else:
                print(f"   BRIEF ({brief_info['path'].stem}): (no changes)")
        
        if diff["req"]:
            req_info = diff["req"]
            if req_info["changes"]:
                for change in req_info["changes"]:
                    if change["type"] == "checkbox_suggestion":
                        print(f"   REQ ({req_info['path'].stem}): [Patch required] {change['message']}")
            else:
                print(f"   REQ ({req_info['path'].stem}): (no changes)")
    
    
    def apply_brief_changes(diff: dict) -> bool:
        """Apply changes to BRIEF document."""
        if not diff["brief"] or not diff["brief"]["changes"]:
            return False
        
        brief_path = diff["brief"]["path"]
        brief_text = read_text(brief_path)
        
        for change in diff["brief"]["changes"]:
            if change["type"] == "status":
                brief_text = update_meta_line(brief_text, "Status", change["to"])
        
        write_text(brief_path, brief_text)
        print(f"[OK] Updated {brief_path}")
        return True
    
    
    def write_req_patch(diff: dict) -> Optional[Path]:
        """Write REQ patch file."""
        if not diff["req"] or not diff["req"]["changes"]:
            return None
        
        ensure_dir(PATCH_DIR)
        req_path = diff["req"]["path"]
        patch_path = PATCH_DIR / f"{req_path.stem}.patch.md"
        
        content = f"""# Patch for {req_path.stem}
    
    > **Generated**: {now_date()}
    > **Source RUN**: {diff['run']['path'].stem}
    
    ## Suggested Changes
    
    """
        for change in diff["req"]["changes"]:
            if change["type"] == "checkbox_suggestion":
                content += f"- {change['message']}\n"
        
        content += f"""
    ## How to Apply
    
    ```bash
    atlas sync {diff['run']['path'].stem} --apply-req
    ```
    
    Or manually edit: {req_path}
    """
        
        write_text(patch_path, content)
        print(f"[OK] Created patch: {patch_path}")
        return patch_path
    
    
    def apply_req_changes(diff: dict) -> bool:
        """Apply changes to REQ document (with warning)."""
        if not diff["req"] or not diff["req"]["changes"]:
            return False
        
        print("[WARN] Modifying REQ document (authority document)")
        req_path = diff["req"]["path"]
        req_text = read_text(req_path)
        
        # For now, just update status if RUN is completed
        run_changes = diff["run"]["changes"]
        for change in run_changes:
            if change["type"] == "status" and change["to"] == "Completed":
                req_text = update_meta_line(req_text, "Status", "Implemented")
        
        write_text(req_path, req_text)
        print(f"[OK] Updated {req_path}")
        return True
    
    
    def init_command(_args: argparse.Namespace) -> int:
        overwrite = getattr(_args, "overwrite", False)
        ensure_dir(ATLAS_ROOT)
        for d in [
            REQ_DIR,
            RULE_DIR,
            ADR_DIR,
            CQ_DIR,
            VIEWS_DIR,
            INBOX_DIR,
            DRAFTS_DIR,
            BRIEF_DIR,
            RUN_DIR,
            ARCHIVE_DIR,
            TEMPLATES_DIR,
            STATE_DIR,
            SYSTEM_ROOT / "prompts",
            SYSTEM_ROOT / "src",
        ]:
            ensure_dir(d)
    
        for path, content in load_default_top_docs().items():
            if overwrite or not path.exists():
                write_text(path, content)
    
        for name, content in load_default_templates().items():
            template_path = TEMPLATES_DIR / name
            if overwrite or not template_path.exists():
                write_text(template_path, content)
    
        prompts_dir = SYSTEM_ROOT / "prompts"
        for name, content in load_default_prompts().items():
            prompt_path = prompts_dir / name
            if overwrite or not prompt_path.exists():
                write_text(prompt_path, content)
                print(f"[OK] Created {prompt_path}")
    
        for name, content in load_default_system_files().items():
            system_path = SYSTEM_ROOT / name
            if overwrite or not system_path.exists():
                write_text(system_path, content)
                print(f"[OK] Created {system_path}")
    
        src_dir = SYSTEM_ROOT / "src"
        for name, content in load_default_src_files().items():
            src_path = src_dir / name
            if overwrite or not src_path.exists():
                write_text(src_path, content)
                print(f"[OK] Created {src_path}")
    
        if not LAST_RUN_PATH.exists():
            write_last_run({"stage": "idle", "updated_at": now_iso()})
    
        print("[OK] Atlas structure initialized.")
        print("[INFO] Run the prompt in .atlas/.system/prompts/onboarding.md to complete setup.")
        return 0
    
    
    def create_brief_doc(text: str, domain: str) -> Path:
        brief_id = next_id("BRIEF", domain, BRIEF_DIR, BRIEF_ID_PATTERN)
        title = derive_title(text)
        content = f"""# [{brief_id}] {title}
    
    > **ID**: {brief_id}
    > **Domain**: {domain}
    > **Status**: Active
    > **Date**: {now_date()}
    
    ## 1. User Request
    {text.strip()}
    
    ## 2. Intent Summary
    - Goal: 
    - Problem: 
    
    ## 3. Affected Artifacts
    - Create: 
    - Modify: 
    - Read: 
    
    ## 4. Proposed Changes
    1. 
    2. 
    
    ## 5. Verification Criteria
    - [ ] 
    """
        path = BRIEF_DIR / f"{brief_id}.md"
        ensure_dir(BRIEF_DIR)
        write_text(path, content)
        return path
    
    
    def capture_command(args: argparse.Namespace) -> int:
        domain = args.domain.upper()
        text = args.text.strip()
        if not text:
            print("[ERR] Empty input.")
            return 1
    
        title = derive_title(text)
        req_ids = [rid for rid in extract_ids_from_text(text) if rid.startswith("REQ-")]
        if not req_ids:
            req_ids = [next_id("REQ", domain, REQ_DIR, REQ_ID_PATTERN)]
    
        created = []
        for req_id in req_ids:
            if not REQ_ID_PATTERN.match(req_id):
                print(f"[WARN] Skipping invalid REQ ID: {req_id}")
                continue
            create_req_stub(req_id, title=title)
            req_path = REQ_DIR / f"{req_id}.md"
            if req_path.exists():
                append_capture_note(req_path, text)
            view_path = ensure_view_doc(req_id, title)
            created.append((req_path, view_path))
    
        if getattr(args, "to", None) == "brief":
            brief_path = create_brief_doc(text, domain)
            print(f"[OK] Created {brief_path}")
    
        for req_path, view_path in created:
            print(f"[OK] Updated {req_path}")
            print(f"[OK] Updated {view_path}")
        return 0
    
    
    def create_req_stub(req_id: str, title: Optional[str] = None) -> None:
        path = REQ_DIR / f"{req_id}.md"
        if path.exists():
            return
        match = REQ_ID_PATTERN.match(req_id)
        if not match:
            return
        domain = match.group(1)
        template = load_template("REQ.md")
        title = title or "Title"
        content = template.replace("REQ-XXX-001", req_id)
        content = content.replace("# [REQ-XXX-001] Title", f"# [{req_id}] {title}")
        content = content.replace("Domain**: XXX", f"Domain**: {domain}")
        content = content.replace("Last Updated**: YYYY-MM-DD", f"Last Updated**: {now_date()}")
        write_text(path, content)
    
    
    def append_capture_note(path: Path, text: str) -> None:
        note = text.strip()
        if not note:
            return
        content = read_text(path)
        stamp = now_date()
        block = f"\n## Capture ({stamp})\n{note}\n"
        if f"## Capture ({stamp})" in content:
            return
        write_text(path, content.rstrip() + block)
    
    
    def ensure_view_doc(req_id: str, title: str) -> Path:
        path = VIEWS_DIR / f"{req_id}.md"
        if not path.exists():
            template = load_template("VIEW.md")
            content = template.replace("REQ-XXX-001", req_id)
            content = content.replace("# [VIEW-REQ-XXX-001] Title", f"# [VIEW-{req_id}] {title}")
            content = content.replace("Last Updated**: YYYY-MM-DD", f"Last Updated**: {now_date()}")
            write_text(path, content)
            return path
    
        content = read_text(path)
        req_link = f"../req/{req_id}.md"
        if req_link not in content:
            if "## References (SSOT)" not in content:
                content = content.rstrip() + "\n\n## References (SSOT)\n"
            content = content.rstrip() + f"\n- [{req_id}]({req_link})\n"
            write_text(path, content)
        return path
    
    
    def run_command(args: argparse.Namespace) -> int:
        req_id = args.req_id
        if req_id.endswith(".md"):
            req_id = Path(req_id).stem
    
        match = REQ_ID_PATTERN.match(req_id)
        if not match:
            print(f"[ERR] Invalid REQ ID: {req_id}")
            return 1
    
        req_path = REQ_DIR / f"{req_id}.md"
        if not req_path.exists():
            print(f"[ERR] REQ not found: {req_path}")
            return 1
    
        domain = match.group(1)
        number = match.group(2)
        step = getattr(args, "step", None) or next_run_step(req_id)
        run_id = f"RUN-REQ-{domain}-{number}-step-{int(step):02d}"
        run_path = RUN_DIR / f"{run_id}.md"
        if run_path.exists():
            print(f"[ERR] RUN already exists: {run_path}")
            return 1
    
        content = f"""# [{run_id}] Plan
    
    > **ID**: {run_id}
    > **REQ**: {req_id}
    > **Status**: Planned
    > **Started**: {now_date()}
    > **Git**: -
    > **Completed**: -
    
    ## Target REQ
    - {req_id}
    
    ## Plan
    - [ ] 
    
    ## Verification
    - [ ] Test
    - [ ] Spec
    - [ ] Boundary
    
    ## Output
    - (files created/modified)
    """
        write_text(run_path, content)
    
        write_last_run(
            {
                "run_id": run_id,
                "req_id": req_id,
                "stage": "executing",
                "updated_at": now_iso(),
            }
        )
    
        print(f"[OK] Created {run_path}")
        return 0
    
    
    def plan_command(args: argparse.Namespace) -> int:
        print("[WARN] 'plan' is deprecated. Use 'run' instead.")
        args.req_id = args.brief_id
        return run_command(args)
    
    
    def finish_command(args: argparse.Namespace) -> int:
        run_id = args.run_id
        if run_id.endswith(".md"):
            run_id = Path(run_id).stem
    
        if not RUN_ID_PATTERN.match(run_id):
            print(f"[ERR] Invalid RUN ID: {run_id}")
            return 1
    
        run_path = RUN_DIR / f"{run_id}.md"
        if not run_path.exists():
            print(f"[ERR] RUN not found: {run_path}")
            return 1
    
        git_hash = args.git
        if not git_hash:
            git_hash = detect_git_hash()
        if not git_hash:
            print("[ERR] Missing git hash. Provide --git or ensure git is available.")
            return 1
    
        text = read_text(run_path)
        meta = extract_meta(text)
        brief_id = meta.get("Brief")
        req_id = meta.get("REQ") or req_id_from_run_id(run_id)
        status = "Completed" if args.success else "Failed"
        text = update_meta_line(text, "Status", status)
        text = update_meta_line(text, "Git", git_hash)
        text = update_meta_line(text, "Completed", now_date())
        write_text(run_path, text)
    
        if brief_id:
            update_brief_status(brief_id, status)
    
        if req_id:
            req_path = REQ_DIR / f"{req_id}.md"
            if req_path.exists():
                req_text = read_text(req_path)
                req_text = update_meta_line(req_text, "Implemented-Git", git_hash)
                req_text = update_meta_line(req_text, "Linked-RUN", run_id)
                req_text = update_meta_line(req_text, "Last Updated", now_date())
                write_text(req_path, req_text)
                print(f"[OK] Updated {req_path}")
    
        last_run_state = {
            "run_id": run_id,
            "stage": "finished",
            "git_hash": git_hash,
            "completed_at": now_iso(),
        }
        if brief_id:
            last_run_state["brief_id"] = brief_id
        if req_id:
            last_run_state["req_id"] = req_id
        write_last_run(last_run_state)
    
        print(f"[OK] Updated {run_path}")
        return 0
    
    
    def sync_command(args: argparse.Namespace) -> int:
        """Sync RUN status to BRIEF/REQ documents."""
        run_id = args.run_id
        if run_id.endswith(".md"):
            run_id = Path(run_id).stem
    
        if not RUN_ID_PATTERN.match(run_id):
            print(f"[ERR] Invalid RUN ID: {run_id}")
            return 1
    
        run_path = RUN_DIR / f"{run_id}.md"
        if not run_path.exists():
            print(f"[ERR] RUN not found: {run_path}")
            return 1
    
        # Generate diff
        diff = generate_sync_diff(run_path)
        
        # Always print diff (dry-run info)
        print_sync_diff(diff)
        
        # Check if any apply flags are set
        apply_brief = getattr(args, "apply_brief", False)
        apply_req = getattr(args, "apply_req", False)
        write_patch = getattr(args, "write_req_patch", False)
        
        if not (apply_brief or apply_req or write_patch):
            print("\n[INFO] Dry-run mode. Use --apply-brief, --write-req-patch, or --apply-req to make changes.")
            return 0
        
        # Apply RUN changes (always when any apply flag is set)
        if diff["run"]["changes"]:
            run_text = read_text(run_path)
            for change in diff["run"]["changes"]:
                if change["type"] == "status":
                    run_text = update_meta_line(run_text, "Status", change["to"])
            write_text(run_path, run_text)
            print(f"[OK] Updated {run_path}")
        
        # Apply BRIEF changes
        if apply_brief:
            apply_brief_changes(diff)
        
        # Write REQ patch
        if write_patch:
            write_req_patch(diff)
        
        # Apply REQ changes (with warning)
        if apply_req:
            apply_req_changes(diff)
        
        return 0
    
    
    def iter_links(text: str) -> list[str]:
        links = []
        in_code = False
        for line in text.splitlines():
            stripped = line.strip()
            if stripped.startswith("```"):
                in_code = not in_code
                continue
            if in_code:
                continue
            for match in LINK_RE.finditer(line):
                links.append(match.group(1).strip())
        return links
    
    
    def doctor_command(args: argparse.Namespace) -> int:
        issues = 0
        brief_statuses: dict[str, str] = {}
        run_brief_statuses: list[tuple[str, str, str, Optional[datetime]]] = []
    
        required_dirs = [
            REQ_DIR,
            RULE_DIR,
            ADR_DIR,
            CQ_DIR,
            VIEWS_DIR,
            INBOX_DIR,
            DRAFTS_DIR,
            BRIEF_DIR,
            RUN_DIR,
            ARCHIVE_DIR,
            SYSTEM_ROOT,
            TEMPLATES_DIR,
            STATE_DIR,
        ]
        for path in required_dirs:
            if not path.exists():
                print(f"[ERR] Missing directory: {path}")
                issues += 1
    
        for path in REQUIRED_TOP_DOCS:
            if not path.exists():
                print(f"[ERR] Missing top doc: {path}")
                issues += 1
    
        for path in OPTIONAL_TOP_DOCS:
            if not path.exists():
                print(f"[WARN] Missing optional doc: {path}")
    
        scan_dirs = [REQ_DIR, RULE_DIR, ADR_DIR, CQ_DIR, BRIEF_DIR, RUN_DIR]
        all_docs = iter_md_files(scan_dirs)
        all_ids: set[str] = set()
    
        for path in all_docs:
            text = read_text(path)
            meta = extract_meta(text)
            meta_id = meta.get("ID")
            header_id = extract_header_id(text)
            file_id = path.stem
            for candidate in [meta_id, header_id, file_id]:
                if candidate:
                    all_ids.add(candidate)
    
        for path in all_docs:
            text = read_text(path)
            meta = extract_meta(text)
            meta_id = meta.get("ID")
            header_id = extract_header_id(text)
            file_id = path.stem
    
            folder = path.parent.name
            expected_prefix = {
                "req": "REQ",
                "rule": "RULE",
                "adr": "ADR",
                "cq": "CQ",
                "brief": "BRIEF",
                "runs": "RUN",
            }.get(folder)
    
            if expected_prefix is None:
                continue
    
            if expected_prefix == "BRIEF":
                status = meta.get("Status")
                if not status:
                    print(f"[ERR] Missing Status: {path}")
                    issues += 1
                else:
                    brief_statuses[file_id] = status
    
            if expected_prefix == "RUN":
                brief_id = meta.get("Brief")
                run_status = meta.get("Status")
                completed = meta.get("Completed")
                if brief_id and run_status:
                    run_brief_statuses.append(
                        (file_id, brief_id, run_status, parse_completed_date(completed))
                    )
                if file_id.startswith("RUN-BRIEF-") and not brief_id:
                    print(f"[WARN] Missing Brief reference: {path}")
                    issues += 1
    
            if not meta_id:
                print(f"[ERR] Missing meta ID: {path}")
                issues += 1
            if not header_id:
                print(f"[ERR] Missing header ID: {path}")
                issues += 1
    
            pattern = {
                "REQ": REQ_ID_PATTERN,
                "RULE": RULE_ID_PATTERN,
                "ADR": ADR_ID_PATTERN,
                "CQ": CQ_ID_PATTERN,
                "BRIEF": BRIEF_ID_PATTERN,
                "RUN": RUN_ID_PATTERN,
            }[expected_prefix]
    
            if not pattern.match(file_id):
                print(f"[ERR] Invalid filename for {expected_prefix}: {path}")
                issues += 1
    
            if meta_id and meta_id != file_id:
                print(f"[ERR] Meta ID mismatch: {path}")
                issues += 1
            if header_id and header_id != file_id:
                print(f"[ERR] Header ID mismatch: {path}")
                issues += 1
    
            if expected_prefix in {"REQ", "RULE"}:
                must_read = meta.get("Must-Read")
                if must_read is None:
                    print(f"[ERR] Missing Must-Read: {path}")
                    issues += 1
                else:
                    ids = parse_must_read(must_read)
                    if not ids and must_read.strip().lower() != "none":
                        print(f"[ERR] Empty Must-Read: {path}")
                        issues += 1
                    for ref_id in ids:
                        prefix = ref_id.split("-", 1)[0]
                        if prefix not in ALLOWED_MUST_READ_PREFIXES:
                            print(f"[ERR] Must-Read disallowed ID: {path} -> {ref_id}")
                            issues += 1
                        if ref_id not in all_ids:
                            print(f"[ERR] Must-Read missing target: {path} -> {ref_id}")
                            issues += 1
    
            if expected_prefix == "REQ":
                status = meta.get("Status", "")
                implemented_git = meta.get("Implemented-Git", "").strip()
                if normalize_status(status) == "implemented" and (not implemented_git or implemented_git == "-"):
                    print(f"[WARN] Implemented REQ missing git hash: {path}")
                    issues += 1
    
            if args.links:
                for target in iter_links(text):
                    if not target or target.startswith("#"):
                        continue
                    if re.match(r"^[a-zA-Z][a-zA-Z0-9+.-]*:", target):
                        continue
                    resolved = (path.parent / target).resolve()
                    if not resolved.exists():
                        print(f"[ERR] Broken link: {path} -> {target}")
                        issues += 1
    
        # View -> REQ link validation
        view_refs: set[str] = set()
        for path in iter_md_files([VIEWS_DIR]):
            text = read_text(path)
            meta = extract_meta(text)
            refs_value = meta.get("Refs")
            if refs_value:
                for ref_id in parse_must_read(refs_value):
                    if ref_id.startswith("REQ-"):
                        view_refs.add(ref_id)
                        ref_path = REQ_DIR / f"{ref_id}.md"
                        if not ref_path.exists():
                            print(f"[WARN] View refs missing REQ: {path} -> {ref_id}")
                            issues += 1
            for target in iter_links(text):
                if not target or target.startswith("#"):
                    continue
                if re.match(r"^[a-zA-Z][a-zA-Z0-9+.-]*:", target):
                    continue
                resolved = (path.parent / target).resolve()
                if is_relative_to(resolved, REQ_DIR):
                    if not resolved.exists():
                        print(f"[WARN] Broken REQ link in view: {path} -> {target}")
                        issues += 1
                    else:
                        view_refs.add(resolved.stem)
    
        # REQ without any view reference
        req_ids = [path.stem for path in all_docs if path.parent.name == "req"]
        for req_id in req_ids:
            if req_id not in view_refs:
                print(f"[WARN] Missing view reference for REQ: {req_id}")
                issues += 1
    
        latest_run_by_brief: dict[str, tuple[str, str, Optional[datetime]]] = {}
        for run_id, brief_id, run_status, completed_at in run_brief_statuses:
            normalized = normalize_status(run_status)
            if normalized not in {"completed", "failed"}:
                continue
            existing = latest_run_by_brief.get(brief_id)
            if existing is None:
                latest_run_by_brief[brief_id] = (run_id, run_status, completed_at)
                continue
            existing_run_id, _, existing_completed = existing
            if completed_at and (existing_completed is None or completed_at > existing_completed):
                latest_run_by_brief[brief_id] = (run_id, run_status, completed_at)
            elif completed_at is None and existing_completed is None and run_id > existing_run_id:
                latest_run_by_brief[brief_id] = (run_id, run_status, completed_at)
    
        for brief_id, (run_id, run_status, _) in latest_run_by_brief.items():
            brief_status = brief_statuses.get(brief_id)
            if not brief_status:
                print(f"[WARN] BRIEF missing for RUN: {run_id} -> {brief_id}")
                issues += 1
                continue
            if normalize_status(brief_status) != normalize_status(run_status):
                print(
                    f"[WARN] BRIEF status mismatch: {brief_id} is {brief_status}, latest RUN {run_id} is {run_status}"
                )
                issues += 1
    
        if LAST_RUN_PATH.exists():
            try:
                state = json.loads(read_text(LAST_RUN_PATH))
            except json.JSONDecodeError:
                state = {}
                print(f"[ERR] Invalid JSON: {LAST_RUN_PATH}")
                issues += 1
            stage = state.get("stage")
            updated_at = state.get("updated_at") or state.get("completed_at")
            if stage == "executing" and updated_at:
                try:
                    ts = datetime.fromisoformat(updated_at)
                    if datetime.now() - ts > timedelta(hours=args.max_age_hours):
                        print(
                            f"[WARN] RUN may be unfinished (>{args.max_age_hours}h): {state.get('run_id')}"
                        )
                        issues += 1
                except ValueError:
                    print("[ERR] Invalid timestamp in last_run.json")
                    issues += 1
    
        print(f"[DONE] Doctor completed with {issues} issue(s).")
        return 0 if issues == 0 else 1
    
    
        print(f"[DONE] Doctor completed with {issues} issue(s).")
        return 0 if issues == 0 else 1
    
    
    def parse_version(v: str) -> tuple[int, ...]:
        try:
            return tuple(map(int, v.strip().split(".")))
        except ValueError:
            return (0, 0, 0)
    
    
    def check_version_update() -> None:
        """Check if Atlas has been updated and print changelog."""
        if not VERSION_PATH.exists():
            return
    
        installed_ver_str = VERSION_PATH.read_text(encoding="utf-8").strip()
        if not installed_ver_str:
            return
    
        installed_ver = parse_version(installed_ver_str)
        current_ver = parse_version(ATLAS_VERSION)
    
        if current_ver > installed_ver:
            print(f"\n[INFO] Upgrading Atlas: {installed_ver_str} -> {ATLAS_VERSION}")
            print("=" * 60)
            
            # Collect versions to print
            versions_to_print = []
            for ver_str in CHANGELOG:
                ver = parse_version(ver_str)
                if ver > installed_ver and ver <= current_ver:
                    versions_to_print.append((ver, ver_str))
            
            # Sort by version descending
            versions_to_print.sort(key=lambda x: x[0], reverse=True)
            
            for _, ver_str in versions_to_print:
                print(f"[{ver_str}]")
                for change in CHANGELOG[ver_str]:
                    print(f"- {change}")
                print()
                
            print("=" * 60)
            
            # Update VERSION file
            if VERSION_PATH.exists():
                write_text(VERSION_PATH, ATLAS_VERSION)
                print(f"[OK] Updated VERSION file to {ATLAS_VERSION}\n")
    
    
    def build_parser() -> argparse.ArgumentParser:
        parser = argparse.ArgumentParser(prog="atlas")
        parser.add_argument(
            "--version", "-v",
            action="version",
            version=f"Atlas {get_version()}"
        )
        sub = parser.add_subparsers(dest="command", required=False)
    
        init = sub.add_parser("init")
        init.add_argument("--overwrite", action="store_true")
    
        capture = sub.add_parser("capture")
        capture.add_argument("text")
        capture.add_argument("--domain", default="GEN")
        capture.add_argument("--to", choices=["brief"])
    
        intake = sub.add_parser("intake")
        intake.add_argument("text")
        intake.add_argument("--domain", default="GEN")
        intake.add_argument("--to", choices=["brief"])
    
        run = sub.add_parser("run")
        run.add_argument("req_id")
        run.add_argument("--step", type=int)
    
        plan = sub.add_parser("plan")
        plan.add_argument("brief_id")
        plan.add_argument("--step", type=int)
    
        finish = sub.add_parser("finish")
        finish.add_argument("run_id")
        finish.add_argument("--git")
        finish.add_argument("--success", type=lambda v: v.lower() == "true", required=True)
    
        doctor = sub.add_parser("doctor")
        doctor.add_argument("--links", action="store_true")
        doctor.add_argument("--max-age-hours", type=int, default=24)
    
        sync = sub.add_parser("sync", help="Sync RUN status to BRIEF/REQ documents")
        sync.add_argument("run_id", help="RUN document ID")
        sync.add_argument("--apply-brief", action="store_true", help="Apply changes to BRIEF document")
        sync.add_argument("--write-req-patch", action="store_true", help="Write REQ patch file")
        sync.add_argument("--apply-req", action="store_true", help="Apply changes to REQ document (caution)")
    
        return parser
    
    
    def main(argv: Optional[list[str]] = None) -> int:
        parser = build_parser()
        args = parser.parse_args(argv)
    
        if not args.command:
            parser.print_help()
            return 0
    
        if args.command != "init" and not ATLAS_ROOT.exists():
            print("[INFO] .atlas not found. Initializing...")
            init_command(args)
    
        if args.command != "init":
            check_version_update()
    
        if args.command == "init":
            return init_command(args)
        if args.command == "capture":
            return capture_command(args)
        if args.command == "intake":
            print("[WARN] 'intake' is deprecated. Use 'capture' instead.")
            return capture_command(args)
        if args.command == "run":
            return run_command(args)
        if args.command == "plan":
            return plan_command(args)
        if args.command == "finish":
            return finish_command(args)
        if args.command == "doctor":
            return doctor_command(args)
        if args.command == "sync":
            return sync_command(args)
    
        parser.print_help()
        return 1
    
    
    if __name__ == "__main__":
        raise SystemExit(main())
    