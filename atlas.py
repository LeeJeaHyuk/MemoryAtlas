#!/usr/bin/env python
import contextlib as __stickytape_contextlib

@__stickytape_contextlib.contextmanager
def __stickytape_temporary_dir():
    import tempfile
    import shutil
    dir_path = tempfile.mkdtemp()
    try:
        yield dir_path
    finally:
        shutil.rmtree(dir_path)

with __stickytape_temporary_dir() as __stickytape_working_dir:
    def __stickytape_write_module(path, contents):
        import os, os.path

        def make_package(path):
            parts = path.split("/")
            partial_path = __stickytape_working_dir
            for part in parts:
                partial_path = os.path.join(partial_path, part)
                if not os.path.exists(partial_path):
                    os.mkdir(partial_path)
                    with open(os.path.join(partial_path, "__init__.py"), "wb") as f:
                        f.write(b"\n")

        make_package(os.path.dirname(path))

        full_path = os.path.join(__stickytape_working_dir, path)
        with open(full_path, "wb") as module_file:
            module_file.write(contents)

    import sys as __stickytape_sys
    __stickytape_sys.path.insert(0, __stickytape_working_dir)

    #!/usr/bin/env python3
    """Atlas vNext CLI."""
    
    import argparse
    import json
    import os
    import re
    import sys
    from datetime import datetime, timedelta
    from pathlib import Path
    from typing import Iterable, Optional
    
    # If running from src/atlas_cli.py, parents[1] is the root.
    # If bundled as atlas.py in the root, parents[0] (or .parent) is the root.
    _path = Path(__file__).resolve()
    if _path.name == "atlas_cli.py":
        REPO_ROOT = _path.parents[1]
    else:
        REPO_ROOT = _path.parent
    
    ATLAS_ROOT = REPO_ROOT / ".atlas"
    SYSTEM_ROOT = ATLAS_ROOT / ".system"
    TEMPLATES_DIR = SYSTEM_ROOT / "templates"
    STATE_DIR = SYSTEM_ROOT / "state"
    LAST_RUN_PATH = STATE_DIR / "last_run.json"
    VERSION_PATH = SYSTEM_ROOT / "VERSION"
    SRC_DEFAULTS_ROOT = REPO_ROOT / "src" / ".system_defaults"
    SRC_DEFAULT_TEMPLATES_DIR = SRC_DEFAULTS_ROOT / "templates"
    SRC_DEFAULT_TOP_DOCS_DIR = SRC_DEFAULTS_ROOT / "top_docs"
    SRC_DEFAULT_PROMPTS_DIR = SRC_DEFAULTS_ROOT / "prompts"
    
    REQ_DIR = ATLAS_ROOT / "req"
    RULE_DIR = ATLAS_ROOT / "rule"
    CQ_DIR = ATLAS_ROOT / "cq"
    BRIEF_DIR = ATLAS_ROOT / "brief"
    RUN_DIR = ATLAS_ROOT / "runs"
    IDEA_DIR = ATLAS_ROOT / "idea"  # Unstructured notes, excluded from doctor
    
    REQUIRED_TOP_DOCS = [
        ATLAS_ROOT / "FRONT.md",
        ATLAS_ROOT / "BOARD.md",
        ATLAS_ROOT / "CONVENTIONS.md",
    ]
    
    OPTIONAL_TOP_DOCS = [
        ATLAS_ROOT / "GOALS.md",
    ]
    
    REQ_ID_PATTERN = re.compile(r"^REQ-([A-Z]+)-(\d{3})$")
    RULE_ID_PATTERN = re.compile(r"^RULE-([A-Z]+)-(\d{3})$")
    CQ_ID_PATTERN = re.compile(r"^CQ-([A-Z]+)-(\d{3})$")
    BRIEF_ID_PATTERN = re.compile(r"^BRIEF-([A-Z]+)-(\d{3})$")
    RUN_ID_PATTERN = re.compile(r"^RUN-(BRIEF|REQ)-([A-Z]+)-(\d{3})-step-(\d{2})$")
    
    META_RE = re.compile(r"^>\s*\*\*([^*]+)\*\*:\s*(.+)$")
    HEADER_ID_RE = re.compile(r"^#\s+\[([^\]]+)\]", re.M)
    LINK_RE = re.compile(r"\[[^\]]*\]\(([^)]+)\)")
    
    ALLOWED_MUST_READ_PREFIXES = {"RULE"}
    
    PATCH_DIR = ATLAS_ROOT / "patch"
    
    # Embedded source code (populated by build.py)
    # __EMBEDDED_SRC_PLACEHOLDER__ will be replaced with base64-encoded source
    EMBEDDED_SRC_B64 = "IyEvdXNyL2Jpbi9lbnYgcHl0aG9uMwoiIiJBdGxhcyB2TmV4dCBDTEkuIiIiCgppbXBvcnQgYXJncGFyc2UKaW1wb3J0IGpzb24KaW1wb3J0IG9zCmltcG9ydCByZQppbXBvcnQgc3lzCmZyb20gZGF0ZXRpbWUgaW1wb3J0IGRhdGV0aW1lLCB0aW1lZGVsdGEKZnJvbSBwYXRobGliIGltcG9ydCBQYXRoCmZyb20gdHlwaW5nIGltcG9ydCBJdGVyYWJsZSwgT3B0aW9uYWwKCiMgSWYgcnVubmluZyBmcm9tIHNyYy9hdGxhc19jbGkucHksIHBhcmVudHNbMV0gaXMgdGhlIHJvb3QuCiMgSWYgYnVuZGxlZCBhcyBhdGxhcy5weSBpbiB0aGUgcm9vdCwgcGFyZW50c1swXSAob3IgLnBhcmVudCkgaXMgdGhlIHJvb3QuCl9wYXRoID0gUGF0aChfX2ZpbGVfXykucmVzb2x2ZSgpCmlmIF9wYXRoLm5hbWUgPT0gImF0bGFzX2NsaS5weSI6CiAgICBSRVBPX1JPT1QgPSBfcGF0aC5wYXJlbnRzWzFdCmVsc2U6CiAgICBSRVBPX1JPT1QgPSBfcGF0aC5wYXJlbnQKCkFUTEFTX1JPT1QgPSBSRVBPX1JPT1QgLyAiLmF0bGFzIgpTWVNURU1fUk9PVCA9IEFUTEFTX1JPT1QgLyAiLnN5c3RlbSIKVEVNUExBVEVTX0RJUiA9IFNZU1RFTV9ST09UIC8gInRlbXBsYXRlcyIKU1RBVEVfRElSID0gU1lTVEVNX1JPT1QgLyAic3RhdGUiCkxBU1RfUlVOX1BBVEggPSBTVEFURV9ESVIgLyAibGFzdF9ydW4uanNvbiIKVkVSU0lPTl9QQVRIID0gU1lTVEVNX1JPT1QgLyAiVkVSU0lPTiIKU1JDX0RFRkFVTFRTX1JPT1QgPSBSRVBPX1JPT1QgLyAic3JjIiAvICIuc3lzdGVtX2RlZmF1bHRzIgpTUkNfREVGQVVMVF9URU1QTEFURVNfRElSID0gU1JDX0RFRkFVTFRTX1JPT1QgLyAidGVtcGxhdGVzIgpTUkNfREVGQVVMVF9UT1BfRE9DU19ESVIgPSBTUkNfREVGQVVMVFNfUk9PVCAvICJ0b3BfZG9jcyIKU1JDX0RFRkFVTFRfUFJPTVBUU19ESVIgPSBTUkNfREVGQVVMVFNfUk9PVCAvICJwcm9tcHRzIgoKUkVRX0RJUiA9IEFUTEFTX1JPT1QgLyAicmVxIgpSVUxFX0RJUiA9IEFUTEFTX1JPT1QgLyAicnVsZSIKQ1FfRElSID0gQVRMQVNfUk9PVCAvICJjcSIKQlJJRUZfRElSID0gQVRMQVNfUk9PVCAvICJicmllZiIKUlVOX0RJUiA9IEFUTEFTX1JPT1QgLyAicnVucyIKSURFQV9ESVIgPSBBVExBU19ST09UIC8gImlkZWEiICAjIFVuc3RydWN0dXJlZCBub3RlcywgZXhjbHVkZWQgZnJvbSBkb2N0b3IKClJFUVVJUkVEX1RPUF9ET0NTID0gWwogICAgQVRMQVNfUk9PVCAvICJGUk9OVC5tZCIsCiAgICBBVExBU19ST09UIC8gIkJPQVJELm1kIiwKICAgIEFUTEFTX1JPT1QgLyAiQ09OVkVOVElPTlMubWQiLApdCgpPUFRJT05BTF9UT1BfRE9DUyA9IFsKICAgIEFUTEFTX1JPT1QgLyAiR09BTFMubWQiLApdCgpSRVFfSURfUEFUVEVSTiA9IHJlLmNvbXBpbGUociJeUkVRLShbQS1aXSspLShcZHszfSkkIikKUlVMRV9JRF9QQVRURVJOID0gcmUuY29tcGlsZShyIl5SVUxFLShbQS1aXSspLShcZHszfSkkIikKQ1FfSURfUEFUVEVSTiA9IHJlLmNvbXBpbGUociJeQ1EtKFtBLVpdKyktKFxkezN9KSQiKQpCUklFRl9JRF9QQVRURVJOID0gcmUuY29tcGlsZShyIl5CUklFRi0oW0EtWl0rKS0oXGR7M30pJCIpClJVTl9JRF9QQVRURVJOID0gcmUuY29tcGlsZShyIl5SVU4tKEJSSUVGfFJFUSktKFtBLVpdKyktKFxkezN9KS1zdGVwLShcZHsyfSkkIikKCk1FVEFfUkUgPSByZS5jb21waWxlKHIiXj5ccypcKlwqKFteKl0rKVwqXCo6XHMqKC4rKSQiKQpIRUFERVJfSURfUkUgPSByZS5jb21waWxlKHIiXiNccytcWyhbXlxdXSspXF0iLCByZS5NKQpMSU5LX1JFID0gcmUuY29tcGlsZShyIlxbW15cXV0qXF1cKChbXildKylcKSIpCgpBTExPV0VEX01VU1RfUkVBRF9QUkVGSVhFUyA9IHsiUlVMRSJ9CgpQQVRDSF9ESVIgPSBBVExBU19ST09UIC8gInBhdGNoIgoKIyBFbWJlZGRlZCBzb3VyY2UgY29kZSAocG9wdWxhdGVkIGJ5IGJ1aWxkLnB5KQojIF9fRU1CRURERURfU1JDX1BMQUNFSE9MREVSX18gd2lsbCBiZSByZXBsYWNlZCB3aXRoIGJhc2U2NC1lbmNvZGVkIHNvdXJjZQpFTUJFRERFRF9TUkNfQjY0ID0gIl9fRU1CRURERURfU1JDX1BMQUNFSE9MREVSX18iCgojIENoZWNrYm94IHBhdHRlcm5zCkNIRUNLQk9YX1VOQ0hFQ0tFRCA9IHJlLmNvbXBpbGUociJeKFxzKiktXHMqXFtccypcXSguKikkIikKQ0hFQ0tCT1hfQ0hFQ0tFRCA9IHJlLmNvbXBpbGUociJeKFxzKiktXHMqXFt4XF0oLiopJCIsIHJlLklHTk9SRUNBU0UpClRSQUNFQUJJTElUWV9MSU5LX1JFID0gcmUuY29tcGlsZShyIlwqXCooPzpJbXBsZW1lbnRzfEFuc3dlcnN8U29sdmVkIGJ5fEltcGxlbWVudGVkIGJ5KVwqXCo6XHMqXFsoW15cXV0rKVxdXCgoW14pXSspXCkiKQoKREVGQVVMVF9UT1BfRE9DUyA9IHsKICAgIEFUTEFTX1JPT1QgLyAiRlJPTlQubWQiOiAiIiIjIEF0bGFzXG5cblRoaXMgcmVwbyB1c2VzIEF0bGFzIHZOZXh0LlxuVXNlOiBgcHl0aG9uIGF0bGFzLnB5IGluaXRgXG5cblF1aWNrIGZsb3c6XG4xKSBgcHl0aG9uIGF0bGFzLnB5IGludGFrZSBcIi4uLlwiIC0tZG9tYWluIEdFTmBcbjIpIGBweXRob24gYXRsYXMucHkgcGxhbiBCUklFRi1HRU4tMDAxYFxuMykgYHB5dGhvbiBhdGxhcy5weSBmaW5pc2ggUlVOLUJSSUVGLUdFTi0wMDEtc3RlcC0wMSAtLWdpdCA8aGFzaHxuby1jb21taXQ+IC0tc3VjY2VzcyB0cnVlYFxuXG5MaW5rczogQk9BUkQubWQsIENPTlZFTlRJT05TLm1kLCBHT0FMUy5tZFxuIiIiLAogICAgQVRMQVNfUk9PVCAvICJCT0FSRC5tZCI6ICIiIiMgQk9BUkRcblxuPiDsnbQg66y47ISc64qUIO2UhOuhnOygne2KuOydmCAqKu2YhOyerCDsnpHsl4Ug7IOB7YOcIOyKpOuDheyDtyoq7J2EIOuCmO2DgOuDheuLiOuLpC5cbj4g67mE7Ja0IOyeiOuKlCDqsr3smrAsIO2VtOuLuSDsg4Htg5zsl5Ag7ZW064u57ZWY64qUIOyekeyXheydtCDsl4bsnYzsnYQg7J2Y66+47ZWp64uI64ukLlxuXG4jIyBRdWV1ZVxuLSAoZW1wdHkpXG5cbiMjIEFjdGl2ZVxuLSAoZW1wdHkpXG5cbiMjIERvbmVcbi0gKGVtcHR5KVxuXG4+IExhc3QgUmV2aWV3ZWQ6IFlZWVktTU0tRERcbiIiIiwKICAgIEFUTEFTX1JPT1QgLyAiQ09OVkVOVElPTlMubWQiOiAiIiIjIENPTlZFTlRJT05TXG5cbiMjIEJvdW5kYXJpZXNcblxuIyMjIEFsd2F5c1xuLSBLZWVwIFJFUS9SVUxFL0NRIGFzIGF1dGhvcml0eTsgZG8gbm90IGF1dG8tZWRpdCB3aXRob3V0IGludGVudC5cbi0gUmVjb3JkIHZlcmlmaWNhdGlvbiBzdGVwcyBpbiBSVU4uXG5cbiMjIyBBc2sgRmlyc3Rcbi0gQWRkIG9yIHJlbW92ZSBkZXBlbmRlbmNpZXMuXG4tIENoYW5nZSBzdG9yYWdlIGxheW91dCB1bmRlciBgLmF0bGFzL2AuXG5cbiMjIyBOZXZlclxuLSBIYXJkY29kZSBzZWNyZXRzLlxuLSBNb2RpZnkgZXhpc3RpbmcgUkVRL1JVTEUvQ1Egc2lsZW50bHkuXG5cbiMjIFJvbGVzIChvbmUtbGluZSlcbi0gUkVROiB3aGF0IHRoZSBzeXN0ZW0gbXVzdCBkby5cbi0gUlVMRTogY29uc3RyYWludHMgdGhhdCBtdXN0IGFsd2F5cyBob2xkLlxuLSBDUTogcXVlc3Rpb25zIHRoZSBzeXN0ZW0gbXVzdCBhbnN3ZXIuXG4tIEJSSUVGOiBpbnRha2Ugc3VtbWFyeS5cbi0gUlVOOiBleGVjdXRpb24gcGxhbiBhbmQgZXZpZGVuY2UuXG5cbiMjIFZlcmlmaWNhdGlvblxuLSBgcHl0aG9uIGF0bGFzLnB5IGRvY3RvcmBcbi0gKHByb2plY3QgdGVzdHMgYXMgZGVmaW5lZClcbiIiIiwKICAgIEFUTEFTX1JPT1QgLyAiR09BTFMubWQiOiAiIiIjIEdPQUxTXG5cbi0gUHVycG9zZTogKGZpbGwgaW4pXG4tIEluIHNjb3BlOiAoZmlsbCBpbilcbi0gT3V0IG9mIHNjb3BlOiAoZmlsbCBpbilcbiIiIiwKfQoKREVGQVVMVF9URU1QTEFURVMgPSB7CiAgICAiUkVRLm1kIjogIiIiIyBbUkVRLVhYWC0wMDFdIFRpdGxlXG5cbj4gKipJRCoqOiBSRVEtWFhYLTAwMVxuPiAqKkRvbWFpbioqOiBYWFhcbj4gKipTdGF0dXMqKjogRHJhZnRcbj4gKipMYXN0IFVwZGF0ZWQqKjogWVlZWS1NTS1ERFxuPiAqKk11c3QtUmVhZCoqOiBSVUxFLVhYWC0wMDFcblxuLS0tXG5cbiMjIERlY2lzaW9uXG4tICh3aGF0IG11c3QgYmUgdHJ1ZSlcblxuIyMgSW5wdXRcbi0gKGlucHV0cylcblxuIyMgT3V0cHV0XG4tIChvdXRwdXRzKVxuXG4jIyBBY2NlcHRhbmNlIENyaXRlcmlhXG4tIFsgXSAoY3JpdGVyaWEpXG4iIiIsCiAgICAiUlVMRS5tZCI6ICIiIiMgW1JVTEUtWFhYLTAwMV0gVGl0bGVcblxuPiAqKklEKio6IFJVTEUtWFhYLTAwMVxuPiAqKkRvbWFpbioqOiBYWFhcbj4gKipQcmlvcml0eSoqOiBNZWRpdW1cbj4gKipMYXN0IFVwZGF0ZWQqKjogWVlZWS1NTS1ERFxuPiAqKk11c3QtUmVhZCoqOiBSVUxFLVhYWC0wMDFcblxuLS0tXG5cbiMjIFJ1bGUgU3RhdGVtZW50XG4tIChhbHdheXMgdHJ1ZSAvIGZvcmJpZGRlbilcblxuIyMgU2NvcGVcbi0gKHdoZXJlIGl0IGFwcGxpZXMpXG5cbiMjIFZpb2xhdGlvblxuLSAod2hhdCBjb3VudHMgYXMgYSB2aW9sYXRpb24pXG5cbiMjIEV4YW1wbGVzXG5cbiMjIyBDb3JyZWN0XG4tIChleGFtcGxlKVxuXG4jIyMgSW5jb3JyZWN0XG4tIChleGFtcGxlKVxuIiIiLAogICAgIkNRLm1kIjogIiIiIyBbQ1EtWFhYLTAwMV0gVGl0bGVcblxuPiAqKklEKio6IENRLVhYWC0wMDFcbj4gKipEb21haW4qKjogWFhYXG4+ICoqU3RhdHVzKio6IERyYWZ0XG4+ICoqTGFzdCBVcGRhdGVkKio6IFlZWVktTU0tRERcblxuLS0tXG5cbiMjIFF1ZXN0aW9uXG4tICh3aGF0IG11c3QgdGhlIHN5c3RlbSBhbnN3ZXI/KVxuXG4jIyBFeHBlY3RlZCBBbnN3ZXIgKENyaXRlcmlhKVxuMS4gLi4uXG4yLiAuLi5cblxuIyMgVHJhY2VhYmlsaXR5XG4tICoqU29sdmVzIGJ5Kio6IFtSRVEtWFhYLTAwMV0oLi4vcmVxL1JFUS1YWFgtMDAxLm1kKVxuLSAqKkNvbnN0cmFpbmVkIGJ5Kio6IFtSVUxFLVhYWC0wMDFdKC4uL3J1bGUvUlVMRS1YWFgtMDAxLm1kKVxuIiIiLAogICAgIkJSSUVGLm1kIjogIiIiIyBbQlJJRUYtWFhYLTAwMV0gVGl0bGVcblxuPiAqKklEKio6IEJSSUVGLVhYWC0wMDFcbj4gKipEb21haW4qKjogWFhYXG4+ICoqU3RhdHVzKio6IEFjdGl2ZVxuPiAqKkRhdGUqKjogWVlZWS1NTS1ERFxuXG4jIyAxLiBVc2VyIFJlcXVlc3Rcbi0gKHJhdyB0ZXh0KVxuXG4jIyAyLiBJbnRlbnQgU3VtbWFyeVxuLSBHb2FsOlxuLSBQcm9ibGVtOlxuXG4jIyAzLiBBZmZlY3RlZCBBcnRpZmFjdHNcbi0gQ3JlYXRlOiBcbi0gTW9kaWZ5OiBcbi0gUmVhZDogXG5cbiMjIDQuIFByb3Bvc2VkIENoYW5nZXNcbjEuIFxuMi4gXG5cbiMjIDUuIFZlcmlmaWNhdGlvbiBDcml0ZXJpYVxuLSBbIF0gXG4iIiIsCiAgICAiUlVOLm1kIjogIiIiIyBbUlVOLUJSSUVGLVhYWC0wMDEtc3RlcC0wMV0gVGl0bGVcblxuPiAqKklEKio6IFJVTi1CUklFRi1YWFgtMDAxLXN0ZXAtMDFcbj4gKipCcmllZioqOiBCUklFRi1YWFgtMDAxXG4+ICoqU3RhdHVzKio6IFBsYW5uZWRcbj4gKipTdGFydGVkKio6IFlZWVktTU0tRERcbj4gKipHaXQqKjogLVxuPiAqKkNvbXBsZXRlZCoqOiAtXG5cbiMjIElucHV0XG4tIChkb2N1bWVudHMgdG8gcmVhZClcblxuIyMgU3RlcHNcbi0gWyBdIFxuXG4jIyBWZXJpZmljYXRpb25cbi0gWyBdIFRlc3Rcbi0gWyBdIFNwZWNcbi0gWyBdIEJvdW5kYXJ5XG5cbiMjIE91dHB1dFxuLSAoZmlsZXMgY3JlYXRlZC9tb2RpZmllZClcbiIiIiwKfQoKREVGQVVMVF9QUk9NUFRTID0gewogICAgIm9uYm9hcmRpbmcubWQiOiAiIiIjIEF0bGFzIEF1ZGl0IFByb21wdAoKPiAqKk5vdGUqKjog6riw7KG0IGBPbmJvYXJkaW5nIFByb21wdGDqsIAgKipgQXVkaXQgUHJvbXB0YCoq66GcIOyerOygleydmOuQmOyXiOyKteuLiOuLpC4KPiDsnbQg7ZSE66Gs7ZSE7Yq464qUIOuNlCDsnbTsg4Eg7YyM7J287J2EIOyekOuPmeycvOuhnCDsg53shLHtlZjsp4Ag7JWK7Jy866mwLCDtmITsnqwg7ZSE66Gc7KCd7Yq47JmAIOusuOyEnCDqsITsnZggKirsoJXtlanshLEoQ29uc2lzdGVuY3kp7J2EIOqwkOyCrChBdWRpdCkqKu2VmOuKlCDsl63tlaDsnYQg7IiY7ZaJ7ZWp64uI64ukLgoKLS0tCgojIyBQcm9tcHQKCmBgYArri7nsi6DsnYAg7J20IO2UhOuhnOygne2KuOydmCAqKuusuOyEnCDsoJXtlanshLEg6rCQ7IKs6rSAKEF1ZGl0b3IpKirsnoXri4jri6QuCuydtOuvuCDsobTsnqztlZjripQgQXRsYXMg66y47ISc65OkKC5hdGxhcy8g7Y+0642UIOuCtCBHT0FMUywgQ09OVkVOVElPTlMsIEJPQVJELCBGUk9OVCnsnbQg7ZiE7J6sIO2UhOuhnOygne2KuOydmCDsi6TsoJwg7IOB7YOcKOy9lOuTnCwg7LWc6re8IOyekeyXhSwg6riw7IigIOyKpO2DnSDrk7Ep7JmAIOydvOy5mO2VmOuKlOyngCDsoJDqsoDtlZjripQg6rKD7J20IOyjvCDsnoTrrLTsnoXri4jri6QuCgojIyMgW1N0cmljdCBSdWxlc10g7ZW17IusIOq3nOy5mQoxLiAqKlJFQUQtT05MWSoqOiDsoIjrjIAsIOyWtOuWpCDqsr3smrDsl5Drj4Qg6riw7KG0IO2MjOydvOydhCDsp4HsoJEg7IiY7KCV7ZWY6rGw64KYIOuCtOyaqeydhCDsnpDrj5kg7JeF642w7J207Yq47ZWY7KeAIOuniOyEuOyalC4KMi4gKirsoJzslYgg66qo65OcIChTdWdnZXN0aW9uIE9ubHkpKio6IOu2iOydvOy5mOuCmCDriITrnb3snbQg67Cc6rKs65CY66m0ICLslrTrlrvqsowg7IiY7KCV7ZWY66m0IOyii+ydhOyngCLrpbwg7KCc7JWIIO2YleyLneycvOuhnOunjCDstpzroKXtlZjshLjsmpQuCjMuICoq67mE7YyQ7KCBIOyLnOqwgSoqOiDri6jsiJztnogg64K07Jqp7J2EIOyalOyVve2VmOyngCDrp5Dqs6AsICLsoJXrp5Ag7J20IOuCtOyaqeydtCDtmITsnqwg7Jyg7Zqo7ZWc6rCAPyLrpbwg64GK7J6E7JeG7J20IOydmOyLrO2VmOupsCDqsoDspp3tlZjshLjsmpQuCgojIyMgW0NoZWNrbGlzdF0g6rKA7IKsIOq0gOygkAoKTExN7J2AIOuLpOydjCDquLDspIDsl5Ag65Sw6528IOqwgSDrrLjshJzrpbwg7JeE6rKp7ZWY6rKMIO2PieqwgO2VtOyVvCDtlanri4jri6Q6CgojIyMjIDEuIEdPQUxTLm1kICjrqqntkZwg7KCV7ZWp7ISxKQotICoqQWN0aXZlIFRhc2vsmYAg7J287LmYIOyXrOu2gCoqOiDtmITsnqwg7KeE7ZaJIOykkeyduCDsnpHsl4Xrk6TsnbQgR09BTFPsl5Ag7KCV7J2Y65CcIO2VteyLrCDrqqntkZzrpbwg67KX7Ja064KY7KeAIOyViuyVmOuKlOqwgD8KLSAqKlNjb3BlIENyZWVwIOqwkOyngCoqOiDstZzqt7wg64W87J2Y65CY6rGw64KYIOy2lOqwgOuQnCDquLDriqXsnbQgSW4tU2NvcGUg67KU7JyEIOuCtOyXkCDsnojripTqsIA/IOyVhOuLiOuptCDrspTsnITrpbwg7KGw7Jqp7Z6IIOuEk+2eiOqzoCDsnojripTqsIA/CgojIyMjIDIuIENPTlZFTlRJT05TLm1kICjqt5zsuZkg7ZiE7Iuk7ISxKQotICoq7JyE67CYIOqwgOuKpeyEsSDsoJDqsoAqKjog7Iuk7KCcIOy9lOuTnOuCmCDstZzqt7wg7Luk67CLIOuCtOyaqeydtCDrrLjshJzsnZgg6rec7LmZKEFsd2F5cywgTmV2ZXIp7J2EIOychOuwmO2VmOqzoCDsnojsp4Ag7JWK7J2A6rCAPwotICoq6rWs7LK07ISxIOqygOymnSoqOiDqt5zsuZnsnbQg64SI66y0IOy2lOyDgeyggeydtOyWtOyEnCjsmIg6ICLquajrgZftlZwg7L2U65OcIOyekeyEsSIpIOyLpOygnCDsp4DsuajsnbQg65CY7KeAIOuqu+2VmOuKlCDrtoDrtoTsnYAg7JeG64qU6rCAPwoKIyMjIyAzLiBCT0FSRC5tZCAo7ZiE7ZmpIOuPmeq4sO2ZlCkKLSAqKkFjdGl2ZSDsg4Htg5wg6rKA7KadKio6IEFjdGl2ZeyXkCDsnojripQg7J6R7JeF7J20IO2YhOyerCDsi6TsoJzroZwg7KeE7ZaJIOykkeyduOqwgD8gKEdPQUxTIOuylOychOulvCDrspfslrTrgpwg7J6R7JeF7J20IEFjdGl2ZeyXkCDsnojripTqsIA/KQotICoqUXVldWUg67Cp7LmYIOygkOqygCoqOiBRdWV1ZeyXkCDsnojripQg7ZWt66qp65Ok7J20IOuEiOustCDsmKTrnpgg67Cp7LmY65CY7Ja0LCDtmITsnqzsnZggR09BTFPsmYAg66ee7KeAIOyViuqyjCDrkJjsl4jripTqsIA/CgojIyMjIDQuIEZST05ULm1kICjtmZjqsr0g7LWc7Iug7ZmUKQotICoq6riw7IigIOyKpO2DnSDtmITsi6TtmZQqKjog66y47ISc7JeQIOygge2ejCDquLDsiKAg7Iqk7YOd7J20IOyLpOygnCDtlITroZzsoJ3tirgg7L2U65Oc7JmAIOydvOy5mO2VmOuKlOqwgD8KLSAqKuyVlOusteyggSDsoITsoJwqKjog7YyAIOuCtOyXkOyEnCDslZTrrLXsoIHsnLzroZwg7ZWp7J2Y65CcIOykkeyalO2VnCDrs4Dqsr0g7IKs7ZWt7J20IOusuOyEnOyXkOyEnCDriITrnb3rkJjsp4Ag7JWK7JWY64qU6rCAPwoKLS0tCgojIyMgW0F1ZGl0IFJlcG9ydF0g7Lac66ClIOyWkeyLnQoK6rCBIO2MjOydvOuzhOuhnCDslYTrnpgg7IOB7YOcIOyVhOydtOy9mOydhCDsgqzsmqntlZjsl6wg7KeE64uoIOqysOqzvOulvCDstpzroKXtlZjshLjsmpQuCgotIFtQQVNTXSAqKuydvOy5mCAoUGFzcykqKgotIFtXQVJOXSAqKuydmOyLrCAoV2FybmluZykqKjog7ZmV7J247J20IO2VhOyalO2VmOqxsOuCmCDrqqjtmLjtlZwg67aA67aELgotIFtGQUlMXSAqKuu2iOydvOy5mC/riITrnb0gKEZhaWwpKio6IOuqhe2Zle2VnCDsmKTrpZgsIOymieyLnCDsiJjsoJUg7ZWE7JqULgoKKipb7J6R7ISxIOyYiOyLnF0qKgoKIyMjIDEuIEdPQUxTLm1kCi0gW1BBU1NdIO2VteyLrCDrqqntkZwg7Jes7KCE7Z6IIOycoO2aqO2VqC4KLSBbV0FSTl0gKirsnZjsi6wqKjogJ+yLpOyLnOqwhCDssYTtjIUnIOq4sOuKpeydtCDstZzqt7wg7J6R7JeFKFRhc2stMTAyKeyXkOyEnCDqtaztmIQg7KSR7J24642wLCBHT0FMU+ydmCBTY29wZeyXkOuKlCDrqoXsi5zrkJjsp4Ag7JWK7JWY7J2MLiDsl4XrjbDsnbTtirgg7ZWE7JqULgoKIyMjIDIuIENPTlZFTlRJT05TLm1kCi0gW0ZBSUxdICoq67aI7J287LmYKio6IOusuOyEnOyXkOuKlCAnVHlwZSBIaW50IO2VhOyImCfrnbzqs6Ag65CY7Ja0IOyeiOycvOuCmCwg7LWc6re8IGB1dGlscy5weWAg65Ox7JeQ7IScIOunjuydgCDtlajsiJjqsIAg7YOA7J207ZWRIOyXhuydtCDsnpHshLHrkKguCiAgICAtICoq7KCc7JWIKio6IOq3nOy5meydhCDqsJXtmZTtlZjqsbDrgpgsIOyYiOyZuCDsg4HtmansnYQg66y47ISc7JeQIOuqheyLnO2VoCDqsoMuCgoo7J207ZWYIEJPQVJELCBGUk9OVCDrj5nsnbwg7Y+s66e3KQpgYGAKCi0tLQoKIyMgSG93IHRvIGV4ZWN1dGUK7J20IO2UhOuhrO2UhO2KuOuKlCDsoJXquLDsoIHsnLzroZwo65iQ64qUIO2UhOuhnOygne2KuCDrsKntlqXshLHsnbQg7Z2U65Ok66a0IOuVjCkgTExN7JeQ6rKMIOygnOyLnO2VmOyXrCDrrLjshJwg67aA7LGE66W8IOygkOqygO2VmOuKlCDsmqnrj4TroZwg7IKs7Jqp7ZWp64uI64ukLgoiIiIsCn0KCgpkZWYgZ2V0X3ZlcnNpb24oKSAtPiBzdHI6CiAgICAiIiJSZWFkIHZlcnNpb24gZnJvbSBWRVJTSU9OIGZpbGUgKFNTT1QpLiIiIgogICAgaWYgVkVSU0lPTl9QQVRILmV4aXN0cygpOgogICAgICAgIHJldHVybiBWRVJTSU9OX1BBVEgucmVhZF90ZXh0KGVuY29kaW5nPSJ1dGYtOCIpLnN0cmlwKCkKICAgIHJldHVybiAidW5rbm93biIKCgpkZWYgbm93X2RhdGUoKSAtPiBzdHI6CiAgICByZXR1cm4gZGF0ZXRpbWUubm93KCkuc3RyZnRpbWUoIiVZLSVtLSVkIikKCgpkZWYgbm93X2lzbygpIC0+IHN0cjoKICAgIHJldHVybiBkYXRldGltZS5ub3coKS5pc29mb3JtYXQodGltZXNwZWM9InNlY29uZHMiKQoKCmRlZiBlbnN1cmVfZGlyKHBhdGg6IFBhdGgpIC0+IE5vbmU6CiAgICBwYXRoLm1rZGlyKHBhcmVudHM9VHJ1ZSwgZXhpc3Rfb2s9VHJ1ZSkKCgpkZWYgcmVhZF90ZXh0KHBhdGg6IFBhdGgpIC0+IHN0cjoKICAgIHJldHVybiBwYXRoLnJlYWRfdGV4dChlbmNvZGluZz0idXRmLTgiKQoKCmRlZiB3cml0ZV90ZXh0KHBhdGg6IFBhdGgsIGNvbnRlbnQ6IHN0cikgLT4gTm9uZToKICAgIHBhdGgud3JpdGVfdGV4dChjb250ZW50LCBlbmNvZGluZz0idXRmLTgiKQoKCmRlZiBsb2FkX2RlZmF1bHRfdG9wX2RvY3MoKSAtPiBkaWN0W1BhdGgsIHN0cl06CiAgICBkb2NzID0gZGljdChERUZBVUxUX1RPUF9ET0NTKQogICAgaWYgU1JDX0RFRkFVTFRfVE9QX0RPQ1NfRElSLmlzX2RpcigpOgogICAgICAgIGZvciBwYXRoIGluIHNvcnRlZChTUkNfREVGQVVMVF9UT1BfRE9DU19ESVIuZ2xvYigiKi5tZCIpKToKICAgICAgICAgICAgdGFyZ2V0ID0gQVRMQVNfUk9PVCAvIHBhdGgubmFtZQogICAgICAgICAgICBpZiB0YXJnZXQgaW4gZG9jczoKICAgICAgICAgICAgICAgIGRvY3NbdGFyZ2V0XSA9IHJlYWRfdGV4dChwYXRoKQogICAgcmV0dXJuIGRvY3MKCgpkZWYgbG9hZF9kZWZhdWx0X3RlbXBsYXRlcygpIC0+IGRpY3Rbc3RyLCBzdHJdOgogICAgdGVtcGxhdGVzID0gZGljdChERUZBVUxUX1RFTVBMQVRFUykKICAgIGlmIFNSQ19ERUZBVUxUX1RFTVBMQVRFU19ESVIuaXNfZGlyKCk6CiAgICAgICAgZm9yIG5hbWUgaW4gREVGQVVMVF9URU1QTEFURVM6CiAgICAgICAgICAgIHNyY19wYXRoID0gU1JDX0RFRkFVTFRfVEVNUExBVEVTX0RJUiAvIG5hbWUKICAgICAgICAgICAgaWYgc3JjX3BhdGguZXhpc3RzKCk6CiAgICAgICAgICAgICAgICB0ZW1wbGF0ZXNbbmFtZV0gPSByZWFkX3RleHQoc3JjX3BhdGgpCiAgICByZXR1cm4gdGVtcGxhdGVzCgoKZGVmIGxvYWRfZGVmYXVsdF9wcm9tcHRzKCkgLT4gZGljdFtzdHIsIHN0cl06CiAgICBwcm9tcHRzID0gZGljdChERUZBVUxUX1BST01QVFMpCiAgICBpZiBTUkNfREVGQVVMVF9QUk9NUFRTX0RJUi5pc19kaXIoKToKICAgICAgICBmb3IgbmFtZSBpbiBERUZBVUxUX1BST01QVFM6CiAgICAgICAgICAgIHNyY19wYXRoID0gU1JDX0RFRkFVTFRfUFJPTVBUU19ESVIgLyBuYW1lCiAgICAgICAgICAgIGlmIHNyY19wYXRoLmV4aXN0cygpOgogICAgICAgICAgICAgICAgcHJvbXB0c1tuYW1lXSA9IHJlYWRfdGV4dChzcmNfcGF0aCkKICAgIHJldHVybiBwcm9tcHRzCgoKZGVmIGxvYWRfZGVmYXVsdF9zeXN0ZW1fZmlsZXMoKSAtPiBkaWN0W3N0ciwgc3RyXToKICAgICIiIkxvYWQgVkVSU0lPTiBhbmQgVkVSU0lPTklORy5tZCBmcm9tIHNyYy8uc3lzdGVtX2RlZmF1bHRzLy4iIiIKICAgIGZpbGVzOiBkaWN0W3N0ciwgc3RyXSA9IHt9CiAgICBmb3IgbmFtZSBpbiBbIlZFUlNJT04iLCAiVkVSU0lPTklORy5tZCJdOgogICAgICAgIHNyY19wYXRoID0gU1JDX0RFRkFVTFRTX1JPT1QgLyBuYW1lCiAgICAgICAgaWYgc3JjX3BhdGguZXhpc3RzKCk6CiAgICAgICAgICAgIGZpbGVzW25hbWVdID0gcmVhZF90ZXh0KHNyY19wYXRoKQogICAgcmV0dXJuIGZpbGVzCgoKZGVmIGxvYWRfZGVmYXVsdF9zcmNfZmlsZXMoKSAtPiBkaWN0W3N0ciwgc3RyXToKICAgICIiIkxvYWQgc291cmNlIGZpbGVzIC0gZWl0aGVyIGZyb20gZGVmYXVsdHMgZGlyIG9yIGVtYmVkZGVkIGluIGF0bGFzLnB5LiIiIgogICAgaW1wb3J0IGJhc2U2NAogICAgZmlsZXM6IGRpY3Rbc3RyLCBzdHJdID0ge30KICAgIAogICAgIyBUcnkgbG9hZGluZyBmcm9tIHNyYy8uc3lzdGVtX2RlZmF1bHRzL3NyYy8gZmlyc3QgKGRldmVsb3BtZW50IG1vZGUpCiAgICBzcmNfZGlyID0gU1JDX0RFRkFVTFRTX1JPT1QgLyAic3JjIgogICAgaWYgc3JjX2Rpci5pc19kaXIoKToKICAgICAgICBmb3IgcGF0aCBpbiBzcmNfZGlyLmdsb2IoIioucHkiKToKICAgICAgICAgICAgZmlsZXNbcGF0aC5uYW1lXSA9IHJlYWRfdGV4dChwYXRoKQogICAgCiAgICAjIElmIG5vIGZpbGVzIGZvdW5kLCB0cnkgZW1iZWRkZWQgc291cmNlIChkaXN0cmlidXRpb24gbW9kZSkKICAgIGlmIG5vdCBmaWxlcyBhbmQgRU1CRURERURfU1JDX0I2NCAhPSAiX19FTUJFRERFRF9TUkNfUExBQ0VIT0xERVJfXyI6CiAgICAgICAgdHJ5OgogICAgICAgICAgICBkZWNvZGVkID0gYmFzZTY0LmI2NGRlY29kZShFTUJFRERFRF9TUkNfQjY0KS5kZWNvZGUoInV0Zi04IikKICAgICAgICAgICAgZmlsZXNbImF0bGFzX2NsaS5weSJdID0gZGVjb2RlZAogICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgIHBhc3MKICAgIAogICAgcmV0dXJuIGZpbGVzCgoKZGVmIGxvYWRfdGVtcGxhdGUobmFtZTogc3RyKSAtPiBzdHI6CiAgICB0ZW1wbGF0ZV9wYXRoID0gVEVNUExBVEVTX0RJUiAvIG5hbWUKICAgIGlmIG5vdCB0ZW1wbGF0ZV9wYXRoLmV4aXN0cygpOgogICAgICAgIHJhaXNlIEZpbGVOb3RGb3VuZEVycm9yKGYiTWlzc2luZyB0ZW1wbGF0ZToge3RlbXBsYXRlX3BhdGh9IikKICAgIHJldHVybiByZWFkX3RleHQodGVtcGxhdGVfcGF0aCkKCgpkZWYgaXRlcl9tZF9maWxlcyhkaXJzOiBJdGVyYWJsZVtQYXRoXSkgLT4gbGlzdFtQYXRoXToKICAgIGZpbGVzOiBsaXN0W1BhdGhdID0gW10KICAgIGZvciBiYXNlIGluIGRpcnM6CiAgICAgICAgaWYgbm90IGJhc2UuaXNfZGlyKCk6CiAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgZm9yIHBhdGggaW4gYmFzZS5yZ2xvYigiKi5tZCIpOgogICAgICAgICAgICBmaWxlcy5hcHBlbmQocGF0aCkKICAgIHJldHVybiBmaWxlcwoKCmRlZiBleHRyYWN0X21ldGEodGV4dDogc3RyKSAtPiBkaWN0W3N0ciwgc3RyXToKICAgIG1ldGE6IGRpY3Rbc3RyLCBzdHJdID0ge30KICAgIGhlYWQgPSAiXG4iLmpvaW4odGV4dC5zcGxpdGxpbmVzKClbOjYwXSkKICAgIGZvciBsaW5lIGluIGhlYWQuc3BsaXRsaW5lcygpOgogICAgICAgIG1hdGNoID0gTUVUQV9SRS5tYXRjaChsaW5lLnN0cmlwKCkpCiAgICAgICAgaWYgbWF0Y2g6CiAgICAgICAgICAgIG1ldGFbbWF0Y2guZ3JvdXAoMSkuc3RyaXAoKV0gPSBtYXRjaC5ncm91cCgyKS5zdHJpcCgpCiAgICByZXR1cm4gbWV0YQoKCmRlZiBleHRyYWN0X2hlYWRlcl9pZCh0ZXh0OiBzdHIpIC0+IE9wdGlvbmFsW3N0cl06CiAgICBtYXRjaCA9IEhFQURFUl9JRF9SRS5zZWFyY2godGV4dCkKICAgIHJldHVybiBtYXRjaC5ncm91cCgxKS5zdHJpcCgpIGlmIG1hdGNoIGVsc2UgTm9uZQoKCmRlZiBwYXJzZV9tdXN0X3JlYWQodmFsdWU6IHN0cikgLT4gbGlzdFtzdHJdOgogICAgcmF3ID0gdmFsdWUuc3RyaXAoKQogICAgaWYgcmF3Lmxvd2VyKCkgPT0gIm5vbmUiOgogICAgICAgIHJldHVybiBbXQogICAgdG9rZW5zID0gW3Quc3RyaXAoKSBmb3IgdCBpbiByYXcuc3BsaXQoIiwiKSBpZiB0LnN0cmlwKCldCiAgICBpZHM6IGxpc3Rbc3RyXSA9IFtdCiAgICBmb3IgdG9rZW4gaW4gdG9rZW5zOgogICAgICAgIGlmIHRva2VuLnN0YXJ0c3dpdGgoIlsiKSBhbmQgIl0iIGluIHRva2VuIGFuZCAiKCIgaW4gdG9rZW46CiAgICAgICAgICAgIHRva2VuID0gdG9rZW5bMSA6IHRva2VuLmluZGV4KCJdIildLnN0cmlwKCkKICAgICAgICBpZiB0b2tlbjoKICAgICAgICAgICAgaWRzLmFwcGVuZCh0b2tlbikKICAgIHJldHVybiBpZHMKCgpkZWYgbmV4dF9pZChwcmVmaXg6IHN0ciwgZG9tYWluOiBzdHIsIGRpcl9wYXRoOiBQYXRoLCBwYXR0ZXJuOiByZS5QYXR0ZXJuKSAtPiBzdHI6CiAgICBtYXhfbiA9IDAKICAgIGlmIGRpcl9wYXRoLmV4aXN0cygpOgogICAgICAgIGZvciBwYXRoIGluIGRpcl9wYXRoLmdsb2IoZiJ7cHJlZml4fS17ZG9tYWlufS0qLm1kIik6CiAgICAgICAgICAgIG1hdGNoID0gcGF0dGVybi5tYXRjaChwYXRoLnN0ZW0pCiAgICAgICAgICAgIGlmIG1hdGNoOgogICAgICAgICAgICAgICAgbnVtID0gaW50KG1hdGNoLmdyb3VwKDIpKQogICAgICAgICAgICAgICAgaWYgbnVtID4gbWF4X246CiAgICAgICAgICAgICAgICAgICAgbWF4X24gPSBudW0KICAgIHJldHVybiBmIntwcmVmaXh9LXtkb21haW59LXttYXhfbiArIDE6MDNkfSIKCgpkZWYgdXBkYXRlX21ldGFfbGluZSh0ZXh0OiBzdHIsIGtleTogc3RyLCB2YWx1ZTogc3RyKSAtPiBzdHI6CiAgICBsaW5lcyA9IHRleHQuc3BsaXRsaW5lcygpCiAgICB1cGRhdGVkID0gRmFsc2UKICAgIGZvciBpLCBsaW5lIGluIGVudW1lcmF0ZShsaW5lcyk6CiAgICAgICAgaWYgbGluZS5zdGFydHN3aXRoKCI+ICoqIikgYW5kIGxpbmUuc3BsaXQoIioqIiwgMilbMV0uc3RyaXAoKSA9PSBrZXk6CiAgICAgICAgICAgIGxpbmVzW2ldID0gZiI+ICoqe2tleX0qKjoge3ZhbHVlfSIKICAgICAgICAgICAgdXBkYXRlZCA9IFRydWUKICAgICAgICAgICAgYnJlYWsKICAgIGlmIG5vdCB1cGRhdGVkOgogICAgICAgIGluc2VydF9hdCA9IDEgaWYgbGluZXMgZWxzZSAwCiAgICAgICAgbGluZXMuaW5zZXJ0KGluc2VydF9hdCwgZiI+ICoqe2tleX0qKjoge3ZhbHVlfSIpCiAgICByZXR1cm4gIlxuIi5qb2luKGxpbmVzKSArICJcbiIKCgpkZWYgbm9ybWFsaXplX3N0YXR1cyh2YWx1ZTogc3RyKSAtPiBzdHI6CiAgICByZXR1cm4gdmFsdWUuc3RyaXAoKS5sb3dlcigpCgoKZGVmIHBhcnNlX2NvbXBsZXRlZF9kYXRlKHZhbHVlOiBPcHRpb25hbFtzdHJdKSAtPiBPcHRpb25hbFtkYXRldGltZV06CiAgICBpZiBub3QgdmFsdWU6CiAgICAgICAgcmV0dXJuIE5vbmUKICAgIHJhdyA9IHZhbHVlLnN0cmlwKCkKICAgIGlmIHJhdyA9PSAiLSI6CiAgICAgICAgcmV0dXJuIE5vbmUKICAgIHRyeToKICAgICAgICByZXR1cm4gZGF0ZXRpbWUuc3RycHRpbWUocmF3LCAiJVktJW0tJWQiKQogICAgZXhjZXB0IFZhbHVlRXJyb3I6CiAgICAgICAgcmV0dXJuIE5vbmUKCgpkZWYgcGFyc2VfYWZmZWN0ZWRfYXJ0aWZhY3RzKHRleHQ6IHN0cikgLT4gZGljdFtzdHIsIGxpc3Rbc3RyXV06CiAgICBhcnRpZmFjdHMgPSB7IkNyZWF0ZSI6IFtdLCAiTW9kaWZ5IjogW10sICJSZWFkIjogW119CiAgICBmb3IgbGluZSBpbiB0ZXh0LnNwbGl0bGluZXMoKToKICAgICAgICBsaW5lID0gbGluZS5zdHJpcCgpCiAgICAgICAgZm9yIGtleSBpbiBhcnRpZmFjdHMua2V5cygpOgogICAgICAgICAgICBwcmVmaXggPSBmIi0ge2tleX06IgogICAgICAgICAgICBpZiBsaW5lLnN0YXJ0c3dpdGgocHJlZml4KToKICAgICAgICAgICAgICAgIHJlbWFpbmRlciA9IGxpbmVbbGVuKHByZWZpeCkgOl0uc3RyaXAoKQogICAgICAgICAgICAgICAgaWYgcmVtYWluZGVyOgogICAgICAgICAgICAgICAgICAgIHBhcnRzID0gW3Auc3RyaXAoKSBmb3IgcCBpbiByZW1haW5kZXIuc3BsaXQoIiwiKSBpZiBwLnN0cmlwKCldCiAgICAgICAgICAgICAgICAgICAgYXJ0aWZhY3RzW2tleV0uZXh0ZW5kKHBhcnRzKQogICAgcmV0dXJuIGFydGlmYWN0cwoKCmRlZiB1cGRhdGVfYnJpZWZfc3RhdHVzKGJyaWVmX2lkOiBzdHIsIHN0YXR1czogc3RyKSAtPiBib29sOgogICAgaWYgbm90IEJSSUVGX0lEX1BBVFRFUk4ubWF0Y2goYnJpZWZfaWQpOgogICAgICAgIHByaW50KGYiW1dBUk5dIEludmFsaWQgQlJJRUYgSUQgaW4gUlVOIG1ldGE6IHticmllZl9pZH0iKQogICAgICAgIHJldHVybiBGYWxzZQogICAgYnJpZWZfcGF0aCA9IEJSSUVGX0RJUiAvIGYie2JyaWVmX2lkfS5tZCIKICAgIGlmIG5vdCBicmllZl9wYXRoLmV4aXN0cygpOgogICAgICAgIHByaW50KGYiW1dBUk5dIEJSSUVGIG5vdCBmb3VuZCBmb3IgUlVOOiB7YnJpZWZfcGF0aH0iKQogICAgICAgIHJldHVybiBGYWxzZQogICAgYnJpZWZfdGV4dCA9IHJlYWRfdGV4dChicmllZl9wYXRoKQogICAgYnJpZWZfdGV4dCA9IHVwZGF0ZV9tZXRhX2xpbmUoYnJpZWZfdGV4dCwgIlN0YXR1cyIsIHN0YXR1cykKICAgIHdyaXRlX3RleHQoYnJpZWZfcGF0aCwgYnJpZWZfdGV4dCkKICAgIHByaW50KGYiW09LXSBVcGRhdGVkIHticmllZl9wYXRofSIpCiAgICByZXR1cm4gVHJ1ZQoKCmRlZiBleHRyYWN0X2lkc19mcm9tX3RleHQodGV4dDogc3RyKSAtPiBsaXN0W3N0cl06CiAgICByZXR1cm4gcmUuZmluZGFsbChyIig/OlJFUXxSVUxFfENRfEJSSUVGfFJVTiktW0EtWl0rLVxkezN9KD86LXN0ZXAtXGR7Mn0pPyIsIHRleHQpCgoKZGVmIHdyaXRlX2xhc3RfcnVuKHN0YXRlOiBkaWN0KSAtPiBOb25lOgogICAgZW5zdXJlX2RpcihTVEFURV9ESVIpCiAgICB3cml0ZV90ZXh0KExBU1RfUlVOX1BBVEgsIGpzb24uZHVtcHMoc3RhdGUsIGluZGVudD0yKSArICJcbiIpCgoKIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQojIFN5bmMgdXRpbGl0aWVzCiMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KCmRlZiBwYXJzZV9jaGVja2JveGVzKHRleHQ6IHN0cikgLT4gbGlzdFt0dXBsZVtpbnQsIGJvb2wsIHN0cl1dOgogICAgIiIiUGFyc2UgY2hlY2tib3hlcyBmcm9tIHRleHQuIFJldHVybnMgbGlzdCBvZiAobGluZV9udW0sIGlzX2NoZWNrZWQsIGNvbnRlbnQpLiIiIgogICAgcmVzdWx0cyA9IFtdCiAgICBmb3IgaSwgbGluZSBpbiBlbnVtZXJhdGUodGV4dC5zcGxpdGxpbmVzKCkpOgogICAgICAgIGlmIENIRUNLQk9YX0NIRUNLRUQubWF0Y2gobGluZSk6CiAgICAgICAgICAgIG1hdGNoID0gQ0hFQ0tCT1hfQ0hFQ0tFRC5tYXRjaChsaW5lKQogICAgICAgICAgICByZXN1bHRzLmFwcGVuZCgoaSwgVHJ1ZSwgbWF0Y2guZ3JvdXAoMikuc3RyaXAoKSkpCiAgICAgICAgZWxpZiBDSEVDS0JPWF9VTkNIRUNLRUQubWF0Y2gobGluZSk6CiAgICAgICAgICAgIG1hdGNoID0gQ0hFQ0tCT1hfVU5DSEVDS0VELm1hdGNoKGxpbmUpCiAgICAgICAgICAgIHJlc3VsdHMuYXBwZW5kKChpLCBGYWxzZSwgbWF0Y2guZ3JvdXAoMikuc3RyaXAoKSkpCiAgICByZXR1cm4gcmVzdWx0cwoKCmRlZiBwYXJzZV90cmFjZWFiaWxpdHkodGV4dDogc3RyKSAtPiBkaWN0W3N0ciwgdHVwbGVbc3RyLCBzdHJdXToKICAgICIiIlBhcnNlIHRyYWNlYWJpbGl0eSBsaW5rcy4gUmV0dXJucyB7bGlua190eXBlOiAoaWQsIHBhdGgpfS4iIiIKICAgIHJlc3VsdHMgPSB7fQogICAgZm9yIG1hdGNoIGluIFRSQUNFQUJJTElUWV9MSU5LX1JFLmZpbmRpdGVyKHRleHQpOgogICAgICAgIGxpbmtfaWQgPSBtYXRjaC5ncm91cCgxKS5zdHJpcCgpCiAgICAgICAgbGlua19wYXRoID0gbWF0Y2guZ3JvdXAoMikuc3RyaXAoKQogICAgICAgICMgRGV0ZXJtaW5lIGxpbmsgdHlwZSBmcm9tIGNvbnRleHQKICAgICAgICBmdWxsX21hdGNoID0gbWF0Y2guZ3JvdXAoMCkKICAgICAgICBpZiAiSW1wbGVtZW50cyIgaW4gZnVsbF9tYXRjaDoKICAgICAgICAgICAgcmVzdWx0c1siSW1wbGVtZW50cyJdID0gKGxpbmtfaWQsIGxpbmtfcGF0aCkKICAgICAgICBlbGlmICJBbnN3ZXJzIiBpbiBmdWxsX21hdGNoOgogICAgICAgICAgICByZXN1bHRzWyJBbnN3ZXJzIl0gPSAobGlua19pZCwgbGlua19wYXRoKQogICAgICAgIGVsaWYgIlNvbHZlZCBieSIgaW4gZnVsbF9tYXRjaDoKICAgICAgICAgICAgcmVzdWx0c1siU29sdmVkIGJ5Il0gPSAobGlua19pZCwgbGlua19wYXRoKQogICAgICAgIGVsaWYgIkltcGxlbWVudGVkIGJ5IiBpbiBmdWxsX21hdGNoOgogICAgICAgICAgICByZXN1bHRzWyJJbXBsZW1lbnRlZCBieSJdID0gKGxpbmtfaWQsIGxpbmtfcGF0aCkKICAgIHJldHVybiByZXN1bHRzCgoKZGVmIHJlc29sdmVfbGlua2VkX2RvY3MocnVuX3BhdGg6IFBhdGgpIC0+IGRpY3Rbc3RyLCBQYXRoXToKICAgICIiIlJlc29sdmUgUlVOIC0+IEJSSUVGIC0+IFJFUSBjaGFpbi4gUmV0dXJucyB7ZG9jX3R5cGU6IHBhdGh9LiIiIgogICAgZG9jcyA9IHt9CiAgICB0ZXh0ID0gcmVhZF90ZXh0KHJ1bl9wYXRoKQogICAgbWV0YSA9IGV4dHJhY3RfbWV0YSh0ZXh0KQogICAgCiAgICAjIFJVTiAtPiBCUklFRgogICAgYnJpZWZfaWQgPSBtZXRhLmdldCgiQnJpZWYiKQogICAgaWYgYnJpZWZfaWQgYW5kIEJSSUVGX0lEX1BBVFRFUk4ubWF0Y2goYnJpZWZfaWQpOgogICAgICAgIGJyaWVmX3BhdGggPSBCUklFRl9ESVIgLyBmInticmllZl9pZH0ubWQiCiAgICAgICAgaWYgYnJpZWZfcGF0aC5leGlzdHMoKToKICAgICAgICAgICAgZG9jc1siQlJJRUYiXSA9IGJyaWVmX3BhdGgKICAgICAgICAgICAgCiAgICAgICAgICAgICMgQlJJRUYgLT4gUkVRICh2aWEgSW1wbGVtZW50cyBsaW5rKQogICAgICAgICAgICBicmllZl90ZXh0ID0gcmVhZF90ZXh0KGJyaWVmX3BhdGgpCiAgICAgICAgICAgIHRyYWNlID0gcGFyc2VfdHJhY2VhYmlsaXR5KGJyaWVmX3RleHQpCiAgICAgICAgICAgIGlmICJJbXBsZW1lbnRzIiBpbiB0cmFjZToKICAgICAgICAgICAgICAgIHJlcV9pZCwgcmVxX3JlbF9wYXRoID0gdHJhY2VbIkltcGxlbWVudHMiXQogICAgICAgICAgICAgICAgcmVxX3BhdGggPSAoYnJpZWZfcGF0aC5wYXJlbnQgLyByZXFfcmVsX3BhdGgpLnJlc29sdmUoKQogICAgICAgICAgICAgICAgaWYgcmVxX3BhdGguZXhpc3RzKCk6CiAgICAgICAgICAgICAgICAgICAgZG9jc1siUkVRIl0gPSByZXFfcGF0aAogICAgCiAgICByZXR1cm4gZG9jcwoKCmRlZiBjb21wdXRlX3N0YXR1c19mcm9tX2NoZWNrYm94ZXModGV4dDogc3RyKSAtPiBPcHRpb25hbFtzdHJdOgogICAgIiIiQ29tcHV0ZSBzdGF0dXMgYmFzZWQgb24gY2hlY2tib3ggY29tcGxldGlvbiBpbiBTdGVwcy9WZXJpZmljYXRpb24gc2VjdGlvbnMuIiIiCiAgICBjaGVja2JveGVzID0gcGFyc2VfY2hlY2tib3hlcyh0ZXh0KQogICAgaWYgbm90IGNoZWNrYm94ZXM6CiAgICAgICAgcmV0dXJuIE5vbmUKICAgIAogICAgdG90YWwgPSBsZW4oY2hlY2tib3hlcykKICAgIGNoZWNrZWQgPSBzdW0oMSBmb3IgXywgaXNfY2hlY2tlZCwgXyBpbiBjaGVja2JveGVzIGlmIGlzX2NoZWNrZWQpCiAgICAKICAgIGlmIGNoZWNrZWQgPT0gMDoKICAgICAgICByZXR1cm4gIlBsYW5uZWQiCiAgICBlbGlmIGNoZWNrZWQgPT0gdG90YWw6CiAgICAgICAgcmV0dXJuICJDb21wbGV0ZWQiCiAgICBlbHNlOgogICAgICAgIHJldHVybiAiSW5Qcm9ncmVzcyIKCgpkZWYgZ2VuZXJhdGVfc3luY19kaWZmKHJ1bl9wYXRoOiBQYXRoKSAtPiBkaWN0OgogICAgIiIiR2VuZXJhdGUgZGlmZiBmb3Igc3luYyBvcGVyYXRpb24uIFJldHVybnMgY2hhbmdlcyB0byBhcHBseS4iIiIKICAgIGRpZmYgPSB7CiAgICAgICAgInJ1biI6IHsicGF0aCI6IHJ1bl9wYXRoLCAiY2hhbmdlcyI6IFtdfSwKICAgICAgICAiYnJpZWYiOiBOb25lLAogICAgICAgICJyZXEiOiBOb25lLAogICAgfQogICAgCiAgICBydW5fdGV4dCA9IHJlYWRfdGV4dChydW5fcGF0aCkKICAgIHJ1bl9tZXRhID0gZXh0cmFjdF9tZXRhKHJ1bl90ZXh0KQogICAgcnVuX2NoZWNrYm94ZXMgPSBwYXJzZV9jaGVja2JveGVzKHJ1bl90ZXh0KQogICAgCiAgICAjIENvbXB1dGUgUlVOIHN0YXR1cyBmcm9tIGNoZWNrYm94ZXMKICAgIGNvbXB1dGVkX3N0YXR1cyA9IGNvbXB1dGVfc3RhdHVzX2Zyb21fY2hlY2tib3hlcyhydW5fdGV4dCkKICAgIGN1cnJlbnRfc3RhdHVzID0gcnVuX21ldGEuZ2V0KCJTdGF0dXMiLCAiIikKICAgIAogICAgaWYgY29tcHV0ZWRfc3RhdHVzIGFuZCBub3JtYWxpemVfc3RhdHVzKGNvbXB1dGVkX3N0YXR1cykgIT0gbm9ybWFsaXplX3N0YXR1cyhjdXJyZW50X3N0YXR1cyk6CiAgICAgICAgZGlmZlsicnVuIl1bImNoYW5nZXMiXS5hcHBlbmQoewogICAgICAgICAgICAidHlwZSI6ICJzdGF0dXMiLAogICAgICAgICAgICAiZnJvbSI6IGN1cnJlbnRfc3RhdHVzLAogICAgICAgICAgICAidG8iOiBjb21wdXRlZF9zdGF0dXMsCiAgICAgICAgfSkKICAgIAogICAgIyBSZXNvbHZlIGxpbmtlZCBkb2N1bWVudHMKICAgIGxpbmtlZCA9IHJlc29sdmVfbGlua2VkX2RvY3MocnVuX3BhdGgpCiAgICAKICAgICMgQlJJRUYgc3luYwogICAgaWYgIkJSSUVGIiBpbiBsaW5rZWQ6CiAgICAgICAgYnJpZWZfcGF0aCA9IGxpbmtlZFsiQlJJRUYiXQogICAgICAgIGJyaWVmX3RleHQgPSByZWFkX3RleHQoYnJpZWZfcGF0aCkKICAgICAgICBicmllZl9tZXRhID0gZXh0cmFjdF9tZXRhKGJyaWVmX3RleHQpCiAgICAgICAgYnJpZWZfc3RhdHVzID0gYnJpZWZfbWV0YS5nZXQoIlN0YXR1cyIsICIiKQogICAgICAgIAogICAgICAgIGRpZmZbImJyaWVmIl0gPSB7CiAgICAgICAgICAgICJwYXRoIjogYnJpZWZfcGF0aCwKICAgICAgICAgICAgImNoYW5nZXMiOiBbXSwKICAgICAgICB9CiAgICAgICAgCiAgICAgICAgIyBTeW5jIHN0YXR1cwogICAgICAgIGlmIGNvbXB1dGVkX3N0YXR1cyBhbmQgbm9ybWFsaXplX3N0YXR1cyhicmllZl9zdGF0dXMpICE9IG5vcm1hbGl6ZV9zdGF0dXMoY29tcHV0ZWRfc3RhdHVzKToKICAgICAgICAgICAgZGlmZlsiYnJpZWYiXVsiY2hhbmdlcyJdLmFwcGVuZCh7CiAgICAgICAgICAgICAgICAidHlwZSI6ICJzdGF0dXMiLAogICAgICAgICAgICAgICAgImZyb20iOiBicmllZl9zdGF0dXMsCiAgICAgICAgICAgICAgICAidG8iOiBjb21wdXRlZF9zdGF0dXMsCiAgICAgICAgICAgIH0pCiAgICAKICAgICMgUkVRIHBhdGNoIChkb24ndCBhdXRvLW1vZGlmeSwgZ2VuZXJhdGUgcGF0Y2gpCiAgICBpZiAiUkVRIiBpbiBsaW5rZWQ6CiAgICAgICAgcmVxX3BhdGggPSBsaW5rZWRbIlJFUSJdCiAgICAgICAgcmVxX3RleHQgPSByZWFkX3RleHQocmVxX3BhdGgpCiAgICAgICAgcmVxX21ldGEgPSBleHRyYWN0X21ldGEocmVxX3RleHQpCiAgICAgICAgcmVxX2NoZWNrYm94ZXMgPSBwYXJzZV9jaGVja2JveGVzKHJlcV90ZXh0KQogICAgICAgIAogICAgICAgIGRpZmZbInJlcSJdID0gewogICAgICAgICAgICAicGF0aCI6IHJlcV9wYXRoLAogICAgICAgICAgICAiY2hhbmdlcyI6IFtdLAogICAgICAgICAgICAiY2hlY2tib3hlcyI6IHJlcV9jaGVja2JveGVzLAogICAgICAgIH0KICAgICAgICAKICAgICAgICAjIENoZWNrIGlmIFJFUSBhY2NlcHRhbmNlIGNyaXRlcmlhIHNob3VsZCBiZSB1cGRhdGVkIGJhc2VkIG9uIFJVTiBjb21wbGV0aW9uCiAgICAgICAgaWYgY29tcHV0ZWRfc3RhdHVzID09ICJDb21wbGV0ZWQiIGFuZCByZXFfY2hlY2tib3hlczoKICAgICAgICAgICAgIyBTdWdnZXN0IG1hcmtpbmcgcmVsYXRlZCBjaGVja2JveGVzCiAgICAgICAgICAgIGRpZmZbInJlcSJdWyJjaGFuZ2VzIl0uYXBwZW5kKHsKICAgICAgICAgICAgICAgICJ0eXBlIjogImNoZWNrYm94X3N1Z2dlc3Rpb24iLAogICAgICAgICAgICAgICAgIm1lc3NhZ2UiOiBmIlJVTiBjb21wbGV0ZWQuIENvbnNpZGVyIHVwZGF0aW5nIGFjY2VwdGFuY2UgY3JpdGVyaWEgaW4ge3JlcV9wYXRoLm5hbWV9IiwKICAgICAgICAgICAgfSkKICAgIAogICAgcmV0dXJuIGRpZmYKCgpkZWYgcHJpbnRfc3luY19kaWZmKGRpZmY6IGRpY3QpIC0+IE5vbmU6CiAgICAiIiJQcmludCBzeW5jIGRpZmYgaW4gaHVtYW4tcmVhZGFibGUgZm9ybWF0LiIiIgogICAgcnVuX2luZm8gPSBkaWZmWyJydW4iXQogICAgcHJpbnQoZiJcbltTWU5DXSB7cnVuX2luZm9bJ3BhdGgnXS5zdGVtfSIpCiAgICAKICAgIGlmIHJ1bl9pbmZvWyJjaGFuZ2VzIl06CiAgICAgICAgZm9yIGNoYW5nZSBpbiBydW5faW5mb1siY2hhbmdlcyJdOgogICAgICAgICAgICBpZiBjaGFuZ2VbInR5cGUiXSA9PSAic3RhdHVzIjoKICAgICAgICAgICAgICAgIHByaW50KGYiICDihpIgUlVOOiBTdGF0dXMge2NoYW5nZVsnZnJvbSddfSDihpIge2NoYW5nZVsndG8nXX0iKQogICAgZWxzZToKICAgICAgICBwcmludCgiICDihpIgUlVOOiAobm8gY2hhbmdlcykiKQogICAgCiAgICBpZiBkaWZmWyJicmllZiJdOgogICAgICAgIGJyaWVmX2luZm8gPSBkaWZmWyJicmllZiJdCiAgICAgICAgaWYgYnJpZWZfaW5mb1siY2hhbmdlcyJdOgogICAgICAgICAgICBmb3IgY2hhbmdlIGluIGJyaWVmX2luZm9bImNoYW5nZXMiXToKICAgICAgICAgICAgICAgIGlmIGNoYW5nZVsidHlwZSJdID09ICJzdGF0dXMiOgogICAgICAgICAgICAgICAgICAgIHByaW50KGYiICDihpIgQlJJRUYgKHticmllZl9pbmZvWydwYXRoJ10uc3RlbX0pOiBTdGF0dXMge2NoYW5nZVsnZnJvbSddfSDihpIge2NoYW5nZVsndG8nXX0iKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHByaW50KGYiICDihpIgQlJJRUYgKHticmllZl9pbmZvWydwYXRoJ10uc3RlbX0pOiAobm8gY2hhbmdlcykiKQogICAgCiAgICBpZiBkaWZmWyJyZXEiXToKICAgICAgICByZXFfaW5mbyA9IGRpZmZbInJlcSJdCiAgICAgICAgaWYgcmVxX2luZm9bImNoYW5nZXMiXToKICAgICAgICAgICAgZm9yIGNoYW5nZSBpbiByZXFfaW5mb1siY2hhbmdlcyJdOgogICAgICAgICAgICAgICAgaWYgY2hhbmdlWyJ0eXBlIl0gPT0gImNoZWNrYm94X3N1Z2dlc3Rpb24iOgogICAgICAgICAgICAgICAgICAgIHByaW50KGYiICDihpIgUkVRICh7cmVxX2luZm9bJ3BhdGgnXS5zdGVtfSk6IFtQYXRjaCByZXF1aXJlZF0ge2NoYW5nZVsnbWVzc2FnZSddfSIpCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcHJpbnQoZiIgIOKGkiBSRVEgKHtyZXFfaW5mb1sncGF0aCddLnN0ZW19KTogKG5vIGNoYW5nZXMpIikKCgpkZWYgYXBwbHlfYnJpZWZfY2hhbmdlcyhkaWZmOiBkaWN0KSAtPiBib29sOgogICAgIiIiQXBwbHkgY2hhbmdlcyB0byBCUklFRiBkb2N1bWVudC4iIiIKICAgIGlmIG5vdCBkaWZmWyJicmllZiJdIG9yIG5vdCBkaWZmWyJicmllZiJdWyJjaGFuZ2VzIl06CiAgICAgICAgcmV0dXJuIEZhbHNlCiAgICAKICAgIGJyaWVmX3BhdGggPSBkaWZmWyJicmllZiJdWyJwYXRoIl0KICAgIGJyaWVmX3RleHQgPSByZWFkX3RleHQoYnJpZWZfcGF0aCkKICAgIAogICAgZm9yIGNoYW5nZSBpbiBkaWZmWyJicmllZiJdWyJjaGFuZ2VzIl06CiAgICAgICAgaWYgY2hhbmdlWyJ0eXBlIl0gPT0gInN0YXR1cyI6CiAgICAgICAgICAgIGJyaWVmX3RleHQgPSB1cGRhdGVfbWV0YV9saW5lKGJyaWVmX3RleHQsICJTdGF0dXMiLCBjaGFuZ2VbInRvIl0pCiAgICAKICAgIHdyaXRlX3RleHQoYnJpZWZfcGF0aCwgYnJpZWZfdGV4dCkKICAgIHByaW50KGYiW09LXSBVcGRhdGVkIHticmllZl9wYXRofSIpCiAgICByZXR1cm4gVHJ1ZQoKCmRlZiB3cml0ZV9yZXFfcGF0Y2goZGlmZjogZGljdCkgLT4gT3B0aW9uYWxbUGF0aF06CiAgICAiIiJXcml0ZSBSRVEgcGF0Y2ggZmlsZS4iIiIKICAgIGlmIG5vdCBkaWZmWyJyZXEiXSBvciBub3QgZGlmZlsicmVxIl1bImNoYW5nZXMiXToKICAgICAgICByZXR1cm4gTm9uZQogICAgCiAgICBlbnN1cmVfZGlyKFBBVENIX0RJUikKICAgIHJlcV9wYXRoID0gZGlmZlsicmVxIl1bInBhdGgiXQogICAgcGF0Y2hfcGF0aCA9IFBBVENIX0RJUiAvIGYie3JlcV9wYXRoLnN0ZW19LnBhdGNoLm1kIgogICAgCiAgICBjb250ZW50ID0gZiIiIiMgUGF0Y2ggZm9yIHtyZXFfcGF0aC5zdGVtfQoKPiAqKkdlbmVyYXRlZCoqOiB7bm93X2RhdGUoKX0KPiAqKlNvdXJjZSBSVU4qKjoge2RpZmZbJ3J1biddWydwYXRoJ10uc3RlbX0KCiMjIFN1Z2dlc3RlZCBDaGFuZ2VzCgoiIiIKICAgIGZvciBjaGFuZ2UgaW4gZGlmZlsicmVxIl1bImNoYW5nZXMiXToKICAgICAgICBpZiBjaGFuZ2VbInR5cGUiXSA9PSAiY2hlY2tib3hfc3VnZ2VzdGlvbiI6CiAgICAgICAgICAgIGNvbnRlbnQgKz0gZiItIHtjaGFuZ2VbJ21lc3NhZ2UnXX1cbiIKICAgIAogICAgY29udGVudCArPSBmIiIiCiMjIEhvdyB0byBBcHBseQoKYGBgYmFzaAphdGxhcyBzeW5jIHtkaWZmWydydW4nXVsncGF0aCddLnN0ZW19IC0tYXBwbHktcmVxCmBgYAoKT3IgbWFudWFsbHkgZWRpdDoge3JlcV9wYXRofQoiIiIKICAgIAogICAgd3JpdGVfdGV4dChwYXRjaF9wYXRoLCBjb250ZW50KQogICAgcHJpbnQoZiJbT0tdIENyZWF0ZWQgcGF0Y2g6IHtwYXRjaF9wYXRofSIpCiAgICByZXR1cm4gcGF0Y2hfcGF0aAoKCmRlZiBhcHBseV9yZXFfY2hhbmdlcyhkaWZmOiBkaWN0KSAtPiBib29sOgogICAgIiIiQXBwbHkgY2hhbmdlcyB0byBSRVEgZG9jdW1lbnQgKHdpdGggd2FybmluZykuIiIiCiAgICBpZiBub3QgZGlmZlsicmVxIl0gb3Igbm90IGRpZmZbInJlcSJdWyJjaGFuZ2VzIl06CiAgICAgICAgcmV0dXJuIEZhbHNlCiAgICAKICAgIHByaW50KCJbV0FSTl0gTW9kaWZ5aW5nIFJFUSBkb2N1bWVudCAoYXV0aG9yaXR5IGRvY3VtZW50KSIpCiAgICByZXFfcGF0aCA9IGRpZmZbInJlcSJdWyJwYXRoIl0KICAgIHJlcV90ZXh0ID0gcmVhZF90ZXh0KHJlcV9wYXRoKQogICAgCiAgICAjIEZvciBub3csIGp1c3QgdXBkYXRlIHN0YXR1cyBpZiBSVU4gaXMgY29tcGxldGVkCiAgICBydW5fY2hhbmdlcyA9IGRpZmZbInJ1biJdWyJjaGFuZ2VzIl0KICAgIGZvciBjaGFuZ2UgaW4gcnVuX2NoYW5nZXM6CiAgICAgICAgaWYgY2hhbmdlWyJ0eXBlIl0gPT0gInN0YXR1cyIgYW5kIGNoYW5nZVsidG8iXSA9PSAiQ29tcGxldGVkIjoKICAgICAgICAgICAgcmVxX3RleHQgPSB1cGRhdGVfbWV0YV9saW5lKHJlcV90ZXh0LCAiU3RhdHVzIiwgIkltcGxlbWVudGVkIikKICAgIAogICAgd3JpdGVfdGV4dChyZXFfcGF0aCwgcmVxX3RleHQpCiAgICBwcmludChmIltPS10gVXBkYXRlZCB7cmVxX3BhdGh9IikKICAgIHJldHVybiBUcnVlCgoKZGVmIGluaXRfY29tbWFuZChfYXJnczogYXJncGFyc2UuTmFtZXNwYWNlKSAtPiBpbnQ6CiAgICBvdmVyd3JpdGUgPSBnZXRhdHRyKF9hcmdzLCAib3ZlcndyaXRlIiwgRmFsc2UpCiAgICBlbnN1cmVfZGlyKEFUTEFTX1JPT1QpCiAgICBmb3IgZCBpbiBbUkVRX0RJUiwgUlVMRV9ESVIsIENRX0RJUiwgQlJJRUZfRElSLCBSVU5fRElSLCBJREVBX0RJUiwgVEVNUExBVEVTX0RJUiwgU1RBVEVfRElSLCBTWVNURU1fUk9PVCAvICJwcm9tcHRzIiwgU1lTVEVNX1JPT1QgLyAic3JjIl06CiAgICAgICAgZW5zdXJlX2RpcihkKQoKICAgIGZvciBwYXRoLCBjb250ZW50IGluIGxvYWRfZGVmYXVsdF90b3BfZG9jcygpLml0ZW1zKCk6CiAgICAgICAgaWYgb3ZlcndyaXRlIG9yIG5vdCBwYXRoLmV4aXN0cygpOgogICAgICAgICAgICB3cml0ZV90ZXh0KHBhdGgsIGNvbnRlbnQpCgogICAgZm9yIG5hbWUsIGNvbnRlbnQgaW4gbG9hZF9kZWZhdWx0X3RlbXBsYXRlcygpLml0ZW1zKCk6CiAgICAgICAgdGVtcGxhdGVfcGF0aCA9IFRFTVBMQVRFU19ESVIgLyBuYW1lCiAgICAgICAgaWYgb3ZlcndyaXRlIG9yIG5vdCB0ZW1wbGF0ZV9wYXRoLmV4aXN0cygpOgogICAgICAgICAgICB3cml0ZV90ZXh0KHRlbXBsYXRlX3BhdGgsIGNvbnRlbnQpCgogICAgcHJvbXB0c19kaXIgPSBTWVNURU1fUk9PVCAvICJwcm9tcHRzIgogICAgZm9yIG5hbWUsIGNvbnRlbnQgaW4gbG9hZF9kZWZhdWx0X3Byb21wdHMoKS5pdGVtcygpOgogICAgICAgIHByb21wdF9wYXRoID0gcHJvbXB0c19kaXIgLyBuYW1lCiAgICAgICAgaWYgb3ZlcndyaXRlIG9yIG5vdCBwcm9tcHRfcGF0aC5leGlzdHMoKToKICAgICAgICAgICAgd3JpdGVfdGV4dChwcm9tcHRfcGF0aCwgY29udGVudCkKICAgICAgICAgICAgcHJpbnQoZiJbT0tdIENyZWF0ZWQge3Byb21wdF9wYXRofSIpCgogICAgZm9yIG5hbWUsIGNvbnRlbnQgaW4gbG9hZF9kZWZhdWx0X3N5c3RlbV9maWxlcygpLml0ZW1zKCk6CiAgICAgICAgc3lzdGVtX3BhdGggPSBTWVNURU1fUk9PVCAvIG5hbWUKICAgICAgICBpZiBvdmVyd3JpdGUgb3Igbm90IHN5c3RlbV9wYXRoLmV4aXN0cygpOgogICAgICAgICAgICB3cml0ZV90ZXh0KHN5c3RlbV9wYXRoLCBjb250ZW50KQogICAgICAgICAgICBwcmludChmIltPS10gQ3JlYXRlZCB7c3lzdGVtX3BhdGh9IikKCiAgICBzcmNfZGlyID0gU1lTVEVNX1JPT1QgLyAic3JjIgogICAgZm9yIG5hbWUsIGNvbnRlbnQgaW4gbG9hZF9kZWZhdWx0X3NyY19maWxlcygpLml0ZW1zKCk6CiAgICAgICAgc3JjX3BhdGggPSBzcmNfZGlyIC8gbmFtZQogICAgICAgIGlmIG92ZXJ3cml0ZSBvciBub3Qgc3JjX3BhdGguZXhpc3RzKCk6CiAgICAgICAgICAgIHdyaXRlX3RleHQoc3JjX3BhdGgsIGNvbnRlbnQpCiAgICAgICAgICAgIHByaW50KGYiW09LXSBDcmVhdGVkIHtzcmNfcGF0aH0iKQoKICAgIGlmIG5vdCBMQVNUX1JVTl9QQVRILmV4aXN0cygpOgogICAgICAgIHdyaXRlX2xhc3RfcnVuKHsic3RhZ2UiOiAiaWRsZSIsICJ1cGRhdGVkX2F0Ijogbm93X2lzbygpfSkKCiAgICBwcmludCgiW09LXSBBdGxhcyBzdHJ1Y3R1cmUgaW5pdGlhbGl6ZWQuIikKICAgIHByaW50KCJbSU5GT10gUnVuIHRoZSBwcm9tcHQgaW4gLmF0bGFzLy5zeXN0ZW0vcHJvbXB0cy9vbmJvYXJkaW5nLm1kIHRvIGNvbXBsZXRlIHNldHVwLiIpCiAgICByZXR1cm4gMAoKCmRlZiBpbnRha2VfY29tbWFuZChhcmdzOiBhcmdwYXJzZS5OYW1lc3BhY2UpIC0+IGludDoKICAgIGRvbWFpbiA9IGFyZ3MuZG9tYWluLnVwcGVyKCkKICAgIGJyaWVmX2lkID0gbmV4dF9pZCgiQlJJRUYiLCBkb21haW4sIEJSSUVGX0RJUiwgQlJJRUZfSURfUEFUVEVSTikKCiAgICB0aXRsZV9zcmMgPSAiICIuam9pbihhcmdzLnRleHQuc3RyaXAoKS5zcGxpdGxpbmVzKCkpLnN0cmlwKCkKICAgIHRpdGxlID0gdGl0bGVfc3JjWzo2MF0gKyAoIi4uLiIgaWYgbGVuKHRpdGxlX3NyYykgPiA2MCBlbHNlICIiKQogICAgaWYgbm90IHRpdGxlOgogICAgICAgIHRpdGxlID0gIlVzZXIgUmVxdWVzdCIKCiAgICBjb250ZW50ID0gZiIiIiMgW3ticmllZl9pZH1dIHt0aXRsZX0KCj4gKipJRCoqOiB7YnJpZWZfaWR9Cj4gKipEb21haW4qKjoge2RvbWFpbn0KPiAqKlN0YXR1cyoqOiBBY3RpdmUKPiAqKkRhdGUqKjoge25vd19kYXRlKCl9CgojIyAxLiBVc2VyIFJlcXVlc3QKe2FyZ3MudGV4dC5zdHJpcCgpfQoKIyMgMi4gSW50ZW50IFN1bW1hcnkKLSBHb2FsOiAKLSBQcm9ibGVtOiAKCiMjIDMuIEFmZmVjdGVkIEFydGlmYWN0cwotIENyZWF0ZTogCi0gTW9kaWZ5OiAKLSBSZWFkOiAKCiMjIDQuIFByb3Bvc2VkIENoYW5nZXMKMS4gCjIuIAoKIyMgNS4gVmVyaWZpY2F0aW9uIENyaXRlcmlhCi0gWyBdIAoiIiIKICAgIHBhdGggPSBCUklFRl9ESVIgLyBmInticmllZl9pZH0ubWQiCiAgICB3cml0ZV90ZXh0KHBhdGgsIGNvbnRlbnQpCiAgICBwcmludChmIltPS10gQ3JlYXRlZCB7cGF0aH0iKQogICAgcmV0dXJuIDAKCgpkZWYgY3JlYXRlX3JlcV9zdHViKHJlcV9pZDogc3RyKSAtPiBOb25lOgogICAgcGF0aCA9IFJFUV9ESVIgLyBmIntyZXFfaWR9Lm1kIgogICAgaWYgcGF0aC5leGlzdHMoKToKICAgICAgICByZXR1cm4KICAgIG1hdGNoID0gUkVRX0lEX1BBVFRFUk4ubWF0Y2gocmVxX2lkKQogICAgaWYgbm90IG1hdGNoOgogICAgICAgIHJldHVybgogICAgZG9tYWluID0gbWF0Y2guZ3JvdXAoMSkKICAgIHRlbXBsYXRlID0gbG9hZF90ZW1wbGF0ZSgiUkVRLm1kIikKICAgIGNvbnRlbnQgPSAoCiAgICAgICAgdGVtcGxhdGUucmVwbGFjZSgiUkVRLVhYWC0wMDEiLCByZXFfaWQpCiAgICAgICAgLnJlcGxhY2UoIkRvbWFpbioqOiBYWFgiLCBmIkRvbWFpbioqOiB7ZG9tYWlufSIpCiAgICAgICAgLnJlcGxhY2UoIkxhc3QgVXBkYXRlZCoqOiBZWVlZLU1NLUREIiwgZiJMYXN0IFVwZGF0ZWQqKjoge25vd19kYXRlKCl9IikKICAgICkKICAgIHdyaXRlX3RleHQocGF0aCwgY29udGVudCkKCgpkZWYgcGxhbl9jb21tYW5kKGFyZ3M6IGFyZ3BhcnNlLk5hbWVzcGFjZSkgLT4gaW50OgogICAgYnJpZWZfaWQgPSBhcmdzLmJyaWVmX2lkCiAgICBpZiBicmllZl9pZC5lbmRzd2l0aCgiLm1kIik6CiAgICAgICAgYnJpZWZfaWQgPSBQYXRoKGJyaWVmX2lkKS5zdGVtCgogICAgbWF0Y2ggPSBCUklFRl9JRF9QQVRURVJOLm1hdGNoKGJyaWVmX2lkKQogICAgaWYgbm90IG1hdGNoOgogICAgICAgIHByaW50KGYiW0VSUl0gSW52YWxpZCBCUklFRiBJRDoge2JyaWVmX2lkfSIpCiAgICAgICAgcmV0dXJuIDEKCiAgICBicmllZl9wYXRoID0gQlJJRUZfRElSIC8gZiJ7YnJpZWZfaWR9Lm1kIgogICAgaWYgbm90IGJyaWVmX3BhdGguZXhpc3RzKCk6CiAgICAgICAgcHJpbnQoZiJbRVJSXSBCUklFRiBub3QgZm91bmQ6IHticmllZl9wYXRofSIpCiAgICAgICAgcmV0dXJuIDEKCiAgICBkb21haW4gPSBtYXRjaC5ncm91cCgxKQogICAgbnVtYmVyID0gbWF0Y2guZ3JvdXAoMikKICAgIHJ1bl9pZCA9IGYiUlVOLUJSSUVGLXtkb21haW59LXtudW1iZXJ9LXN0ZXAtMDEiCiAgICBydW5fcGF0aCA9IFJVTl9ESVIgLyBmIntydW5faWR9Lm1kIgogICAgaWYgcnVuX3BhdGguZXhpc3RzKCk6CiAgICAgICAgcHJpbnQoZiJbRVJSXSBSVU4gYWxyZWFkeSBleGlzdHM6IHtydW5fcGF0aH0iKQogICAgICAgIHJldHVybiAxCgogICAgYnJpZWZfdGV4dCA9IHJlYWRfdGV4dChicmllZl9wYXRoKQogICAgYXJ0aWZhY3RzID0gcGFyc2VfYWZmZWN0ZWRfYXJ0aWZhY3RzKGJyaWVmX3RleHQpCiAgICByZXFfaWRzID0gWwogICAgICAgIHJpZAogICAgICAgIGZvciByaWQgaW4gZXh0cmFjdF9pZHNfZnJvbV90ZXh0KCIgIi5qb2luKGFydGlmYWN0c1siQ3JlYXRlIl0gKyBhcnRpZmFjdHNbIk1vZGlmeSJdKSkKICAgICAgICBpZiByaWQuc3RhcnRzd2l0aCgiUkVRLSIpCiAgICBdCiAgICBmb3IgcmVxX2lkIGluIHJlcV9pZHM6CiAgICAgICAgY3JlYXRlX3JlcV9zdHViKHJlcV9pZCkKCiAgICBpbnB1dF9saW5lcyA9IFtmIi0ge2JyaWVmX2lkfSJdCiAgICBmb3IgcmVxX2lkIGluIHJlcV9pZHM6CiAgICAgICAgaW5wdXRfbGluZXMuYXBwZW5kKGYiLSB7cmVxX2lkfSIpCgogICAgY29udGVudCA9IGYiIiIjIFt7cnVuX2lkfV0gUGxhbgoKPiAqKklEKio6IHtydW5faWR9Cj4gKipCcmllZioqOiB7YnJpZWZfaWR9Cj4gKipTdGF0dXMqKjogUGxhbm5lZAo+ICoqU3RhcnRlZCoqOiB7bm93X2RhdGUoKX0KPiAqKkdpdCoqOiAtCj4gKipDb21wbGV0ZWQqKjogLQoKIyMgSW5wdXQKe29zLmxpbmVzZXAuam9pbihpbnB1dF9saW5lcyl9CgojIyBTdGVwcwotIFsgXSAKCiMjIFZlcmlmaWNhdGlvbgotIFsgXSBUZXN0Ci0gWyBdIFNwZWMKLSBbIF0gQm91bmRhcnkKCiMjIE91dHB1dAotIChmaWxlcyBjcmVhdGVkL21vZGlmaWVkKQoiIiIKICAgIHdyaXRlX3RleHQocnVuX3BhdGgsIGNvbnRlbnQpCgogICAgd3JpdGVfbGFzdF9ydW4oCiAgICAgICAgewogICAgICAgICAgICAicnVuX2lkIjogcnVuX2lkLAogICAgICAgICAgICAiYnJpZWZfaWQiOiBicmllZl9pZCwKICAgICAgICAgICAgInN0YWdlIjogImV4ZWN1dGluZyIsCiAgICAgICAgICAgICJ1cGRhdGVkX2F0Ijogbm93X2lzbygpLAogICAgICAgIH0KICAgICkKCiAgICBwcmludChmIltPS10gQ3JlYXRlZCB7cnVuX3BhdGh9IikKICAgIHJldHVybiAwCgoKZGVmIGZpbmlzaF9jb21tYW5kKGFyZ3M6IGFyZ3BhcnNlLk5hbWVzcGFjZSkgLT4gaW50OgogICAgcnVuX2lkID0gYXJncy5ydW5faWQKICAgIGlmIHJ1bl9pZC5lbmRzd2l0aCgiLm1kIik6CiAgICAgICAgcnVuX2lkID0gUGF0aChydW5faWQpLnN0ZW0KCiAgICBpZiBub3QgUlVOX0lEX1BBVFRFUk4ubWF0Y2gocnVuX2lkKToKICAgICAgICBwcmludChmIltFUlJdIEludmFsaWQgUlVOIElEOiB7cnVuX2lkfSIpCiAgICAgICAgcmV0dXJuIDEKCiAgICBydW5fcGF0aCA9IFJVTl9ESVIgLyBmIntydW5faWR9Lm1kIgogICAgaWYgbm90IHJ1bl9wYXRoLmV4aXN0cygpOgogICAgICAgIHByaW50KGYiW0VSUl0gUlVOIG5vdCBmb3VuZDoge3J1bl9wYXRofSIpCiAgICAgICAgcmV0dXJuIDEKCiAgICB0ZXh0ID0gcmVhZF90ZXh0KHJ1bl9wYXRoKQogICAgbWV0YSA9IGV4dHJhY3RfbWV0YSh0ZXh0KQogICAgYnJpZWZfaWQgPSBtZXRhLmdldCgiQnJpZWYiKQogICAgc3RhdHVzID0gIkNvbXBsZXRlZCIgaWYgYXJncy5zdWNjZXNzIGVsc2UgIkZhaWxlZCIKICAgIHRleHQgPSB1cGRhdGVfbWV0YV9saW5lKHRleHQsICJTdGF0dXMiLCBzdGF0dXMpCiAgICB0ZXh0ID0gdXBkYXRlX21ldGFfbGluZSh0ZXh0LCAiR2l0IiwgYXJncy5naXQpCiAgICB0ZXh0ID0gdXBkYXRlX21ldGFfbGluZSh0ZXh0LCAiQ29tcGxldGVkIiwgbm93X2RhdGUoKSkKICAgIHdyaXRlX3RleHQocnVuX3BhdGgsIHRleHQpCgogICAgaWYgYnJpZWZfaWQ6CiAgICAgICAgdXBkYXRlX2JyaWVmX3N0YXR1cyhicmllZl9pZCwgc3RhdHVzKQoKICAgIGxhc3RfcnVuX3N0YXRlID0gewogICAgICAgICJydW5faWQiOiBydW5faWQsCiAgICAgICAgInN0YWdlIjogImZpbmlzaGVkIiwKICAgICAgICAiZ2l0X2hhc2giOiBhcmdzLmdpdCwKICAgICAgICAiY29tcGxldGVkX2F0Ijogbm93X2lzbygpLAogICAgfQogICAgaWYgYnJpZWZfaWQ6CiAgICAgICAgbGFzdF9ydW5fc3RhdGVbImJyaWVmX2lkIl0gPSBicmllZl9pZAogICAgd3JpdGVfbGFzdF9ydW4obGFzdF9ydW5fc3RhdGUpCgogICAgcHJpbnQoZiJbT0tdIFVwZGF0ZWQge3J1bl9wYXRofSIpCiAgICByZXR1cm4gMAoKCmRlZiBzeW5jX2NvbW1hbmQoYXJnczogYXJncGFyc2UuTmFtZXNwYWNlKSAtPiBpbnQ6CiAgICAiIiJTeW5jIFJVTiBzdGF0dXMgdG8gQlJJRUYvUkVRIGRvY3VtZW50cy4iIiIKICAgIHJ1bl9pZCA9IGFyZ3MucnVuX2lkCiAgICBpZiBydW5faWQuZW5kc3dpdGgoIi5tZCIpOgogICAgICAgIHJ1bl9pZCA9IFBhdGgocnVuX2lkKS5zdGVtCgogICAgaWYgbm90IFJVTl9JRF9QQVRURVJOLm1hdGNoKHJ1bl9pZCk6CiAgICAgICAgcHJpbnQoZiJbRVJSXSBJbnZhbGlkIFJVTiBJRDoge3J1bl9pZH0iKQogICAgICAgIHJldHVybiAxCgogICAgcnVuX3BhdGggPSBSVU5fRElSIC8gZiJ7cnVuX2lkfS5tZCIKICAgIGlmIG5vdCBydW5fcGF0aC5leGlzdHMoKToKICAgICAgICBwcmludChmIltFUlJdIFJVTiBub3QgZm91bmQ6IHtydW5fcGF0aH0iKQogICAgICAgIHJldHVybiAxCgogICAgIyBHZW5lcmF0ZSBkaWZmCiAgICBkaWZmID0gZ2VuZXJhdGVfc3luY19kaWZmKHJ1bl9wYXRoKQogICAgCiAgICAjIEFsd2F5cyBwcmludCBkaWZmIChkcnktcnVuIGluZm8pCiAgICBwcmludF9zeW5jX2RpZmYoZGlmZikKICAgIAogICAgIyBDaGVjayBpZiBhbnkgYXBwbHkgZmxhZ3MgYXJlIHNldAogICAgYXBwbHlfYnJpZWYgPSBnZXRhdHRyKGFyZ3MsICJhcHBseV9icmllZiIsIEZhbHNlKQogICAgYXBwbHlfcmVxID0gZ2V0YXR0cihhcmdzLCAiYXBwbHlfcmVxIiwgRmFsc2UpCiAgICB3cml0ZV9wYXRjaCA9IGdldGF0dHIoYXJncywgIndyaXRlX3JlcV9wYXRjaCIsIEZhbHNlKQogICAgCiAgICBpZiBub3QgKGFwcGx5X2JyaWVmIG9yIGFwcGx5X3JlcSBvciB3cml0ZV9wYXRjaCk6CiAgICAgICAgcHJpbnQoIlxuW0lORk9dIERyeS1ydW4gbW9kZS4gVXNlIC0tYXBwbHktYnJpZWYsIC0td3JpdGUtcmVxLXBhdGNoLCBvciAtLWFwcGx5LXJlcSB0byBtYWtlIGNoYW5nZXMuIikKICAgICAgICByZXR1cm4gMAogICAgCiAgICAjIEFwcGx5IFJVTiBjaGFuZ2VzIChhbHdheXMgd2hlbiBhbnkgYXBwbHkgZmxhZyBpcyBzZXQpCiAgICBpZiBkaWZmWyJydW4iXVsiY2hhbmdlcyJdOgogICAgICAgIHJ1bl90ZXh0ID0gcmVhZF90ZXh0KHJ1bl9wYXRoKQogICAgICAgIGZvciBjaGFuZ2UgaW4gZGlmZlsicnVuIl1bImNoYW5nZXMiXToKICAgICAgICAgICAgaWYgY2hhbmdlWyJ0eXBlIl0gPT0gInN0YXR1cyI6CiAgICAgICAgICAgICAgICBydW5fdGV4dCA9IHVwZGF0ZV9tZXRhX2xpbmUocnVuX3RleHQsICJTdGF0dXMiLCBjaGFuZ2VbInRvIl0pCiAgICAgICAgd3JpdGVfdGV4dChydW5fcGF0aCwgcnVuX3RleHQpCiAgICAgICAgcHJpbnQoZiJbT0tdIFVwZGF0ZWQge3J1bl9wYXRofSIpCiAgICAKICAgICMgQXBwbHkgQlJJRUYgY2hhbmdlcwogICAgaWYgYXBwbHlfYnJpZWY6CiAgICAgICAgYXBwbHlfYnJpZWZfY2hhbmdlcyhkaWZmKQogICAgCiAgICAjIFdyaXRlIFJFUSBwYXRjaAogICAgaWYgd3JpdGVfcGF0Y2g6CiAgICAgICAgd3JpdGVfcmVxX3BhdGNoKGRpZmYpCiAgICAKICAgICMgQXBwbHkgUkVRIGNoYW5nZXMgKHdpdGggd2FybmluZykKICAgIGlmIGFwcGx5X3JlcToKICAgICAgICBhcHBseV9yZXFfY2hhbmdlcyhkaWZmKQogICAgCiAgICByZXR1cm4gMAoKCmRlZiBpdGVyX2xpbmtzKHRleHQ6IHN0cikgLT4gbGlzdFtzdHJdOgogICAgbGlua3MgPSBbXQogICAgaW5fY29kZSA9IEZhbHNlCiAgICBmb3IgbGluZSBpbiB0ZXh0LnNwbGl0bGluZXMoKToKICAgICAgICBzdHJpcHBlZCA9IGxpbmUuc3RyaXAoKQogICAgICAgIGlmIHN0cmlwcGVkLnN0YXJ0c3dpdGgoImBgYCIpOgogICAgICAgICAgICBpbl9jb2RlID0gbm90IGluX2NvZGUKICAgICAgICAgICAgY29udGludWUKICAgICAgICBpZiBpbl9jb2RlOgogICAgICAgICAgICBjb250aW51ZQogICAgICAgIGZvciBtYXRjaCBpbiBMSU5LX1JFLmZpbmRpdGVyKGxpbmUpOgogICAgICAgICAgICBsaW5rcy5hcHBlbmQobWF0Y2guZ3JvdXAoMSkuc3RyaXAoKSkKICAgIHJldHVybiBsaW5rcwoKCmRlZiBkb2N0b3JfY29tbWFuZChhcmdzOiBhcmdwYXJzZS5OYW1lc3BhY2UpIC0+IGludDoKICAgIGlzc3VlcyA9IDAKICAgIGJyaWVmX3N0YXR1c2VzOiBkaWN0W3N0ciwgc3RyXSA9IHt9CiAgICBydW5fYnJpZWZfc3RhdHVzZXM6IGxpc3RbdHVwbGVbc3RyLCBzdHIsIHN0ciwgT3B0aW9uYWxbZGF0ZXRpbWVdXV0gPSBbXQoKICAgIHJlcXVpcmVkX2RpcnMgPSBbUkVRX0RJUiwgUlVMRV9ESVIsIENRX0RJUiwgQlJJRUZfRElSLCBSVU5fRElSLCBTWVNURU1fUk9PVCwgVEVNUExBVEVTX0RJUiwgU1RBVEVfRElSXQogICAgZm9yIHBhdGggaW4gcmVxdWlyZWRfZGlyczoKICAgICAgICBpZiBub3QgcGF0aC5leGlzdHMoKToKICAgICAgICAgICAgcHJpbnQoZiJbRVJSXSBNaXNzaW5nIGRpcmVjdG9yeToge3BhdGh9IikKICAgICAgICAgICAgaXNzdWVzICs9IDEKCiAgICBmb3IgcGF0aCBpbiBSRVFVSVJFRF9UT1BfRE9DUzoKICAgICAgICBpZiBub3QgcGF0aC5leGlzdHMoKToKICAgICAgICAgICAgcHJpbnQoZiJbRVJSXSBNaXNzaW5nIHRvcCBkb2M6IHtwYXRofSIpCiAgICAgICAgICAgIGlzc3VlcyArPSAxCgogICAgZm9yIHBhdGggaW4gT1BUSU9OQUxfVE9QX0RPQ1M6CiAgICAgICAgaWYgbm90IHBhdGguZXhpc3RzKCk6CiAgICAgICAgICAgIHByaW50KGYiW1dBUk5dIE1pc3Npbmcgb3B0aW9uYWwgZG9jOiB7cGF0aH0iKQoKICAgIHNjYW5fZGlycyA9IFtSRVFfRElSLCBSVUxFX0RJUiwgQ1FfRElSLCBCUklFRl9ESVIsIFJVTl9ESVJdCiAgICBhbGxfZG9jcyA9IGl0ZXJfbWRfZmlsZXMoc2Nhbl9kaXJzKQogICAgYWxsX2lkczogc2V0W3N0cl0gPSBzZXQoKQoKICAgIGZvciBwYXRoIGluIGFsbF9kb2NzOgogICAgICAgIHRleHQgPSByZWFkX3RleHQocGF0aCkKICAgICAgICBtZXRhID0gZXh0cmFjdF9tZXRhKHRleHQpCiAgICAgICAgbWV0YV9pZCA9IG1ldGEuZ2V0KCJJRCIpCiAgICAgICAgaGVhZGVyX2lkID0gZXh0cmFjdF9oZWFkZXJfaWQodGV4dCkKICAgICAgICBmaWxlX2lkID0gcGF0aC5zdGVtCiAgICAgICAgZm9yIGNhbmRpZGF0ZSBpbiBbbWV0YV9pZCwgaGVhZGVyX2lkLCBmaWxlX2lkXToKICAgICAgICAgICAgaWYgY2FuZGlkYXRlOgogICAgICAgICAgICAgICAgYWxsX2lkcy5hZGQoY2FuZGlkYXRlKQoKICAgIGZvciBwYXRoIGluIGFsbF9kb2NzOgogICAgICAgIHRleHQgPSByZWFkX3RleHQocGF0aCkKICAgICAgICBtZXRhID0gZXh0cmFjdF9tZXRhKHRleHQpCiAgICAgICAgbWV0YV9pZCA9IG1ldGEuZ2V0KCJJRCIpCiAgICAgICAgaGVhZGVyX2lkID0gZXh0cmFjdF9oZWFkZXJfaWQodGV4dCkKICAgICAgICBmaWxlX2lkID0gcGF0aC5zdGVtCgogICAgICAgIGZvbGRlciA9IHBhdGgucGFyZW50Lm5hbWUKICAgICAgICBleHBlY3RlZF9wcmVmaXggPSB7CiAgICAgICAgICAgICJyZXEiOiAiUkVRIiwKICAgICAgICAgICAgInJ1bGUiOiAiUlVMRSIsCiAgICAgICAgICAgICJjcSI6ICJDUSIsCiAgICAgICAgICAgICJicmllZiI6ICJCUklFRiIsCiAgICAgICAgICAgICJydW5zIjogIlJVTiIsCiAgICAgICAgfS5nZXQoZm9sZGVyKQoKICAgICAgICBpZiBleHBlY3RlZF9wcmVmaXggaXMgTm9uZToKICAgICAgICAgICAgY29udGludWUKCiAgICAgICAgaWYgZXhwZWN0ZWRfcHJlZml4ID09ICJCUklFRiI6CiAgICAgICAgICAgIHN0YXR1cyA9IG1ldGEuZ2V0KCJTdGF0dXMiKQogICAgICAgICAgICBpZiBub3Qgc3RhdHVzOgogICAgICAgICAgICAgICAgcHJpbnQoZiJbRVJSXSBNaXNzaW5nIFN0YXR1czoge3BhdGh9IikKICAgICAgICAgICAgICAgIGlzc3VlcyArPSAxCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBicmllZl9zdGF0dXNlc1tmaWxlX2lkXSA9IHN0YXR1cwoKICAgICAgICBpZiBleHBlY3RlZF9wcmVmaXggPT0gIlJVTiI6CiAgICAgICAgICAgIGJyaWVmX2lkID0gbWV0YS5nZXQoIkJyaWVmIikKICAgICAgICAgICAgcnVuX3N0YXR1cyA9IG1ldGEuZ2V0KCJTdGF0dXMiKQogICAgICAgICAgICBjb21wbGV0ZWQgPSBtZXRhLmdldCgiQ29tcGxldGVkIikKICAgICAgICAgICAgaWYgYnJpZWZfaWQgYW5kIHJ1bl9zdGF0dXM6CiAgICAgICAgICAgICAgICBydW5fYnJpZWZfc3RhdHVzZXMuYXBwZW5kKAogICAgICAgICAgICAgICAgICAgIChmaWxlX2lkLCBicmllZl9pZCwgcnVuX3N0YXR1cywgcGFyc2VfY29tcGxldGVkX2RhdGUoY29tcGxldGVkKSkKICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgaWYgZmlsZV9pZC5zdGFydHN3aXRoKCJSVU4tQlJJRUYtIikgYW5kIG5vdCBicmllZl9pZDoKICAgICAgICAgICAgICAgIHByaW50KGYiW1dBUk5dIE1pc3NpbmcgQnJpZWYgcmVmZXJlbmNlOiB7cGF0aH0iKQogICAgICAgICAgICAgICAgaXNzdWVzICs9IDEKCiAgICAgICAgaWYgbm90IG1ldGFfaWQ6CiAgICAgICAgICAgIHByaW50KGYiW0VSUl0gTWlzc2luZyBtZXRhIElEOiB7cGF0aH0iKQogICAgICAgICAgICBpc3N1ZXMgKz0gMQogICAgICAgIGlmIG5vdCBoZWFkZXJfaWQ6CiAgICAgICAgICAgIHByaW50KGYiW0VSUl0gTWlzc2luZyBoZWFkZXIgSUQ6IHtwYXRofSIpCiAgICAgICAgICAgIGlzc3VlcyArPSAxCgogICAgICAgIHBhdHRlcm4gPSB7CiAgICAgICAgICAgICJSRVEiOiBSRVFfSURfUEFUVEVSTiwKICAgICAgICAgICAgIlJVTEUiOiBSVUxFX0lEX1BBVFRFUk4sCiAgICAgICAgICAgICJDUSI6IENRX0lEX1BBVFRFUk4sCiAgICAgICAgICAgICJCUklFRiI6IEJSSUVGX0lEX1BBVFRFUk4sCiAgICAgICAgICAgICJSVU4iOiBSVU5fSURfUEFUVEVSTiwKICAgICAgICB9W2V4cGVjdGVkX3ByZWZpeF0KCiAgICAgICAgaWYgbm90IHBhdHRlcm4ubWF0Y2goZmlsZV9pZCk6CiAgICAgICAgICAgIHByaW50KGYiW0VSUl0gSW52YWxpZCBmaWxlbmFtZSBmb3Ige2V4cGVjdGVkX3ByZWZpeH06IHtwYXRofSIpCiAgICAgICAgICAgIGlzc3VlcyArPSAxCgogICAgICAgIGlmIG1ldGFfaWQgYW5kIG1ldGFfaWQgIT0gZmlsZV9pZDoKICAgICAgICAgICAgcHJpbnQoZiJbRVJSXSBNZXRhIElEIG1pc21hdGNoOiB7cGF0aH0iKQogICAgICAgICAgICBpc3N1ZXMgKz0gMQogICAgICAgIGlmIGhlYWRlcl9pZCBhbmQgaGVhZGVyX2lkICE9IGZpbGVfaWQ6CiAgICAgICAgICAgIHByaW50KGYiW0VSUl0gSGVhZGVyIElEIG1pc21hdGNoOiB7cGF0aH0iKQogICAgICAgICAgICBpc3N1ZXMgKz0gMQoKICAgICAgICBpZiBleHBlY3RlZF9wcmVmaXggaW4geyJSRVEiLCAiUlVMRSJ9OgogICAgICAgICAgICBtdXN0X3JlYWQgPSBtZXRhLmdldCgiTXVzdC1SZWFkIikKICAgICAgICAgICAgaWYgbXVzdF9yZWFkIGlzIE5vbmU6CiAgICAgICAgICAgICAgICBwcmludChmIltFUlJdIE1pc3NpbmcgTXVzdC1SZWFkOiB7cGF0aH0iKQogICAgICAgICAgICAgICAgaXNzdWVzICs9IDEKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIGlkcyA9IHBhcnNlX211c3RfcmVhZChtdXN0X3JlYWQpCiAgICAgICAgICAgICAgICBpZiBub3QgaWRzIGFuZCBtdXN0X3JlYWQuc3RyaXAoKS5sb3dlcigpICE9ICJub25lIjoKICAgICAgICAgICAgICAgICAgICBwcmludChmIltFUlJdIEVtcHR5IE11c3QtUmVhZDoge3BhdGh9IikKICAgICAgICAgICAgICAgICAgICBpc3N1ZXMgKz0gMQogICAgICAgICAgICAgICAgZm9yIHJlZl9pZCBpbiBpZHM6CiAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gcmVmX2lkLnNwbGl0KCItIiwgMSlbMF0KICAgICAgICAgICAgICAgICAgICBpZiBwcmVmaXggbm90IGluIEFMTE9XRURfTVVTVF9SRUFEX1BSRUZJWEVTOgogICAgICAgICAgICAgICAgICAgICAgICBwcmludChmIltFUlJdIE11c3QtUmVhZCBkaXNhbGxvd2VkIElEOiB7cGF0aH0gLT4ge3JlZl9pZH0iKQogICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXMgKz0gMQogICAgICAgICAgICAgICAgICAgIGlmIHJlZl9pZCBub3QgaW4gYWxsX2lkczoKICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQoZiJbRVJSXSBNdXN0LVJlYWQgbWlzc2luZyB0YXJnZXQ6IHtwYXRofSAtPiB7cmVmX2lkfSIpCiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlcyArPSAxCgogICAgICAgIGlmIGFyZ3MubGlua3M6CiAgICAgICAgICAgIGZvciB0YXJnZXQgaW4gaXRlcl9saW5rcyh0ZXh0KToKICAgICAgICAgICAgICAgIGlmIG5vdCB0YXJnZXQgb3IgdGFyZ2V0LnN0YXJ0c3dpdGgoIiMiKToKICAgICAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICAgICAgaWYgcmUubWF0Y2gociJeW2EtekEtWl1bYS16QS1aMC05Ky4tXSo6IiwgdGFyZ2V0KToKICAgICAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSAocGF0aC5wYXJlbnQgLyB0YXJnZXQpLnJlc29sdmUoKQogICAgICAgICAgICAgICAgaWYgbm90IHJlc29sdmVkLmV4aXN0cygpOgogICAgICAgICAgICAgICAgICAgIHByaW50KGYiW0VSUl0gQnJva2VuIGxpbms6IHtwYXRofSAtPiB7dGFyZ2V0fSIpCiAgICAgICAgICAgICAgICAgICAgaXNzdWVzICs9IDEKCiAgICBsYXRlc3RfcnVuX2J5X2JyaWVmOiBkaWN0W3N0ciwgdHVwbGVbc3RyLCBzdHIsIE9wdGlvbmFsW2RhdGV0aW1lXV1dID0ge30KICAgIGZvciBydW5faWQsIGJyaWVmX2lkLCBydW5fc3RhdHVzLCBjb21wbGV0ZWRfYXQgaW4gcnVuX2JyaWVmX3N0YXR1c2VzOgogICAgICAgIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVfc3RhdHVzKHJ1bl9zdGF0dXMpCiAgICAgICAgaWYgbm9ybWFsaXplZCBub3QgaW4geyJjb21wbGV0ZWQiLCAiZmFpbGVkIn06CiAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgZXhpc3RpbmcgPSBsYXRlc3RfcnVuX2J5X2JyaWVmLmdldChicmllZl9pZCkKICAgICAgICBpZiBleGlzdGluZyBpcyBOb25lOgogICAgICAgICAgICBsYXRlc3RfcnVuX2J5X2JyaWVmW2JyaWVmX2lkXSA9IChydW5faWQsIHJ1bl9zdGF0dXMsIGNvbXBsZXRlZF9hdCkKICAgICAgICAgICAgY29udGludWUKICAgICAgICBleGlzdGluZ19ydW5faWQsIF8sIGV4aXN0aW5nX2NvbXBsZXRlZCA9IGV4aXN0aW5nCiAgICAgICAgaWYgY29tcGxldGVkX2F0IGFuZCAoZXhpc3RpbmdfY29tcGxldGVkIGlzIE5vbmUgb3IgY29tcGxldGVkX2F0ID4gZXhpc3RpbmdfY29tcGxldGVkKToKICAgICAgICAgICAgbGF0ZXN0X3J1bl9ieV9icmllZlticmllZl9pZF0gPSAocnVuX2lkLCBydW5fc3RhdHVzLCBjb21wbGV0ZWRfYXQpCiAgICAgICAgZWxpZiBjb21wbGV0ZWRfYXQgaXMgTm9uZSBhbmQgZXhpc3RpbmdfY29tcGxldGVkIGlzIE5vbmUgYW5kIHJ1bl9pZCA+IGV4aXN0aW5nX3J1bl9pZDoKICAgICAgICAgICAgbGF0ZXN0X3J1bl9ieV9icmllZlticmllZl9pZF0gPSAocnVuX2lkLCBydW5fc3RhdHVzLCBjb21wbGV0ZWRfYXQpCgogICAgZm9yIGJyaWVmX2lkLCAocnVuX2lkLCBydW5fc3RhdHVzLCBfKSBpbiBsYXRlc3RfcnVuX2J5X2JyaWVmLml0ZW1zKCk6CiAgICAgICAgYnJpZWZfc3RhdHVzID0gYnJpZWZfc3RhdHVzZXMuZ2V0KGJyaWVmX2lkKQogICAgICAgIGlmIG5vdCBicmllZl9zdGF0dXM6CiAgICAgICAgICAgIHByaW50KGYiW1dBUk5dIEJSSUVGIG1pc3NpbmcgZm9yIFJVTjoge3J1bl9pZH0gLT4ge2JyaWVmX2lkfSIpCiAgICAgICAgICAgIGlzc3VlcyArPSAxCiAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgaWYgbm9ybWFsaXplX3N0YXR1cyhicmllZl9zdGF0dXMpICE9IG5vcm1hbGl6ZV9zdGF0dXMocnVuX3N0YXR1cyk6CiAgICAgICAgICAgIHByaW50KAogICAgICAgICAgICAgICAgZiJbV0FSTl0gQlJJRUYgc3RhdHVzIG1pc21hdGNoOiB7YnJpZWZfaWR9IGlzIHticmllZl9zdGF0dXN9LCBsYXRlc3QgUlVOIHtydW5faWR9IGlzIHtydW5fc3RhdHVzfSIKICAgICAgICAgICAgKQogICAgICAgICAgICBpc3N1ZXMgKz0gMQoKICAgIGlmIExBU1RfUlVOX1BBVEguZXhpc3RzKCk6CiAgICAgICAgdHJ5OgogICAgICAgICAgICBzdGF0ZSA9IGpzb24ubG9hZHMocmVhZF90ZXh0KExBU1RfUlVOX1BBVEgpKQogICAgICAgIGV4Y2VwdCBqc29uLkpTT05EZWNvZGVFcnJvcjoKICAgICAgICAgICAgc3RhdGUgPSB7fQogICAgICAgICAgICBwcmludChmIltFUlJdIEludmFsaWQgSlNPTjoge0xBU1RfUlVOX1BBVEh9IikKICAgICAgICAgICAgaXNzdWVzICs9IDEKICAgICAgICBzdGFnZSA9IHN0YXRlLmdldCgic3RhZ2UiKQogICAgICAgIHVwZGF0ZWRfYXQgPSBzdGF0ZS5nZXQoInVwZGF0ZWRfYXQiKSBvciBzdGF0ZS5nZXQoImNvbXBsZXRlZF9hdCIpCiAgICAgICAgaWYgc3RhZ2UgPT0gImV4ZWN1dGluZyIgYW5kIHVwZGF0ZWRfYXQ6CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIHRzID0gZGF0ZXRpbWUuZnJvbWlzb2Zvcm1hdCh1cGRhdGVkX2F0KQogICAgICAgICAgICAgICAgaWYgZGF0ZXRpbWUubm93KCkgLSB0cyA+IHRpbWVkZWx0YShob3Vycz1hcmdzLm1heF9hZ2VfaG91cnMpOgogICAgICAgICAgICAgICAgICAgIHByaW50KAogICAgICAgICAgICAgICAgICAgICAgICBmIltXQVJOXSBSVU4gbWF5IGJlIHVuZmluaXNoZWQgKD57YXJncy5tYXhfYWdlX2hvdXJzfWgpOiB7c3RhdGUuZ2V0KCdydW5faWQnKX0iCiAgICAgICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgICAgIGlzc3VlcyArPSAxCiAgICAgICAgICAgIGV4Y2VwdCBWYWx1ZUVycm9yOgogICAgICAgICAgICAgICAgcHJpbnQoIltFUlJdIEludmFsaWQgdGltZXN0YW1wIGluIGxhc3RfcnVuLmpzb24iKQogICAgICAgICAgICAgICAgaXNzdWVzICs9IDEKCiAgICBwcmludChmIltET05FXSBEb2N0b3IgY29tcGxldGVkIHdpdGgge2lzc3Vlc30gaXNzdWUocykuIikKICAgIHJldHVybiAwIGlmIGlzc3VlcyA9PSAwIGVsc2UgMQoKCmRlZiBidWlsZF9wYXJzZXIoKSAtPiBhcmdwYXJzZS5Bcmd1bWVudFBhcnNlcjoKICAgIHBhcnNlciA9IGFyZ3BhcnNlLkFyZ3VtZW50UGFyc2VyKHByb2c9ImF0bGFzIikKICAgIHBhcnNlci5hZGRfYXJndW1lbnQoCiAgICAgICAgIi0tdmVyc2lvbiIsICItdiIsCiAgICAgICAgYWN0aW9uPSJ2ZXJzaW9uIiwKICAgICAgICB2ZXJzaW9uPWYiQXRsYXMge2dldF92ZXJzaW9uKCl9IgogICAgKQogICAgc3ViID0gcGFyc2VyLmFkZF9zdWJwYXJzZXJzKGRlc3Q9ImNvbW1hbmQiLCByZXF1aXJlZD1GYWxzZSkKCiAgICBpbml0ID0gc3ViLmFkZF9wYXJzZXIoImluaXQiKQogICAgaW5pdC5hZGRfYXJndW1lbnQoIi0tb3ZlcndyaXRlIiwgYWN0aW9uPSJzdG9yZV90cnVlIikKCiAgICBpbnRha2UgPSBzdWIuYWRkX3BhcnNlcigiaW50YWtlIikKICAgIGludGFrZS5hZGRfYXJndW1lbnQoInRleHQiKQogICAgaW50YWtlLmFkZF9hcmd1bWVudCgiLS1kb21haW4iLCBkZWZhdWx0PSJHRU4iKQoKICAgIHBsYW4gPSBzdWIuYWRkX3BhcnNlcigicGxhbiIpCiAgICBwbGFuLmFkZF9hcmd1bWVudCgiYnJpZWZfaWQiKQoKICAgIGZpbmlzaCA9IHN1Yi5hZGRfcGFyc2VyKCJmaW5pc2giKQogICAgZmluaXNoLmFkZF9hcmd1bWVudCgicnVuX2lkIikKICAgIGZpbmlzaC5hZGRfYXJndW1lbnQoIi0tZ2l0IiwgcmVxdWlyZWQ9VHJ1ZSkKICAgIGZpbmlzaC5hZGRfYXJndW1lbnQoIi0tc3VjY2VzcyIsIHR5cGU9bGFtYmRhIHY6IHYubG93ZXIoKSA9PSAidHJ1ZSIsIHJlcXVpcmVkPVRydWUpCgogICAgZG9jdG9yID0gc3ViLmFkZF9wYXJzZXIoImRvY3RvciIpCiAgICBkb2N0b3IuYWRkX2FyZ3VtZW50KCItLWxpbmtzIiwgYWN0aW9uPSJzdG9yZV90cnVlIikKICAgIGRvY3Rvci5hZGRfYXJndW1lbnQoIi0tbWF4LWFnZS1ob3VycyIsIHR5cGU9aW50LCBkZWZhdWx0PTI0KQoKICAgIHN5bmMgPSBzdWIuYWRkX3BhcnNlcigic3luYyIsIGhlbHA9IlN5bmMgUlVOIHN0YXR1cyB0byBCUklFRi9SRVEgZG9jdW1lbnRzIikKICAgIHN5bmMuYWRkX2FyZ3VtZW50KCJydW5faWQiLCBoZWxwPSJSVU4gZG9jdW1lbnQgSUQiKQogICAgc3luYy5hZGRfYXJndW1lbnQoIi0tYXBwbHktYnJpZWYiLCBhY3Rpb249InN0b3JlX3RydWUiLCBoZWxwPSJBcHBseSBjaGFuZ2VzIHRvIEJSSUVGIGRvY3VtZW50IikKICAgIHN5bmMuYWRkX2FyZ3VtZW50KCItLXdyaXRlLXJlcS1wYXRjaCIsIGFjdGlvbj0ic3RvcmVfdHJ1ZSIsIGhlbHA9IldyaXRlIFJFUSBwYXRjaCBmaWxlIikKICAgIHN5bmMuYWRkX2FyZ3VtZW50KCItLWFwcGx5LXJlcSIsIGFjdGlvbj0ic3RvcmVfdHJ1ZSIsIGhlbHA9IkFwcGx5IGNoYW5nZXMgdG8gUkVRIGRvY3VtZW50IChjYXV0aW9uKSIpCgogICAgcmV0dXJuIHBhcnNlcgoKCmRlZiBtYWluKGFyZ3Y6IE9wdGlvbmFsW2xpc3Rbc3RyXV0gPSBOb25lKSAtPiBpbnQ6CiAgICBwYXJzZXIgPSBidWlsZF9wYXJzZXIoKQogICAgYXJncyA9IHBhcnNlci5wYXJzZV9hcmdzKGFyZ3YpCgogICAgaWYgbm90IGFyZ3MuY29tbWFuZDoKICAgICAgICBwYXJzZXIucHJpbnRfaGVscCgpCiAgICAgICAgcmV0dXJuIDAKCiAgICBpZiBhcmdzLmNvbW1hbmQgIT0gImluaXQiIGFuZCBub3QgQVRMQVNfUk9PVC5leGlzdHMoKToKICAgICAgICBwcmludCgiW0lORk9dIC5hdGxhcyBub3QgZm91bmQuIEluaXRpYWxpemluZy4uLiIpCiAgICAgICAgaW5pdF9jb21tYW5kKGFyZ3MpCgogICAgaWYgYXJncy5jb21tYW5kID09ICJpbml0IjoKICAgICAgICByZXR1cm4gaW5pdF9jb21tYW5kKGFyZ3MpCiAgICBpZiBhcmdzLmNvbW1hbmQgPT0gImludGFrZSI6CiAgICAgICAgcmV0dXJuIGludGFrZV9jb21tYW5kKGFyZ3MpCiAgICBpZiBhcmdzLmNvbW1hbmQgPT0gInBsYW4iOgogICAgICAgIHJldHVybiBwbGFuX2NvbW1hbmQoYXJncykKICAgIGlmIGFyZ3MuY29tbWFuZCA9PSAiZmluaXNoIjoKICAgICAgICByZXR1cm4gZmluaXNoX2NvbW1hbmQoYXJncykKICAgIGlmIGFyZ3MuY29tbWFuZCA9PSAiZG9jdG9yIjoKICAgICAgICByZXR1cm4gZG9jdG9yX2NvbW1hbmQoYXJncykKICAgIGlmIGFyZ3MuY29tbWFuZCA9PSAic3luYyI6CiAgICAgICAgcmV0dXJuIHN5bmNfY29tbWFuZChhcmdzKQoKICAgIHBhcnNlci5wcmludF9oZWxwKCkKICAgIHJldHVybiAxCgoKaWYgX19uYW1lX18gPT0gIl9fbWFpbl9fIjoKICAgIHJhaXNlIFN5c3RlbUV4aXQobWFpbigpKQo="
    
    # Checkbox patterns
    CHECKBOX_UNCHECKED = re.compile(r"^(\s*)-\s*\[\s*\](.*)$")
    CHECKBOX_CHECKED = re.compile(r"^(\s*)-\s*\[x\](.*)$", re.IGNORECASE)
    TRACEABILITY_LINK_RE = re.compile(r"\*\*(?:Implements|Answers|Solved by|Implemented by)\*\*:\s*\[([^\]]+)\]\(([^)]+)\)")
    
    DEFAULT_TOP_DOCS = {
        ATLAS_ROOT / "FRONT.md": """# Atlas\n\nThis repo uses Atlas vNext.\nUse: `python atlas.py init`\n\nQuick flow:\n1) `python atlas.py intake \"...\" --domain GEN`\n2) `python atlas.py plan BRIEF-GEN-001`\n3) `python atlas.py finish RUN-BRIEF-GEN-001-step-01 --git <hash|no-commit> --success true`\n\nLinks: BOARD.md, CONVENTIONS.md, GOALS.md\n""",
        ATLAS_ROOT / "BOARD.md": """# BOARD\n\n>    **   ** .\n>   ,      .\n\n## Queue\n- (empty)\n\n## Active\n- (empty)\n\n## Done\n- (empty)\n\n> Last Reviewed: YYYY-MM-DD\n""",
        ATLAS_ROOT / "CONVENTIONS.md": """# CONVENTIONS\n\n## Boundaries\n\n### Always\n- Keep REQ/RULE/CQ as authority; do not auto-edit without intent.\n- Record verification steps in RUN.\n\n### Ask First\n- Add or remove dependencies.\n- Change storage layout under `.atlas/`.\n\n### Never\n- Hardcode secrets.\n- Modify existing REQ/RULE/CQ silently.\n\n## Roles (one-line)\n- REQ: what the system must do.\n- RULE: constraints that must always hold.\n- CQ: questions the system must answer.\n- BRIEF: intake summary.\n- RUN: execution plan and evidence.\n\n## Verification\n- `python atlas.py doctor`\n- (project tests as defined)\n""",
        ATLAS_ROOT / "GOALS.md": """# GOALS\n\n- Purpose: (fill in)\n- In scope: (fill in)\n- Out of scope: (fill in)\n""",
    }
    
    DEFAULT_TEMPLATES = {
        "REQ.md": """# [REQ-XXX-001] Title\n\n> **ID**: REQ-XXX-001\n> **Domain**: XXX\n> **Status**: Draft\n> **Last Updated**: YYYY-MM-DD\n> **Must-Read**: RULE-XXX-001\n\n---\n\n## Decision\n- (what must be true)\n\n## Input\n- (inputs)\n\n## Output\n- (outputs)\n\n## Acceptance Criteria\n- [ ] (criteria)\n""",
        "RULE.md": """# [RULE-XXX-001] Title\n\n> **ID**: RULE-XXX-001\n> **Domain**: XXX\n> **Priority**: Medium\n> **Last Updated**: YYYY-MM-DD\n> **Must-Read**: RULE-XXX-001\n\n---\n\n## Rule Statement\n- (always true / forbidden)\n\n## Scope\n- (where it applies)\n\n## Violation\n- (what counts as a violation)\n\n## Examples\n\n### Correct\n- (example)\n\n### Incorrect\n- (example)\n""",
        "CQ.md": """# [CQ-XXX-001] Title\n\n> **ID**: CQ-XXX-001\n> **Domain**: XXX\n> **Status**: Draft\n> **Last Updated**: YYYY-MM-DD\n\n---\n\n## Question\n- (what must the system answer?)\n\n## Expected Answer (Criteria)\n1. ...\n2. ...\n\n## Traceability\n- **Solves by**: [REQ-XXX-001](../req/REQ-XXX-001.md)\n- **Constrained by**: [RULE-XXX-001](../rule/RULE-XXX-001.md)\n""",
        "BRIEF.md": """# [BRIEF-XXX-001] Title\n\n> **ID**: BRIEF-XXX-001\n> **Domain**: XXX\n> **Status**: Active\n> **Date**: YYYY-MM-DD\n\n## 1. User Request\n- (raw text)\n\n## 2. Intent Summary\n- Goal:\n- Problem:\n\n## 3. Affected Artifacts\n- Create: \n- Modify: \n- Read: \n\n## 4. Proposed Changes\n1. \n2. \n\n## 5. Verification Criteria\n- [ ] \n""",
        "RUN.md": """# [RUN-BRIEF-XXX-001-step-01] Title\n\n> **ID**: RUN-BRIEF-XXX-001-step-01\n> **Brief**: BRIEF-XXX-001\n> **Status**: Planned\n> **Started**: YYYY-MM-DD\n> **Git**: -\n> **Completed**: -\n\n## Input\n- (documents to read)\n\n## Steps\n- [ ] \n\n## Verification\n- [ ] Test\n- [ ] Spec\n- [ ] Boundary\n\n## Output\n- (files created/modified)\n""",
    }
    
    DEFAULT_PROMPTS = {
        "onboarding.md": """# Atlas Audit Prompt
    
    > **Note**:  `Onboarding Prompt` **`Audit Prompt`** .
    >        ,     **(Consistency) (Audit)**  .
    
    ---
    
    ## Prompt
    
    ```
       **  (Auditor)**.
      Atlas (.atlas/   GOALS, CONVENTIONS, BOARD, FRONT)    (,  ,   )     .
    
    ### [Strict Rules]  
    1. **READ-ONLY**: ,          .
    2. **  (Suggestion Only)**:    "  "   .
    3. ** **:    , "    ?"   .
    
    ### [Checklist]  
    
    LLM        :
    
    #### 1. GOALS.md ( )
    - **Active Task  **:     GOALS     ?
    - **Scope Creep **:     In-Scope   ?     ?
    
    #### 2. CONVENTIONS.md ( )
    - **  **:       (Always, Never)   ?
    - ** **:   (: "  ")      ?
    
    #### 3. BOARD.md ( )
    - **Active  **: Active      ? (GOALS    Active ?)
    - **Queue  **: Queue     ,  GOALS   ?
    
    #### 4. FRONT.md ( )
    - **  **:        ?
    - ** **:          ?
    
    ---
    
    ### [Audit Report]  
    
            .
    
    - [PASS] ** (Pass)**
    - [WARN] ** (Warning)**:    .
    - [FAIL] **/ (Fail)**:  ,   .
    
    **[ ]**
    
    ### 1. GOALS.md
    - [PASS]    .
    - [WARN] ****: ' '   (Task-102)  , GOALS Scope  .  .
    
    ### 2. CONVENTIONS.md
    - [FAIL] ****:  'Type Hint '  ,  `utils.py`      .
        - ****:  ,     .
    
    ( BOARD, FRONT  )
    ```
    
    ---
    
    ## How to execute
      (    ) LLM      .
    """,
    }
    
    
    def get_version() -> str:
        """Read version from VERSION file (SSOT)."""
        if VERSION_PATH.exists():
            return VERSION_PATH.read_text(encoding="utf-8").strip()
        return "unknown"
    
    
    def now_date() -> str:
        return datetime.now().strftime("%Y-%m-%d")
    
    
    def now_iso() -> str:
        return datetime.now().isoformat(timespec="seconds")
    
    
    def ensure_dir(path: Path) -> None:
        path.mkdir(parents=True, exist_ok=True)
    
    
    def read_text(path: Path) -> str:
        return path.read_text(encoding="utf-8")
    
    
    def write_text(path: Path, content: str) -> None:
        path.write_text(content, encoding="utf-8")
    
    
    def load_default_top_docs() -> dict[Path, str]:
        docs = dict(DEFAULT_TOP_DOCS)
        if SRC_DEFAULT_TOP_DOCS_DIR.is_dir():
            for path in sorted(SRC_DEFAULT_TOP_DOCS_DIR.glob("*.md")):
                target = ATLAS_ROOT / path.name
                if target in docs:
                    docs[target] = read_text(path)
        return docs
    
    
    def load_default_templates() -> dict[str, str]:
        templates = dict(DEFAULT_TEMPLATES)
        if SRC_DEFAULT_TEMPLATES_DIR.is_dir():
            for name in DEFAULT_TEMPLATES:
                src_path = SRC_DEFAULT_TEMPLATES_DIR / name
                if src_path.exists():
                    templates[name] = read_text(src_path)
        return templates
    
    
    def load_default_prompts() -> dict[str, str]:
        prompts = dict(DEFAULT_PROMPTS)
        if SRC_DEFAULT_PROMPTS_DIR.is_dir():
            for name in DEFAULT_PROMPTS:
                src_path = SRC_DEFAULT_PROMPTS_DIR / name
                if src_path.exists():
                    prompts[name] = read_text(src_path)
        return prompts
    
    
    def load_default_system_files() -> dict[str, str]:
        """Load VERSION and VERSIONING.md from src/.system_defaults/."""
        files: dict[str, str] = {}
        for name in ["VERSION", "VERSIONING.md"]:
            src_path = SRC_DEFAULTS_ROOT / name
            if src_path.exists():
                files[name] = read_text(src_path)
        return files
    
    
    def load_default_src_files() -> dict[str, str]:
        """Load source files - either from defaults dir or embedded in atlas.py."""
        import base64
        files: dict[str, str] = {}
        
        # Try loading from src/.system_defaults/src/ first (development mode)
        src_dir = SRC_DEFAULTS_ROOT / "src"
        if src_dir.is_dir():
            for path in src_dir.glob("*.py"):
                files[path.name] = read_text(path)
        
        # If no files found, try embedded source (distribution mode)
        if not files and EMBEDDED_SRC_B64 != "__EMBEDDED_SRC_PLACEHOLDER__":
            try:
                decoded = base64.b64decode(EMBEDDED_SRC_B64).decode("utf-8")
                files["atlas_cli.py"] = decoded
            except Exception:
                pass
        
        return files
    
    
    def load_template(name: str) -> str:
        template_path = TEMPLATES_DIR / name
        if not template_path.exists():
            raise FileNotFoundError(f"Missing template: {template_path}")
        return read_text(template_path)
    
    
    def iter_md_files(dirs: Iterable[Path]) -> list[Path]:
        files: list[Path] = []
        for base in dirs:
            if not base.is_dir():
                continue
            for path in base.rglob("*.md"):
                files.append(path)
        return files
    
    
    def extract_meta(text: str) -> dict[str, str]:
        meta: dict[str, str] = {}
        head = "\n".join(text.splitlines()[:60])
        for line in head.splitlines():
            match = META_RE.match(line.strip())
            if match:
                meta[match.group(1).strip()] = match.group(2).strip()
        return meta
    
    
    def extract_header_id(text: str) -> Optional[str]:
        match = HEADER_ID_RE.search(text)
        return match.group(1).strip() if match else None
    
    
    def parse_must_read(value: str) -> list[str]:
        raw = value.strip()
        if raw.lower() == "none":
            return []
        tokens = [t.strip() for t in raw.split(",") if t.strip()]
        ids: list[str] = []
        for token in tokens:
            if token.startswith("[") and "]" in token and "(" in token:
                token = token[1 : token.index("]")].strip()
            if token:
                ids.append(token)
        return ids
    
    
    def next_id(prefix: str, domain: str, dir_path: Path, pattern: re.Pattern) -> str:
        max_n = 0
        if dir_path.exists():
            for path in dir_path.glob(f"{prefix}-{domain}-*.md"):
                match = pattern.match(path.stem)
                if match:
                    num = int(match.group(2))
                    if num > max_n:
                        max_n = num
        return f"{prefix}-{domain}-{max_n + 1:03d}"
    
    
    def update_meta_line(text: str, key: str, value: str) -> str:
        lines = text.splitlines()
        updated = False
        for i, line in enumerate(lines):
            if line.startswith("> **") and line.split("**", 2)[1].strip() == key:
                lines[i] = f"> **{key}**: {value}"
                updated = True
                break
        if not updated:
            insert_at = 1 if lines else 0
            lines.insert(insert_at, f"> **{key}**: {value}")
        return "\n".join(lines) + "\n"
    
    
    def normalize_status(value: str) -> str:
        return value.strip().lower()
    
    
    def parse_completed_date(value: Optional[str]) -> Optional[datetime]:
        if not value:
            return None
        raw = value.strip()
        if raw == "-":
            return None
        try:
            return datetime.strptime(raw, "%Y-%m-%d")
        except ValueError:
            return None
    
    
    def parse_affected_artifacts(text: str) -> dict[str, list[str]]:
        artifacts = {"Create": [], "Modify": [], "Read": []}
        for line in text.splitlines():
            line = line.strip()
            for key in artifacts.keys():
                prefix = f"- {key}:"
                if line.startswith(prefix):
                    remainder = line[len(prefix) :].strip()
                    if remainder:
                        parts = [p.strip() for p in remainder.split(",") if p.strip()]
                        artifacts[key].extend(parts)
        return artifacts
    
    
    def update_brief_status(brief_id: str, status: str) -> bool:
        if not BRIEF_ID_PATTERN.match(brief_id):
            print(f"[WARN] Invalid BRIEF ID in RUN meta: {brief_id}")
            return False
        brief_path = BRIEF_DIR / f"{brief_id}.md"
        if not brief_path.exists():
            print(f"[WARN] BRIEF not found for RUN: {brief_path}")
            return False
        brief_text = read_text(brief_path)
        brief_text = update_meta_line(brief_text, "Status", status)
        write_text(brief_path, brief_text)
        print(f"[OK] Updated {brief_path}")
        return True
    
    
    def extract_ids_from_text(text: str) -> list[str]:
        return re.findall(r"(?:REQ|RULE|CQ|BRIEF|RUN)-[A-Z]+-\d{3}(?:-step-\d{2})?", text)
    
    
    def write_last_run(state: dict) -> None:
        ensure_dir(STATE_DIR)
        write_text(LAST_RUN_PATH, json.dumps(state, indent=2) + "\n")
    
    
    # =============================================================================
    # Sync utilities
    # =============================================================================
    
    def parse_checkboxes(text: str) -> list[tuple[int, bool, str]]:
        """Parse checkboxes from text. Returns list of (line_num, is_checked, content)."""
        results = []
        for i, line in enumerate(text.splitlines()):
            if CHECKBOX_CHECKED.match(line):
                match = CHECKBOX_CHECKED.match(line)
                results.append((i, True, match.group(2).strip()))
            elif CHECKBOX_UNCHECKED.match(line):
                match = CHECKBOX_UNCHECKED.match(line)
                results.append((i, False, match.group(2).strip()))
        return results
    
    
    def parse_traceability(text: str) -> dict[str, tuple[str, str]]:
        """Parse traceability links. Returns {link_type: (id, path)}."""
        results = {}
        for match in TRACEABILITY_LINK_RE.finditer(text):
            link_id = match.group(1).strip()
            link_path = match.group(2).strip()
            # Determine link type from context
            full_match = match.group(0)
            if "Implements" in full_match:
                results["Implements"] = (link_id, link_path)
            elif "Answers" in full_match:
                results["Answers"] = (link_id, link_path)
            elif "Solved by" in full_match:
                results["Solved by"] = (link_id, link_path)
            elif "Implemented by" in full_match:
                results["Implemented by"] = (link_id, link_path)
        return results
    
    
    def resolve_linked_docs(run_path: Path) -> dict[str, Path]:
        """Resolve RUN -> BRIEF -> REQ chain. Returns {doc_type: path}."""
        docs = {}
        text = read_text(run_path)
        meta = extract_meta(text)
        
        # RUN -> BRIEF
        brief_id = meta.get("Brief")
        if brief_id and BRIEF_ID_PATTERN.match(brief_id):
            brief_path = BRIEF_DIR / f"{brief_id}.md"
            if brief_path.exists():
                docs["BRIEF"] = brief_path
                
                # BRIEF -> REQ (via Implements link)
                brief_text = read_text(brief_path)
                trace = parse_traceability(brief_text)
                if "Implements" in trace:
                    req_id, req_rel_path = trace["Implements"]
                    req_path = (brief_path.parent / req_rel_path).resolve()
                    if req_path.exists():
                        docs["REQ"] = req_path
        
        return docs
    
    
    def compute_status_from_checkboxes(text: str) -> Optional[str]:
        """Compute status based on checkbox completion in Steps/Verification sections."""
        checkboxes = parse_checkboxes(text)
        if not checkboxes:
            return None
        
        total = len(checkboxes)
        checked = sum(1 for _, is_checked, _ in checkboxes if is_checked)
        
        if checked == 0:
            return "Planned"
        elif checked == total:
            return "Completed"
        else:
            return "InProgress"
    
    
    def generate_sync_diff(run_path: Path) -> dict:
        """Generate diff for sync operation. Returns changes to apply."""
        diff = {
            "run": {"path": run_path, "changes": []},
            "brief": None,
            "req": None,
        }
        
        run_text = read_text(run_path)
        run_meta = extract_meta(run_text)
        run_checkboxes = parse_checkboxes(run_text)
        
        # Compute RUN status from checkboxes
        computed_status = compute_status_from_checkboxes(run_text)
        current_status = run_meta.get("Status", "")
        
        if computed_status and normalize_status(computed_status) != normalize_status(current_status):
            diff["run"]["changes"].append({
                "type": "status",
                "from": current_status,
                "to": computed_status,
            })
        
        # Resolve linked documents
        linked = resolve_linked_docs(run_path)
        
        # BRIEF sync
        if "BRIEF" in linked:
            brief_path = linked["BRIEF"]
            brief_text = read_text(brief_path)
            brief_meta = extract_meta(brief_text)
            brief_status = brief_meta.get("Status", "")
            
            diff["brief"] = {
                "path": brief_path,
                "changes": [],
            }
            
            # Sync status
            if computed_status and normalize_status(brief_status) != normalize_status(computed_status):
                diff["brief"]["changes"].append({
                    "type": "status",
                    "from": brief_status,
                    "to": computed_status,
                })
        
        # REQ patch (don't auto-modify, generate patch)
        if "REQ" in linked:
            req_path = linked["REQ"]
            req_text = read_text(req_path)
            req_meta = extract_meta(req_text)
            req_checkboxes = parse_checkboxes(req_text)
            
            diff["req"] = {
                "path": req_path,
                "changes": [],
                "checkboxes": req_checkboxes,
            }
            
            # Check if REQ acceptance criteria should be updated based on RUN completion
            if computed_status == "Completed" and req_checkboxes:
                # Suggest marking related checkboxes
                diff["req"]["changes"].append({
                    "type": "checkbox_suggestion",
                    "message": f"RUN completed. Consider updating acceptance criteria in {req_path.name}",
                })
        
        return diff
    
    
    def print_sync_diff(diff: dict) -> None:
        """Print sync diff in human-readable format."""
        run_info = diff["run"]
        print(f"\n[SYNC] {run_info['path'].stem}")
        
        if run_info["changes"]:
            for change in run_info["changes"]:
                if change["type"] == "status":
                    print(f"   RUN: Status {change['from']}  {change['to']}")
        else:
            print("   RUN: (no changes)")
        
        if diff["brief"]:
            brief_info = diff["brief"]
            if brief_info["changes"]:
                for change in brief_info["changes"]:
                    if change["type"] == "status":
                        print(f"   BRIEF ({brief_info['path'].stem}): Status {change['from']}  {change['to']}")
            else:
                print(f"   BRIEF ({brief_info['path'].stem}): (no changes)")
        
        if diff["req"]:
            req_info = diff["req"]
            if req_info["changes"]:
                for change in req_info["changes"]:
                    if change["type"] == "checkbox_suggestion":
                        print(f"   REQ ({req_info['path'].stem}): [Patch required] {change['message']}")
            else:
                print(f"   REQ ({req_info['path'].stem}): (no changes)")
    
    
    def apply_brief_changes(diff: dict) -> bool:
        """Apply changes to BRIEF document."""
        if not diff["brief"] or not diff["brief"]["changes"]:
            return False
        
        brief_path = diff["brief"]["path"]
        brief_text = read_text(brief_path)
        
        for change in diff["brief"]["changes"]:
            if change["type"] == "status":
                brief_text = update_meta_line(brief_text, "Status", change["to"])
        
        write_text(brief_path, brief_text)
        print(f"[OK] Updated {brief_path}")
        return True
    
    
    def write_req_patch(diff: dict) -> Optional[Path]:
        """Write REQ patch file."""
        if not diff["req"] or not diff["req"]["changes"]:
            return None
        
        ensure_dir(PATCH_DIR)
        req_path = diff["req"]["path"]
        patch_path = PATCH_DIR / f"{req_path.stem}.patch.md"
        
        content = f"""# Patch for {req_path.stem}
    
    > **Generated**: {now_date()}
    > **Source RUN**: {diff['run']['path'].stem}
    
    ## Suggested Changes
    
    """
        for change in diff["req"]["changes"]:
            if change["type"] == "checkbox_suggestion":
                content += f"- {change['message']}\n"
        
        content += f"""
    ## How to Apply
    
    ```bash
    atlas sync {diff['run']['path'].stem} --apply-req
    ```
    
    Or manually edit: {req_path}
    """
        
        write_text(patch_path, content)
        print(f"[OK] Created patch: {patch_path}")
        return patch_path
    
    
    def apply_req_changes(diff: dict) -> bool:
        """Apply changes to REQ document (with warning)."""
        if not diff["req"] or not diff["req"]["changes"]:
            return False
        
        print("[WARN] Modifying REQ document (authority document)")
        req_path = diff["req"]["path"]
        req_text = read_text(req_path)
        
        # For now, just update status if RUN is completed
        run_changes = diff["run"]["changes"]
        for change in run_changes:
            if change["type"] == "status" and change["to"] == "Completed":
                req_text = update_meta_line(req_text, "Status", "Implemented")
        
        write_text(req_path, req_text)
        print(f"[OK] Updated {req_path}")
        return True
    
    
    def init_command(_args: argparse.Namespace) -> int:
        overwrite = getattr(_args, "overwrite", False)
        ensure_dir(ATLAS_ROOT)
        for d in [REQ_DIR, RULE_DIR, CQ_DIR, BRIEF_DIR, RUN_DIR, IDEA_DIR, TEMPLATES_DIR, STATE_DIR, SYSTEM_ROOT / "prompts", SYSTEM_ROOT / "src"]:
            ensure_dir(d)
    
        for path, content in load_default_top_docs().items():
            if overwrite or not path.exists():
                write_text(path, content)
    
        for name, content in load_default_templates().items():
            template_path = TEMPLATES_DIR / name
            if overwrite or not template_path.exists():
                write_text(template_path, content)
    
        prompts_dir = SYSTEM_ROOT / "prompts"
        for name, content in load_default_prompts().items():
            prompt_path = prompts_dir / name
            if overwrite or not prompt_path.exists():
                write_text(prompt_path, content)
                print(f"[OK] Created {prompt_path}")
    
        for name, content in load_default_system_files().items():
            system_path = SYSTEM_ROOT / name
            if overwrite or not system_path.exists():
                write_text(system_path, content)
                print(f"[OK] Created {system_path}")
    
        src_dir = SYSTEM_ROOT / "src"
        for name, content in load_default_src_files().items():
            src_path = src_dir / name
            if overwrite or not src_path.exists():
                write_text(src_path, content)
                print(f"[OK] Created {src_path}")
    
        if not LAST_RUN_PATH.exists():
            write_last_run({"stage": "idle", "updated_at": now_iso()})
    
        print("[OK] Atlas structure initialized.")
        print("[INFO] Run the prompt in .atlas/.system/prompts/onboarding.md to complete setup.")
        return 0
    
    
    def intake_command(args: argparse.Namespace) -> int:
        domain = args.domain.upper()
        brief_id = next_id("BRIEF", domain, BRIEF_DIR, BRIEF_ID_PATTERN)
    
        title_src = " ".join(args.text.strip().splitlines()).strip()
        title = title_src[:60] + ("..." if len(title_src) > 60 else "")
        if not title:
            title = "User Request"
    
        content = f"""# [{brief_id}] {title}
    
    > **ID**: {brief_id}
    > **Domain**: {domain}
    > **Status**: Active
    > **Date**: {now_date()}
    
    ## 1. User Request
    {args.text.strip()}
    
    ## 2. Intent Summary
    - Goal: 
    - Problem: 
    
    ## 3. Affected Artifacts
    - Create: 
    - Modify: 
    - Read: 
    
    ## 4. Proposed Changes
    1. 
    2. 
    
    ## 5. Verification Criteria
    - [ ] 
    """
        path = BRIEF_DIR / f"{brief_id}.md"
        write_text(path, content)
        print(f"[OK] Created {path}")
        return 0
    
    
    def create_req_stub(req_id: str) -> None:
        path = REQ_DIR / f"{req_id}.md"
        if path.exists():
            return
        match = REQ_ID_PATTERN.match(req_id)
        if not match:
            return
        domain = match.group(1)
        template = load_template("REQ.md")
        content = (
            template.replace("REQ-XXX-001", req_id)
            .replace("Domain**: XXX", f"Domain**: {domain}")
            .replace("Last Updated**: YYYY-MM-DD", f"Last Updated**: {now_date()}")
        )
        write_text(path, content)
    
    
    def plan_command(args: argparse.Namespace) -> int:
        brief_id = args.brief_id
        if brief_id.endswith(".md"):
            brief_id = Path(brief_id).stem
    
        match = BRIEF_ID_PATTERN.match(brief_id)
        if not match:
            print(f"[ERR] Invalid BRIEF ID: {brief_id}")
            return 1
    
        brief_path = BRIEF_DIR / f"{brief_id}.md"
        if not brief_path.exists():
            print(f"[ERR] BRIEF not found: {brief_path}")
            return 1
    
        domain = match.group(1)
        number = match.group(2)
        run_id = f"RUN-BRIEF-{domain}-{number}-step-01"
        run_path = RUN_DIR / f"{run_id}.md"
        if run_path.exists():
            print(f"[ERR] RUN already exists: {run_path}")
            return 1
    
        brief_text = read_text(brief_path)
        artifacts = parse_affected_artifacts(brief_text)
        req_ids = [
            rid
            for rid in extract_ids_from_text(" ".join(artifacts["Create"] + artifacts["Modify"]))
            if rid.startswith("REQ-")
        ]
        for req_id in req_ids:
            create_req_stub(req_id)
    
        input_lines = [f"- {brief_id}"]
        for req_id in req_ids:
            input_lines.append(f"- {req_id}")
    
        content = f"""# [{run_id}] Plan
    
    > **ID**: {run_id}
    > **Brief**: {brief_id}
    > **Status**: Planned
    > **Started**: {now_date()}
    > **Git**: -
    > **Completed**: -
    
    ## Input
    {os.linesep.join(input_lines)}
    
    ## Steps
    - [ ] 
    
    ## Verification
    - [ ] Test
    - [ ] Spec
    - [ ] Boundary
    
    ## Output
    - (files created/modified)
    """
        write_text(run_path, content)
    
        write_last_run(
            {
                "run_id": run_id,
                "brief_id": brief_id,
                "stage": "executing",
                "updated_at": now_iso(),
            }
        )
    
        print(f"[OK] Created {run_path}")
        return 0
    
    
    def finish_command(args: argparse.Namespace) -> int:
        run_id = args.run_id
        if run_id.endswith(".md"):
            run_id = Path(run_id).stem
    
        if not RUN_ID_PATTERN.match(run_id):
            print(f"[ERR] Invalid RUN ID: {run_id}")
            return 1
    
        run_path = RUN_DIR / f"{run_id}.md"
        if not run_path.exists():
            print(f"[ERR] RUN not found: {run_path}")
            return 1
    
        text = read_text(run_path)
        meta = extract_meta(text)
        brief_id = meta.get("Brief")
        status = "Completed" if args.success else "Failed"
        text = update_meta_line(text, "Status", status)
        text = update_meta_line(text, "Git", args.git)
        text = update_meta_line(text, "Completed", now_date())
        write_text(run_path, text)
    
        if brief_id:
            update_brief_status(brief_id, status)
    
        last_run_state = {
            "run_id": run_id,
            "stage": "finished",
            "git_hash": args.git,
            "completed_at": now_iso(),
        }
        if brief_id:
            last_run_state["brief_id"] = brief_id
        write_last_run(last_run_state)
    
        print(f"[OK] Updated {run_path}")
        return 0
    
    
    def sync_command(args: argparse.Namespace) -> int:
        """Sync RUN status to BRIEF/REQ documents."""
        run_id = args.run_id
        if run_id.endswith(".md"):
            run_id = Path(run_id).stem
    
        if not RUN_ID_PATTERN.match(run_id):
            print(f"[ERR] Invalid RUN ID: {run_id}")
            return 1
    
        run_path = RUN_DIR / f"{run_id}.md"
        if not run_path.exists():
            print(f"[ERR] RUN not found: {run_path}")
            return 1
    
        # Generate diff
        diff = generate_sync_diff(run_path)
        
        # Always print diff (dry-run info)
        print_sync_diff(diff)
        
        # Check if any apply flags are set
        apply_brief = getattr(args, "apply_brief", False)
        apply_req = getattr(args, "apply_req", False)
        write_patch = getattr(args, "write_req_patch", False)
        
        if not (apply_brief or apply_req or write_patch):
            print("\n[INFO] Dry-run mode. Use --apply-brief, --write-req-patch, or --apply-req to make changes.")
            return 0
        
        # Apply RUN changes (always when any apply flag is set)
        if diff["run"]["changes"]:
            run_text = read_text(run_path)
            for change in diff["run"]["changes"]:
                if change["type"] == "status":
                    run_text = update_meta_line(run_text, "Status", change["to"])
            write_text(run_path, run_text)
            print(f"[OK] Updated {run_path}")
        
        # Apply BRIEF changes
        if apply_brief:
            apply_brief_changes(diff)
        
        # Write REQ patch
        if write_patch:
            write_req_patch(diff)
        
        # Apply REQ changes (with warning)
        if apply_req:
            apply_req_changes(diff)
        
        return 0
    
    
    def iter_links(text: str) -> list[str]:
        links = []
        in_code = False
        for line in text.splitlines():
            stripped = line.strip()
            if stripped.startswith("```"):
                in_code = not in_code
                continue
            if in_code:
                continue
            for match in LINK_RE.finditer(line):
                links.append(match.group(1).strip())
        return links
    
    
    def doctor_command(args: argparse.Namespace) -> int:
        issues = 0
        brief_statuses: dict[str, str] = {}
        run_brief_statuses: list[tuple[str, str, str, Optional[datetime]]] = []
    
        required_dirs = [REQ_DIR, RULE_DIR, CQ_DIR, BRIEF_DIR, RUN_DIR, SYSTEM_ROOT, TEMPLATES_DIR, STATE_DIR]
        for path in required_dirs:
            if not path.exists():
                print(f"[ERR] Missing directory: {path}")
                issues += 1
    
        for path in REQUIRED_TOP_DOCS:
            if not path.exists():
                print(f"[ERR] Missing top doc: {path}")
                issues += 1
    
        for path in OPTIONAL_TOP_DOCS:
            if not path.exists():
                print(f"[WARN] Missing optional doc: {path}")
    
        scan_dirs = [REQ_DIR, RULE_DIR, CQ_DIR, BRIEF_DIR, RUN_DIR]
        all_docs = iter_md_files(scan_dirs)
        all_ids: set[str] = set()
    
        for path in all_docs:
            text = read_text(path)
            meta = extract_meta(text)
            meta_id = meta.get("ID")
            header_id = extract_header_id(text)
            file_id = path.stem
            for candidate in [meta_id, header_id, file_id]:
                if candidate:
                    all_ids.add(candidate)
    
        for path in all_docs:
            text = read_text(path)
            meta = extract_meta(text)
            meta_id = meta.get("ID")
            header_id = extract_header_id(text)
            file_id = path.stem
    
            folder = path.parent.name
            expected_prefix = {
                "req": "REQ",
                "rule": "RULE",
                "cq": "CQ",
                "brief": "BRIEF",
                "runs": "RUN",
            }.get(folder)
    
            if expected_prefix is None:
                continue
    
            if expected_prefix == "BRIEF":
                status = meta.get("Status")
                if not status:
                    print(f"[ERR] Missing Status: {path}")
                    issues += 1
                else:
                    brief_statuses[file_id] = status
    
            if expected_prefix == "RUN":
                brief_id = meta.get("Brief")
                run_status = meta.get("Status")
                completed = meta.get("Completed")
                if brief_id and run_status:
                    run_brief_statuses.append(
                        (file_id, brief_id, run_status, parse_completed_date(completed))
                    )
                if file_id.startswith("RUN-BRIEF-") and not brief_id:
                    print(f"[WARN] Missing Brief reference: {path}")
                    issues += 1
    
            if not meta_id:
                print(f"[ERR] Missing meta ID: {path}")
                issues += 1
            if not header_id:
                print(f"[ERR] Missing header ID: {path}")
                issues += 1
    
            pattern = {
                "REQ": REQ_ID_PATTERN,
                "RULE": RULE_ID_PATTERN,
                "CQ": CQ_ID_PATTERN,
                "BRIEF": BRIEF_ID_PATTERN,
                "RUN": RUN_ID_PATTERN,
            }[expected_prefix]
    
            if not pattern.match(file_id):
                print(f"[ERR] Invalid filename for {expected_prefix}: {path}")
                issues += 1
    
            if meta_id and meta_id != file_id:
                print(f"[ERR] Meta ID mismatch: {path}")
                issues += 1
            if header_id and header_id != file_id:
                print(f"[ERR] Header ID mismatch: {path}")
                issues += 1
    
            if expected_prefix in {"REQ", "RULE"}:
                must_read = meta.get("Must-Read")
                if must_read is None:
                    print(f"[ERR] Missing Must-Read: {path}")
                    issues += 1
                else:
                    ids = parse_must_read(must_read)
                    if not ids and must_read.strip().lower() != "none":
                        print(f"[ERR] Empty Must-Read: {path}")
                        issues += 1
                    for ref_id in ids:
                        prefix = ref_id.split("-", 1)[0]
                        if prefix not in ALLOWED_MUST_READ_PREFIXES:
                            print(f"[ERR] Must-Read disallowed ID: {path} -> {ref_id}")
                            issues += 1
                        if ref_id not in all_ids:
                            print(f"[ERR] Must-Read missing target: {path} -> {ref_id}")
                            issues += 1
    
            if args.links:
                for target in iter_links(text):
                    if not target or target.startswith("#"):
                        continue
                    if re.match(r"^[a-zA-Z][a-zA-Z0-9+.-]*:", target):
                        continue
                    resolved = (path.parent / target).resolve()
                    if not resolved.exists():
                        print(f"[ERR] Broken link: {path} -> {target}")
                        issues += 1
    
        latest_run_by_brief: dict[str, tuple[str, str, Optional[datetime]]] = {}
        for run_id, brief_id, run_status, completed_at in run_brief_statuses:
            normalized = normalize_status(run_status)
            if normalized not in {"completed", "failed"}:
                continue
            existing = latest_run_by_brief.get(brief_id)
            if existing is None:
                latest_run_by_brief[brief_id] = (run_id, run_status, completed_at)
                continue
            existing_run_id, _, existing_completed = existing
            if completed_at and (existing_completed is None or completed_at > existing_completed):
                latest_run_by_brief[brief_id] = (run_id, run_status, completed_at)
            elif completed_at is None and existing_completed is None and run_id > existing_run_id:
                latest_run_by_brief[brief_id] = (run_id, run_status, completed_at)
    
        for brief_id, (run_id, run_status, _) in latest_run_by_brief.items():
            brief_status = brief_statuses.get(brief_id)
            if not brief_status:
                print(f"[WARN] BRIEF missing for RUN: {run_id} -> {brief_id}")
                issues += 1
                continue
            if normalize_status(brief_status) != normalize_status(run_status):
                print(
                    f"[WARN] BRIEF status mismatch: {brief_id} is {brief_status}, latest RUN {run_id} is {run_status}"
                )
                issues += 1
    
        if LAST_RUN_PATH.exists():
            try:
                state = json.loads(read_text(LAST_RUN_PATH))
            except json.JSONDecodeError:
                state = {}
                print(f"[ERR] Invalid JSON: {LAST_RUN_PATH}")
                issues += 1
            stage = state.get("stage")
            updated_at = state.get("updated_at") or state.get("completed_at")
            if stage == "executing" and updated_at:
                try:
                    ts = datetime.fromisoformat(updated_at)
                    if datetime.now() - ts > timedelta(hours=args.max_age_hours):
                        print(
                            f"[WARN] RUN may be unfinished (>{args.max_age_hours}h): {state.get('run_id')}"
                        )
                        issues += 1
                except ValueError:
                    print("[ERR] Invalid timestamp in last_run.json")
                    issues += 1
    
        print(f"[DONE] Doctor completed with {issues} issue(s).")
        return 0 if issues == 0 else 1
    
    
    def build_parser() -> argparse.ArgumentParser:
        parser = argparse.ArgumentParser(prog="atlas")
        parser.add_argument(
            "--version", "-v",
            action="version",
            version=f"Atlas {get_version()}"
        )
        sub = parser.add_subparsers(dest="command", required=False)
    
        init = sub.add_parser("init")
        init.add_argument("--overwrite", action="store_true")
    
        intake = sub.add_parser("intake")
        intake.add_argument("text")
        intake.add_argument("--domain", default="GEN")
    
        plan = sub.add_parser("plan")
        plan.add_argument("brief_id")
    
        finish = sub.add_parser("finish")
        finish.add_argument("run_id")
        finish.add_argument("--git", required=True)
        finish.add_argument("--success", type=lambda v: v.lower() == "true", required=True)
    
        doctor = sub.add_parser("doctor")
        doctor.add_argument("--links", action="store_true")
        doctor.add_argument("--max-age-hours", type=int, default=24)
    
        sync = sub.add_parser("sync", help="Sync RUN status to BRIEF/REQ documents")
        sync.add_argument("run_id", help="RUN document ID")
        sync.add_argument("--apply-brief", action="store_true", help="Apply changes to BRIEF document")
        sync.add_argument("--write-req-patch", action="store_true", help="Write REQ patch file")
        sync.add_argument("--apply-req", action="store_true", help="Apply changes to REQ document (caution)")
    
        return parser
    
    
    def main(argv: Optional[list[str]] = None) -> int:
        parser = build_parser()
        args = parser.parse_args(argv)
    
        if not args.command:
            parser.print_help()
            return 0
    
        if args.command != "init" and not ATLAS_ROOT.exists():
            print("[INFO] .atlas not found. Initializing...")
            init_command(args)
    
        if args.command == "init":
            return init_command(args)
        if args.command == "intake":
            return intake_command(args)
        if args.command == "plan":
            return plan_command(args)
        if args.command == "finish":
            return finish_command(args)
        if args.command == "doctor":
            return doctor_command(args)
        if args.command == "sync":
            return sync_command(args)
    
        parser.print_help()
        return 1
    
    
    if __name__ == "__main__":
        raise SystemExit(main())
    